-- ~~~~~~
-- Script by dzikakulka
-- Issues, history at: http://github.com/tjakubo2/TTS_xwing
--
-- Based on a work of: Flolania, Hera Vertigo
-- ~~~~~~

-- ~~~~~~
-- Code contributions
--  - Characted width data: Indimeco
--  - http://github.com/Indimeco/Tabletop-Simulator-Misc
-- ~~~~~~

-- Should the code execute print functions or skip them?
-- This should be set to false on every release
print_debug = false
cast_debug = false

TTS_print = print
function print(...)
    if print_debug == true then
        TTS_print(table.unpack({...}))
    end
end

-- Vector manipulation
#include TTS_lib/Vector/Vector

-- Standard libraries extentions
#include TTS_lib/Util/Util

-- Standard event handling
#include TTS_lib/EventSub/EventSub

-- Object type abstraction
#include TTS_lib/ObjType/ObjType


-- Save/load management
#include TTS_lib/SaveManager/SaveManager

-- Component sizes, unit conversion methods
#include TTS_xwing/src/Dimensions

-- AI behaviour sets
#include TTS_xwing/src/BehaviourDB

-- Dice control and dice_statistics
#include TTS_xwing/src/DiceControl

-- Ship verification
#include TTS_xwing/src/ShipVerification

-- ContextGui
#include TTS_xwing/src/ContextGui


-- Modules API, must be loaded last
#include TTS_xwing/src/API

--------
-- MISC FUNCTIONS

-- Dumbest TTS issue ever workaround
function TTS_Serialize(pos)
    return {pos[1], pos[2], pos[3]}
end

ObjType.AddType('ship', function(obj)
    return ((obj.tag == 'Figurine') and (obj.getVar('__XW_Ship') == true))
end)
ObjType.AddType('token', function(obj)
    return (obj.tag == 'Chip' or obj.tag == 'Coin' or (obj.getVar('__XW_Token') and obj.getVar('__XW_TokenIdle')))
end)
ObjType.AddType('dial', function(obj)
    return (obj.tag == 'Card' and XW_cmd.CheckCommand(obj.getDescription()) == 'move')
end)


-- Dud function for info buttons and not yet written sections where Lua complains about no code
function dummy() return end

-- END MISC FUNCTIONS
--------


--------
-- COMMAND HANDLING MODULE
-- Sanitizes input (more like ignores anything not explicitly allowed)
-- Allows other modules to add available commands and passes their execution where they belong

XW_cmd = {}
XW_cmd.commandLUT = {}

-- Table of valid commands: their patterns and general types
XW_cmd.ValidCommands = {}

-- Add given regen expression as a valid command for processing
XW_cmd.AddCommand = function(cmdRegex, type)
    -- When adding available commands, assert beggining and end of string automatically
    if cmdRegex:sub(1,1) ~= '^' then cmdRegex = '^' .. cmdRegex end
    if cmdRegex:sub(-1,-1) ~= '$' then cmdRegex = cmdRegex .. '$' end
    table.insert(XW_cmd.ValidCommands, {string.lower(cmdRegex), type})
end

-- Check if command is registered as valid
-- If it is return its type identifier, if not return nil
XW_cmd.CheckCommand = function(cmd)
    -- Trim whitespaces
    cmd = string.lower(cmd:match( "^%s*(.-)%s*$" ))
    local type = nil
    if XW_cmd.commandLUT[cmd] then
        return XW_cmd.commandLUT[cmd]
    end
    -- Resolve command type
    for k,pat in pairs(XW_cmd.ValidCommands) do
        if cmd:match(pat[1]) ~= nil then
            type = pat[2]
            break
        end
    end
    XW_cmd.commandLUT[cmd] = type
    return type
end

-- (special function)
-- Purge all save data (everything that goes to onSave)
XW_cmd.AddCommand('purgeSave', 'special')
XW_cmd.PurgeSave = function()
    MoveModule.moveHistory = {}
end

-- (special function)
-- Print ship hitory
XW_cmd.AddCommand('hist', 'special')
XW_cmd.ShowHist = function(ship)
    MoveModule.PrintHistory(ship)
end

-- (special function)
-- Check for typical issues with a ship
XW_cmd.AddCommand('diag', 'special')
XW_cmd.Diagnose = function(ship)
    -- Check and unlock XW_cmd lock if it's on
    local issueFound = false
    if ObjType.IsOfType(ship, 'ship') ~= true then return end
    if XW_cmd.isReady(ship) ~= true then
        XW_cmd.SetReady(ship)
        printToAll(ship.getName() .. '\'s deadlock resolved', {0.1, 0.1, 1})
        issueFound = true
    end
    -- Delete lingering buttons
    if ship.getButtons() ~= nil then
        ship.clearButtons()
        printToAll(ship.getName() .. '\'s lingering buttons deleted', {0.1, 0.1, 1})
        issueFound = true
    end
    -- If ship has unrecognized model and said that before, remind
    if ship.getVar('missingModelWarned') == true then
        printToAll('I hope you do remember that I told you about ' .. ship.getName() .. '\'s model being unrecognized when it was first moved/used', {0.1, 0.1, 1})
        issueFound = true
    end
    -- No issues found
    if issueFound ~= true then
        printToAll(ship.getName() .. ' looks OK', {0.1, 1, 0.1})
    end
end

-- Process provided command on a provided object
-- Return true if command has been executed/started
-- Return false if object cannot process commands right now or command was invalid
XW_cmd.Process = function(obj, cmd)

    -- Trim whitespaces
    cmd = cmd:match( "^%s*(.-)%s*$" )

    -- Resolve command type
    local type = XW_cmd.CheckCommand(cmd)

    -- Process special commands without taking lock into consideration
    if type == nil then
        return false
    elseif type == 'special' then
        if cmd == 'diag' then
            XW_cmd.Diagnose(obj)
        elseif cmd == 'purgeSave' then
            XW_cmd.PurgeSave()
        elseif cmd == 'hist' then
            XW_cmd.ShowHist(obj)
        end
    end

    -- Return if not ready, else process
    if XW_cmd.isReady(obj) ~= true then
        return false
    end

    if type == 'demoMove' then
        MoveModule.DemoMove(cmd:sub(3, -1), obj)
    elseif type == 'move' or type == 'actionMove' then
        local info = MoveData.DecodeInfo(cmd, obj)
        MoveModule.PerformMove(cmd, obj)
    elseif type == 'historyHandle' then
        if cmd == 'q' or cmd == 'undo' then
            MoveModule.UndoMove(obj)
        elseif cmd == 'z' or cmd == 'redo' then
            MoveModule.RedoMove(obj)
        elseif cmd == 'keep' then
            MoveModule.SaveStateToHistory(obj, false)
        elseif cmd:sub(1,8) == 'restore#' then
            local keyNum = tonumber(cmd:sub(9, -1))
            MoveModule.Restore(obj, keyNum)
        end
    elseif type == 'dialHandle' then
        if cmd == 'sd' then
            DialModule.SaveNearby(obj)
        elseif cmd == 'rd' then
            DialModule.RemoveSet(obj)
        end
    elseif type == 'rulerHandle' then
        RulerModule.ToggleRuler(obj, string.upper(cmd))
    elseif type == 'action' then
        DialModule.PerformAction(obj, cmd)
    elseif type == 'bombDrop' then
        BombModule.ToggleDrop(obj, cmd)
    elseif type == 'AI' then
        AIModule.EnableAI(obj, cmd)
    end
    obj.setDescription('')
    return true
end

-- Is object not processing some commands right now?
XW_cmd.isReady = function(obj)
    return (obj.getVar('cmdBusy') ~= true)
end

-- Flag the object as processing commands to ignore any in the meantime
XW_cmd.SetBusy = function(obj)
    if XW_cmd.isReady(obj) ~= true then
        print('Nested process on ' .. obj.getName())
    end
    obj.setVar('cmdBusy', true)
end

-- Flag the object as ready to process next command
XW_cmd.SetReady = function(obj)
    if XW_cmd.isReady(obj) == true then
        print('Double ready on ' .. obj.getName())
    end
    obj.setVar('cmdBusy', false)
end

--------
-- MOVEMENT DATA MODULE
-- Stores and processes data about moves
-- NOT aware of any ship position, operation solely on relative movements
-- Used for feeding data about a move to a higher level movement module
-- Exclusively uses milimeters and degrees for values, needs external conversion

-- Possible commands supported by this module
XW_cmd.AddCommand('[sk][012345][r]?', 'move')   -- Straights/Koiograns + stationary moves
XW_cmd.AddCommand('b[rle][0123][strz]?', 'move')   -- Banks + segnor and reverse versions
XW_cmd.AddCommand('t[rle][01234][srfbtz]?[t]?', 'move')

XW_cmd.AddCommand('r[rle][123]?', 'actionMove')       --New Roll Done
XW_cmd.AddCommand('v[rle][fb][123]?', 'actionMove')   --New ViperRoll
XW_cmd.AddCommand('c[srle][123]?', 'actionMove')      --New Cloak side
XW_cmd.AddCommand('e[srle][fbrle][123]?', 'actionMove')   --New Echo Cloack


XW_cmd.AddCommand('x[rle][fb]?', 'actionMove')  -- Barrel rolls
XW_cmd.AddCommand('s[12345]b', 'actionMove')    -- Boost straights
XW_cmd.AddCommand('b[rle][123]b', 'actionMove') -- Boost banks
XW_cmd.AddCommand('t[rle][123]b', 'actionMove') -- Boost turns
XW_cmd.AddCommand('a[12]', 'actionMove')        -- Adjusts
--XW_cmd.AddCommand('c[srle]', 'actionMove')      -- Decloaks side middle + straight
--XW_cmd.AddCommand('c[rle][fb]', 'actionMove')   -- Decloaks side forward + backward
--XW_cmd.AddCommand('ch[rle][fb]', 'actionMove')  -- Echo's bullshit
--XW_cmd.AddCommand('chs[rle]', 'actionMove')     -- Echo's bullshit, part 2
--XW_cmd.AddCommand('vr[rle][fb]', 'actionMove')  -- StarViper Mk.II rolls

-- AI Module:
test_AI = false
AIModule = {}

-- 2000mm is the length between opposite corners of an epic table.
AIModule.max_distance = 2000

-- Information about the most recently executed maneuver by an AI ship. This is
-- stored just before we move the ship, and it used when the ship comes to rest
-- and the callback is fired. Yes, this is a bit of a hack, and yes, I'd love to
-- do it a better way.
AIModule.current_move = {}
AIModule.current_move.in_progress = false
AIModule.current_move.Reset = function()
    AIModule.current_move.take_action = false
    AIModule.current_move.move_code = nil
    AIModule.current_move.collision = false
    AIModule.current_move.difficulty = nil
    AIModule.current_move.obstacle = false
    AIModule.current_move.stress_count = 0
    AIModule.current_move.is_ionised = false
    AIModule.current_move.target = nil
    AIModule.current_move.probes = {}
    AIModule.current_move.action_stack = {}
    AIModule.current_move.actions = {}
end
AIModule.current_move.Reset()



-- Possible commands supported by the AI module
XW_cmd.AddCommand('ai', 'AI')   -- Enables the AI on the selected ship

-- Description function to add the AI functions to a ship
AIModule.EnableAI = function(ship, command)
    ship.AddContextMenuItem("AI move and action", function(argument) Global.call("PerformAIManeuver", {['ship']=ship, ['take_action']=true}) end, false)
    ship.AddContextMenuItem("AI move only", function(argument) Global.call("PerformAIManeuver", {['ship']=ship, ['take_action']=false}) end, false)
end

-- Sanity check, make sure that all the moves for this ship are actually
-- possible. It won't fix every issue but it'll find most typos. This is not
-- called except when debugging.
AIModule.ValidateMoveTables = function(ship)
    local ship_id = ship.getTable('Data')['shipId']
    local rule_set = BehaviourDB.GetRuleSet()
    local behaviour = rule_set.ships[ship_id]

    for arc, range_tables in pairs(behaviour.move_table) do
        for range, move_table in pairs(range_tables) do
            for roll, move_code in pairs(move_table) do
                if AIModule.GetMoveDifficulty(ship, move_code) == nil then
                    print("Couldn't find maneuver " .. move_code .. " from ship " .. tostring(ship_id) .. "'s move table. Arc: " .. arc .. ", range: " .. range .. ", roll: " .. tostring(roll))
                end
            end
        end
    end
end

--[[ AI target selection

Target selection is the simplest of the AI submodules. It consists of a set of
functions for different selection types, each of which takes the querying ship
and returns a target ship. There are also some helper methods for filtering
targets by various metrics.
]]

-- Target selection functions. These take a ship, and return a target ship
AIModule.TargetSelectionFunctions = {}
AIModule.TargetSelectionFunctions.ClosestInArc = function(ship)
    local targets = AIModule.GetSortedTargetsInArc(ship)

    -- Get the first ship as it's already been sorted by distance
    for i, target in pairs(targets) do
        return target.ship
    end

    return nil
end

AIModule.TargetSelectionFunctions.Closest = function(ship)
    local potential_targets = ArcCheck.GetPotentialTargets(ship, AIModule.max_distance)

    local closest_distance = nil
    local closest_target = nil
    for i, target in pairs(potential_targets) do
        local distance = Vect.Length(ship.getPosition() - target.GetPosition())
        if closest_distance == nil or distance < closest_distance then
            closest_distance = distance
            closest_target = target
        end
    end

    return closest_target
end

AIModule.TargetSelectionFunctions.LockedInRange = function(ship)
    local potential_targets = AIModule.GetSortedTargetsInArc(ship, 'all')
    potential_targets = table.sieve(potential_targets, AIModule.FilterInRange)

    local closest_distance = nil
    local closest_target = nil
    for i, target in pairs(potential_targets) do
        -- Is this ship locked by us?
        if AIModule.HasTargetLockOnShip(ship, target.ship) then
            local distance = Vect.Length(ship.getPosition() - target.ship.GetPosition())
            if closest_distance == nil or distance < closest_distance then
                closest_distance = distance
                closest_target = target.ship
            end
        end
    end

    return closest_target
end

AIModule.TargetSelectionFunctions.ClosestInArcLowerInitiative = function(ship)
    local initiative = ship.getTable('Data')['initiative']
    local targets = AIModule.GetSortedTargetsInArc(ship)

    -- Get the first ship with a lower initiative as it's already been sorted by
    -- distance.
    for i, target in pairs(targets) do
        if (target.ship.getTable('Data')['initiative'] < initiative) then
            return target.ship
        end
    end

    return nil
end

-- Only choose ships that are in arc and between ranges 1-3
AIModule.FilterInArc = function(el)
    if el.in_arc == false then
        return false
    end

    return true;
end

-- Only choose ships that are between range one and three
AIModule.FilterInRange = function(el)
    if el.closest.range < 1 or el.closest.range > 3 then
        return false
    end

    return true;
end

-- Assumed to have been filtered first
AIModule.SortTargetsByAIDesirability = function(e1, e2)
    if e1.closest ~= nil and e2.closest ~= nil then
        if e1.closest.length < e2.closest.length then
            return true
        elseif e1.closest.length > e2.closest.length then
            return false
        end
    end

    return e1.ship.getGUID() > e2.ship.getGUID()
end

AIModule.GetSortedTargetsInArc = function(ship, arc)
    local targets = ArcCheck.GetTargetsInRelationToArc(ship, arc or 'front')
    targets = table.sieve(targets, AIModule.FilterInArc)
    targets = table.sieve(targets, AIModule.FilterInRange)
    table.sort(targets, AIModule.SortTargetsByAIDesirability)
    return targets
end

AIModule.HasTargetLockOnShip = function(locking_ship, locked_ship)
    local lock_tokens = locked_ship.call("GetTokens", {type="targetLock"})
    for j, token in pairs(lock_tokens) do
        if token.GetName() == locking_ship.GetName() then -- TODO: this really should be guid
            return true
        end
    end

    return false
end


--[[ AI maneuver selection

The maneuver selection is the main submodule of the AI, as well as the one that
ties most of the others together. It is home to one of the entry points,
"PerformAIManever". The main function, AIModule.PerformManeuver, uses the
target selection functions to pick a target, then plots a maneuver based on
the move tables in BehaviourDB.ttslua. It also cover stress, ion, and obstacle
avoidance.

Worth noting is that due to having to wait for ships to finish moving, part of
the functionality of AIModule.PerformManeuver had to be split out to a callback
function, AIModule.ManeuverPostShipRest. This handles everything after the
maneuver is executed, including calling the action submodule.

It also includes various helper functions for searching through and transforming
manveuvers.
]]
function PerformAIManeuver(args)
    local ship = args.ship
    local take_action = args.take_action

    AIModule.PerformManeuver(ship, take_action)
end

AIModule.PerformManeuver = function(ship, take_action)
    if AIModule.current_move.in_progress then
        printToAll("Can't perform AI maneuver while another ship is moving.", color(1.0, 1.0, 0.2, 0.9))
        return
    end

    --AIModule.ValidateMoveTables(ship)
    AIModule.current_move.Reset()
    AIModule.current_move.stress_count = TokenModule.GetShipTokenCount(ship, "Stress")
    AIModule.current_move.take_action = take_action
    local stress = AIModule.current_move.stress_count > 0

    local rule_set = BehaviourDB.GetRuleSet()

    local ship_id = ship.getTable('Data')['shipId']
    local ship_behaviour = rule_set.ships[ship_id]

    if ship_behaviour ~= nil then
        printToAll('Performing AI routine for ' .. ship.GetName(), color(1.0, 1.0, 0.2, 0.9))
        local move_code = nil

        -- Find this ship's target.
        local target_ship = nil
        for _, target_selection_function in ipairs(ship_behaviour.target_selection) do
            target_ship = AIModule.TargetSelectionFunctions[target_selection_function](ship)
            if target_ship ~= nil then
                break
            end
        end
        AIModule.current_move.target = target_ship

        -- Check if we're ionised.
        local is_ionised = AIModule.IsIonised(ship)
        AIModule.current_move.is_ionised = is_ionised

        if target_ship == nil then
            -- TODO: This is undefined behaviour, and highly unlikely to happen.
            -- Should it default to a 2 straight?
            printToAll('Failed to find target')
        elseif is_ionised == true then
            move_code = 's1'
            printToAll('Ionised, skipping movement selection')
        else
            -- Find out the arc that the target is in.
            local target_arc = nil
            local arc_parts = nil

            local ship_size = ship.getTable("Data").Size or 'small'

            if rule_set.useBullseyeArc then
                -- First do a check to see if the ship is in our bullseye.
                -- Move the bullseye position ahead because it's in the middle of
                -- range ruler rather than one end. Could this be moved into the
                -- GetBullseyeTargets function?
                local bullseye_position = vector(ArcCheck.bullseye_data.pos[ship_size][1], ArcCheck.bullseye_data.pos[ship_size][2], ArcCheck.bullseye_data.pos[ship_size][3] + Convert_mm_igu(AIModule.max_distance / 2) - (ArcCheck.bullseye_data.size[3] / 2))
                local bullseye_targets = ArcCheck.GetBullseyeTargets(ship, bullseye_position, AIModule.max_distance)
                for i, bullseye_target in pairs(bullseye_targets) do
                    if bullseye_target == target_ship then
                        target_arc = 'bullseye'
                        arc_parts = {'front'}
                        break
                    end
                end
            end

            if target_arc == nil then
                -- We have our target ship. Now we do some vector maths to get
                -- the angle pointing from our ship to the target ship.
                local ship_facing = Vect.RotateDeg({0, 0, -1}, ship.GetRotation().y)
                local ship_to_target = target_ship.GetPosition() - ship.getPosition()
                local angle_to_target = Vect.AngleDeg(ship_facing, ship_to_target)

                -- angleToTarget is normalised between 0 and 180, to work out if
                -- if it's pointing to our left or our right we need to get the
                -- dot product of the shipToTarget vector and the tangent to our
                -- facing.
                local ship_facing_tangent = {ship_facing[3], 0, -ship_facing[1]}
                local tangent_dot_product = Vect.DotProd(ship_to_target, ship_facing_tangent)
                if tangent_dot_product < 0 then
                    angle_to_target = angle_to_target * -1
                end

                 arc_result = rule_set.degreesToArc(angle_to_target)
                 target_arc = arc_result.target_arc
                 arc_parts = arc_result.arc_parts
            end

            -- Find the range bracket - one of closing, fleeing, distant, or
            -- stress.
            local range_bracket = nil
            if stress then
                range_bracket = 'stress'
                printToAll(' Selected target: ' .. target_ship.getName() .. ', in the ' .. target_arc .. ' arc, while stressed.')
            else
                local target_range = nil
                -- Find the range, if we haven't got it already.
                -- TODO: If a ship is at range 0, then treat it as range 1 and
                -- behind our ship. (pg 19, "Touching")
                if target_range == nil then
                    -- TODO: Wrap up this code in a re-useable function
                    local own_line_segments = {}
                    for i, arc in ipairs(arc_parts) do
                        local segments = ArcCheck.GetOwnArcLineSegments(ship, ArcCheck.arc_line_segments[ship_size][arc]["segments"])
                        for k, segment in ipairs(segments) do
                            table.insert(own_line_segments, segment)
                        end
                    end

                    local target_line_segments = {}
                    for i, arc in ipairs(arc_parts) do
                        local segments = ArcCheck.GetTargetLineSegmentsInArc(ship, target_ship, ArcCheck.arc_line_segments[ship_size][arc]["degrees"])
                        for k, segment in ipairs(segments) do
                            table.insert(target_line_segments, segment)
                        end
                    end

                    if #target_line_segments ~= 0 then
                        local closest = nil
                        closest, _ = ArcCheck.GetDistanceBetweenLineSegments(own_line_segments, target_line_segments)
                        target_range = closest.range
                    end
                end

                -- If we're at range 2, then we need to check if the target is
                -- moving towards us (closing) or moving away from us (fleeing)
                target_closing = nil
                closing_text = '.'
                if target_range == 2 then
                    local target_ship_facing = Vect.RotateDeg({0, 0, -1}, target_ship.GetRotation().y)
                    local target_to_ship = ship.getPosition() - target_ship.GetPosition()
                    local angle_to_ship = Vect.AngleDeg(target_ship_facing, target_to_ship)

                    if (angle_to_ship < 90) then
                        target_closing = true
                        closing_text = ' and closing.'
                    else
                        target_closing = false
                        closing_text = ' and fleeing.'
                    end
                end

                printToAll(' Selected target: ' .. target_ship.getName() .. ', in the ' .. target_arc .. ' arc at range ' .. tostring(target_range) .. closing_text)

                -- Get the move for our situation.
                -- Convert our target's range and facing into a range bracket.
                range_bracket = 'distant'
                if (target_range <= 1 or (target_range == 2 and target_closing == true)) then
                    range_bracket = 'near'
                elseif (target_range == 3 or (target_range == 2 and target_closing == false)) then
                    range_bracket = 'far'
                end
            end

            -- Check if we need to flip the facing and the final move.
            local flip_move = ship_behaviour.move_table[target_arc] == nil
            if (flip_move) then
                target_arc = rule_set.flipArc(target_arc)
            end

            -- Roll the d6, and keep substracting 1 until we find a move.
            local d6_roll = math.random(6)
            while move_code == nil and d6_roll > 0 do
                move_code = ship_behaviour.move_table[target_arc][range_bracket][d6_roll]
                d6_roll = d6_roll - 1
            end

            -- If we had to flip the arc, then also flip the resulting move.
            if (flip_move) then
                if string.find(move_code, 'l') then
                    move_code = string.gsub(move_code, 'l', 'r')
                elseif string.find(move_code, 'r') then
                    move_code = string.gsub(move_code, 'r', 'l')
                end
            end
        end

        AIModule.current_move.move_code = move_code

        if move_code ~= nil then
            -- Check for collisions.
            local move_info = MoveData.DecodeInfo(move_code, ship)
            local probe_data = MoveModule.MoveProbe.TryFullMove(move_info, ship, MoveModule.GetFullMove)
            AIModule.current_move.collision = probe_data.collObj ~= nil
            if probe_data.collObs ~= nil then
                printToAll(' Tried ' .. move_code .. ', hit an obstacle')
                AIModule.current_move.obstacle = true
                -- We've hit an obstacle! If we aren't ionised then We'll try to
                -- swerve.
                if is_ionised == false then
                    -- We pick up to two maneuvers that are the closest to our
                    -- current maneuver, and possible for our ship and stress
                    -- level. Whichever of these will get us closer to our
                    -- target is the one that we try. If that move avoids an
                    -- obstacle, then we choose it instead, otherwise we stick
                    -- with our original maneuver.
                    -- TODO: deal with reverse moves
                    local potential_swerve_moves = {}
                    local swerve_speed = tostring(math.max(1, math.min(3, move_info.speed)))
                    if move_info.type == 'straight' then
                        potential_swerve_moves = {'bl' .. swerve_speed, 'br' .. swerve_speed}
                    elseif move_info.type == 'bank' then
                        potential_swerve_moves = {'t' .. string.sub(move_info.dir, 1, 1) .. swerve_speed, 's' .. swerve_speed}
                    elseif move_info.type == 'turn' then
                        potential_swerve_moves = {'b' .. string.sub(move_info.dir, 1, 1) .. swerve_speed}
                    end

                    local swerve_moves = {}
                    for _, potential_swerve_move_code in ipairs(potential_swerve_moves) do
                        -- If we can't do this move, then get the closest move that
                        -- we can do and try that instead. This may be multiple
                        -- moves, for example if a two-bank is impossible then we
                        -- may be able to try a one-bank and a three-bank. They're
                        -- both the same distance from the original so we'll try
                        -- both.
                        local nearest_move_codes = AIModule.GetNearestMoves(ship, potential_swerve_move_code, stress == false)
                        for _, nearest_move_code in ipairs(nearest_move_codes) do
                            table.insert(swerve_moves, nearest_move_code)
                        end
                    end

                    -- Loop through all of the possible swerve moves, and find out
                    -- which one will get us the closest to our target. This is the
                    -- maneuver that we'll try again with.
                    local closest_swerve_move_code = nil
                    local closest_swerve_distance = nil
                    for _, swerve_move_code in ipairs(swerve_moves) do
                        local post_swerve = MoveModule.GetFullMove(swerve_move_code, ship)
                        local post_swerve_position = Vector(post_swerve.pos[1], post_swerve.pos[2], post_swerve.pos[3])
                        local distance = Vect.Length(post_swerve_position - target_ship.GetPosition())
                        if closest_swerve_distance == nil or distance < closest_swerve_distance then
                            closest_swerve_distance = distance
                            closest_swerve_move_code = swerve_move_code
                        end
                    end

                    if closest_swerve_move_code ~= nil then
                        local swerve_move_info = MoveData.DecodeInfo(closest_swerve_move_code, ship)
                        local swerve_probe_data = MoveModule.MoveProbe.TryFullMove(swerve_move_info, ship, MoveModule.GetFullMove)
                        if swerve_probe_data.collObs == nil then
                            move_code = closest_swerve_move_code
                            print(' Tried ' .. closest_swerve_move_code .. ', avoids the obstacle.')
                            AIModule.current_move.obstacle = false
                            AIModule.current_move.collision = swerve_probe_data.collObj ~= nil
                        else
                            print(' Tried ' .. closest_swerve_move_code .. ', still hits an obstacle.')
                        end
                    end
                end
            end

            -- TODO: Check for edge of table collision

            AIModule.current_move.difficulty = 'b'

            -- If we are ionised, then our move is always blue and we remove
            -- all of our ion tokens. Otherwise, we check for our difficulty.
            if is_ionised then
                while TokenModule.GetShipTokenCount(ship, 'Ion') > 0 do
                    -- BUG: This fails to identify the ion token stack if the
                    -- ship has exactly two stress tokens. If this occurs, the
                    -- ship also leaves behind the single remaining stress
                    -- token. I've done a bit of debugging and it appears that
                    -- when a token stack has "takeObject" called on it, it
                    -- changes from a 'chip' type to a 'generic' type. This
                    -- means that it isn't picked up by ObjType.GetNearOfType.
                    -- This does correct itself if the tokens are moved around
                    -- manually, so I assume that this is just a one-frame
                    -- occurence that wouldn't matter if the AI wasn't doing
                    -- everything at the same time. Potential fix: set
                    -- '__XW_Token' on the token afterwards?
                    DialModule.PerformAction(ship, 'Ion', ship.getVar('owningPlayer'), {['remove'] = true})
                end
            else
                AIModule.current_move.difficulty = AIModule.GetMoveDifficulty(ship, move_code)
            end
            -- Remove tokens _before_ the move - if we wait till afterwards then
            -- the tokens haven't caught up with the ship and the token module
            -- doesn't count them.
            if AIModule.current_move.difficulty == 'b' then
                if stress then
                    DialModule.PerformAction(ship, 'Stress', ship.getVar('owningPlayer'), {['remove'] = true})
                    AIModule.current_move.stress_count = AIModule.current_move.stress_count - 1
                end
                if TokenModule.GetShipTokenCount(ship, 'Strain') > 0 then
                    DialModule.PerformAction(ship, 'Strain', ship.getVar('owningPlayer'), {['remove'] = true})
                end
                if TokenModule.GetShipTokenCount(ship, 'Deplete') > 0 then
                    DialModule.PerformAction(ship, 'Deplete', ship.getVar('owningPlayer'), {['remove'] = true})
                end
            end

            AIModule.current_move.in_progress = true
            if MoveModule.PerformMove(move_code, ship, false, AIModule.ManeuverPostShipRest, true) == false then
                -- If the PerformMove function retured false, then the ship
                -- could not move at all. In this case the post-rest callback
                -- won't be fired, so we'll call it ourselves. Also, just in
                -- case, set the collision flag.
                AIModule.current_move.collision = true
                AIModule.ManeuverPostShipRest(ship)
            end
        end
    else
        printToAll('No AI routine found for ship ID ' .. tostring(ship_id), color(1.0, 1.0, 0.2, 0.9))
    end
end

AIModule.ManeuverPostShipRest = function(ship)
    local action_selected = false;

    if AIModule.current_move.difficulty == 'r' then
        DialModule.PerformAction(ship, 'Stress', ship.getVar("owningPlayer"))
    elseif AIModule.current_move.take_action == true and AIModule.current_move.stress_count == 0 and AIModule.current_move.collision == false and AIModule.current_move.obstacle == false then
        if AIModule.current_move.is_ionised then
            -- TODO: Only perform a focus action (if possible)
        else
            -- Check for Full Throttle and apply it now if appropriate.
            AIModule.ApplySpecialAbility(ship, 'fullThrottle')

            -- Run through the ship's actions and try them in order.
            action_selected = AIModule.SelectAction(ship)
        end
    end

    if action_selected then
        AIModule.ProcessActionStack(ship)
    else
        AIModule.current_move.in_progress = false
    end
end

--[[ AIModule.GetMoveDifficulty
This function takes a ship and a move code and returns the difficulty of the
move.

ship: TTS Object, the ship performing the move
move_code: String, the move code being queried.

returns a string corresponding to the difficulty of the move for the ship:
    'b': blue maneuver, reduces stress
    'w': white manuever, stress neutral
    'r': red maneuver, causes stress
    nil: maneuver is impossible for the given ship
]]
AIModule.GetMoveDifficulty = function(ship, move_code)
    move_set = ship.getTable('Data')['moveSet']
    for _, raw_move_code in ipairs(move_set) do
        local ship_move_difficulty = string.sub(raw_move_code, 1, 1)
        local ship_move_code = string.sub(raw_move_code, 2)

        if ship_move_code == move_code then
            return ship_move_difficulty
        end
    end

    return nil
end

--[[ AIModule.GetNearestMoves
This function takes a ship and a move code, and returns the nearest maneuvers
that the ship is capable of. This may be the specified move. "Nearest" is
defined as closest in speed. We won't change the angle of the move. So for
example, if tr1 is passed in we will try tr2 and tr3, but not br1.

ship: TTS Object, the ship whose move set the function will be testing
move_code: String, the move code we want to get the closest maneuver to
can_perform_red_maneuvers: Boolean, if true then we will try red maneuvers,
    if false then we won't.

returns a table of move codes, as strings.
]]--
AIModule.GetNearestMoves = function(ship, move_code, can_perform_red_maneuvers)
    move_set = ship.getTable('Data')['moveSet']
    local move_info = MoveData.DecodeInfo(move_code, ship)
    local original_speed = move_info.speed

    -- We're going to loop through all of the ships moves and test for whether
    -- they're possible or not, and each loop we'll increase the speed offset
    -- by one. So 0 first, then -1 and +1, then -2 and +2, ... First we need
    -- to calculate the maximum number of loops we can make.
    local min_speed = 1
    local max_speed = 3
    if move_info.type == 'straight' then
        min_speed = 0
        max_speed = 5
    end
    max_offset = math.max(move_info.speed - min_speed, max_speed - move_info.speed)

    -- Break the move code into sections so we can change the speed easily.
    local speed_position = string.find(move_code, tostring(original_speed))
    local move_pre_speed = string.sub(move_code, 1, speed_position - 1)
    local move_post_speed = string.sub(move_code, speed_position + 1)

    -- Loop through all the moves at the current offset. If we find at least
    -- one possible move, then return it.
    local speed_offset = 0
    while speed_offset <= max_offset do
        -- Prepare a table of 1-2 speeds to try this loop
        local test_speeds = {}
        if speed_offset == 0 then
            table.insert(test_speeds, original_speed)
        else
            for _, direction in ipairs({1, -1}) do
                local test_speed = original_speed + speed_offset * direction
                if test_speed <= max_speed and test_speed >= min_speed then
                    table.insert(test_speeds, test_speed)
                end
            end
        end

        -- Turn the move speeds into move codes
        test_move_codes = {}
        for _, test_speed in ipairs(test_speeds) do
            table.insert(test_move_codes, move_pre_speed .. tostring(test_speed) .. move_post_speed)
        end

        -- Loop through and check if these maneuvers are in our list
        move_replacements = {}
        for _, raw_move_code in ipairs(move_set) do
            local move_difficulty = string.sub(raw_move_code, 1, 1)
            if move_difficulty ~= 'r' or can_perform_red_maneuvers then
                local move_code = string.sub(raw_move_code, 2)
                for _, test_move_code in ipairs(test_move_codes) do
                    if test_move_code == move_code then
                        table.insert(move_replacements, move_code)
                    end
                end
            end
        end

        if #move_replacements ~= 0 then
            return move_replacements
        end

        speed_offset = speed_offset + 1
    end
end

AIModule.ApplySpecialAbility = function(ship, ability)
    if AIModule.HasSpecialAbility(ship, ability) then
        if ability == 'fullThrottle' then
            -- Take an evade action if the ship fully executed (ie, no
            -- ship-to-ship collision) a 3-5 maneuver. We're assumed to not be
            -- stressed as this is only called right before actions are
            -- selected.
            if AIModule.current_move.collision == false then
                local move_code = AIModule.current_move.move_code
                if string.find(move_code, '3') or string.find(move_code, '4') or string.find(move_code, '5') then
                    printToAll(string.format('%s used full throttle to evade.', ship.getName()))
                    DialModule.PerformAction(ship, 'Evade', ship.getVar('owningPlayer'))
                    table.insert(AIModule.current_move.actions, 'evade')
                end
            end
        end
    end
end

AIModule.HasSpecialAbility = function(ship, ability)
    local rule_set = BehaviourDB.GetRuleSet()
    local ship_id = ship.getTable('Data')['shipId']
    local ship_behaviour = rule_set.ships[ship_id]

    if ship_behaviour.special_rules == nil then
        return false
    end

    for _, ship_ability in pairs(ship_behaviour.special_rules) do
        if ability == ship_ability then
            return true
        end
    end

    return false
end

--[[ AIModule.IsIonised
This function returns whether or not a ship has enough ion tokens to ionise it.

ship: TTS Object, the ship performing the move

returns true if the ship is ionised, false otherwise.
]]
AIModule.IsIonised = function(ship)
    local ion_count = TokenModule.GetShipTokenCount(ship, "Ion")
    local ship_size = ship.getTable('Data').Size or 'small'
    if ship_size == 'small' then
        return ion_count >= 1
    elseif ship_size == 'medium' then
        return ion_count >= 2
    elseif ship_size == 'large' then
        return ion_count >= 3
    else
        return ion_count >= 6
    end

    return false
end

--[[ AI action selection

This submodule is smaller than the maneuver system, but probably more complex.
The main function is AIModule.AttemptAction, which takes an action definition
and checks if it is possible to execute. This involves checking the action's
pre-conditions (if the ship is in the right situation to attempt it), then if
the ship can actually execute the action, and finally checking the action's
post-conditions (if the action met with the desired result).

Where this gets complicated is the use of action probes, which are hypothetical
future positions of the ship. So if a ship makes a boost, then we create a probe
for each type of boost (bl1, s1, br1) and evaluate the post-conditions for each
probe. Where this gets _really_ complicated is when handling ships that can
string together more than one move action, such as the Interceptor's boost
action linking to a barrel roll action. For this we have to "expand" the first
set of probes by the second action - so the probe "bl1" expands into six more
probes: "bl1 > rl1", "bl1 > rl2", "bl1 > rl3", "bl1 > rr1", "bl1 > rr2", and
"bl1 > rr3". These permutations can get quite large (45 in the case of the
Interceptor) so these are cached where possible, but even so they can lead to
long execution times.

Finally, the actions are packed into a stack and processed one-by-one. Just like
the maneuver submodule these have to be dealt with in a callback to wait for the
TTS components to come to a rest.
]]

-- List which actions are expandable actions, and therefore have to be expanded
-- into a list of potential move codes or turret rotations. Any action not
-- listed here is assumed to be possible to made at any time (such as 'focus',
-- 'evade', etc)
AIModule.expandable_actions = {
    ['barrelRoll'] = {'rl1', 'rr1', 'rl2', 'rr2', 'rl3', 'rr3'},
    ['boost'] = {'bl1', 's1', 'br1'},
    ['rotateTurret'] = true -- These are calculated at run-time based on the turret type and current rotation.
}

-- Which arcs are adjacent to each arc, used for checking whether a ship is
-- wholly within an arc or not.
AIModule.arc_adjacencies = {
    ['front'] = {'left', 'right'},
    ['back'] = {'left', 'right'},
    ['left'] = {'front', 'back'},
    ['right'] = {'front', 'back'},
    ['leftRight'] = {'front', 'back'},
    ['frontBack'] = {'left', 'right'},
    ['fullfront'] = {'fullback'},
    ['fullback'] = {'fullfront'}
}

AIModule.SelectAction = function(ship)
    local rule_set = BehaviourDB.GetRuleSet()
    local ship_id = ship.getTable('Data')['shipId']
    local ship_behaviour = rule_set.ships[ship_id]

    for _, action in ipairs(ship_behaviour.action_selection) do
        if AIModule.AttemptAction(ship, AIModule.current_move.target, action) then
            return true
        end
    end

    printToAll('No AI actions found for ship ID ' .. tostring(ship_id) .. ', please make actions manually.', color(1.0, 1.0, 0.2, 0.9))
end

AIModule.AttemptAction = function(ship, target, action_definition)
    if action_definition.pass_through then
        AIModule.PrintActionDescription(action_definition.description, ship, target)
        return false
    end

    -- Generate a static action probe to start our moves from.
    local initial_probe = AIModule.GetActionProbe(ship)
    -- The list of possible probe moves, if any. Group by the set index.
    local probe_sets = {}
    -- The simple actions that we'll take, grouped by the set index.
    local simple_actions = {}

    -- Check for preconditions
    if AIModule.CheckProbeConditions(ship, target, initial_probe, action_definition.preconditions) == false then
        return false
    end

    -- There are three ways that an action can be defined in the behaviour
    -- database, so look for the shorthands and expand them out to the full
    -- definition if necessary.
    local action_set = action_definition.action
    if type(action_definition.action) == 'string' then
        action_set = {[1] = {[action_definition.action] = {['stress'] = false}}}
    elseif action_definition.action[1] == nil then
        action_set = {[1] = action_definition.action}
    end

    -- Iterate over each item in the action list, attempting each one in turn.
    -- The action could be a move action (barrelRoll or boost) in which case
    -- we need to expand it into all possible moves.
    local action_includes_move_component = false
    for set_index, action_list in ipairs(action_set) do
        probe_sets[set_index] = {}
        simple_actions[set_index] = {}
        local initial_action = true

        for action, arguments in pairs(action_list) do
            -- Check for the stress shorthand in the arguments parameter.
            if type(arguments) ~= 'table' then
                arguments = {['stress'] = arguments}
            end

            if AIModule.expandable_actions[action] ~= nil then
                -- Get or build the list of actions to expand into.
                local expanded_actions = AIModule.expandable_actions[action]
                if type(expanded_actions) == 'table' then
                    action_includes_move_component = true
                else
                    expanded_actions = {}
                    if action == 'rotateTurret' then
                        local mount = arguments.mount or 'main'
                        local turret_rotation_options = AIModule.GetTurretRotationOptions(ship, mount)
                        for _, rotation in pairs(turret_rotation_options) do
                            table.insert(expanded_actions, {['action'] = 'rotateTurret', ['mount'] = mount, ['arc'] = rotation})
                        end
                    end
                end

                local action_difficulty = 'w'
                if arguments.stress == true then
                    action_difficulty = 'r'
                end

                -- This action is an expanded action, so expand our current set
                -- of possible action probes further.
                if initial_action == true then
                    probe_sets[set_index] = table.join(probe_sets[set_index], AIModule.ExpandActionProbe(ship, initial_probe, expanded_actions, action_difficulty))
                    initial_action = false
                else
                    new_probes = {}
                    for _, probe in pairs(probe_sets[set_index]) do
                        new_probes = table.join(new_probes, AIModule.ExpandActionProbe(ship, probe, expanded_actions, action_difficulty))
                    end

                    probe_sets[set_index] = table.join(probe_sets[set_index], new_probes)
                end

                -- Set the set index on each probe.
                for _, probe in pairs(probe_sets[set_index]) do
                    probe.set_index = set_index
                end
            else
                -- There's one instance that we skip the action - we don't take
                -- a target lock action if the target is already locked. This is
                -- often handled by the preconditions anyway, but sometimes it's
                -- not so we double-check here. Also, range must be checked by
                -- the postconditions as doing a range check now would be from
                -- the post-maneuver position, not the post-action position.
                local skip_action = false
                if action == 'targetLock' then
                    skip_action = AIModule.HasTargetLockOnShip(ship, target)
                end

                if skip_action == false then
                    table.insert(simple_actions[set_index], action)

                    if arguments.stress == true then
                        table.insert(simple_actions[set_index], 'stress')
                    end
                end
            end
        end
    end

    -- We merge together all of the probe sets into one table so we can rank
    -- them and compare them to each other. We need to select a random one, so
    -- we'll randomise the list and pick the first one that passes all the
    -- postconditions. If the list is empty, or if no probe passes the
    -- postconditions, then we can't complete the action and must return false.
    selected_probe = initial_probe

    -- Group all the probe sets together
    local all_possible_probes = {}
    for _, probe_set in pairs(probe_sets) do
        all_possible_probes = table.join(all_possible_probes, probe_set)
    end

    -- Randomise the probes, then sort by difficulty so we avoid stress if
    -- possible. We set the index here as it is used by SortProbesByDifficulty
    -- to guarantee a stable sort.
    all_possible_probes = table.shuffle(all_possible_probes)
    for index, probe in ipairs(all_possible_probes) do
        probe.index = index
    end
    table.sort(all_possible_probes, AIModule.SortProbesByDifficulty)

    -- Iterate over the probes. The first successful one we find we store
    -- in the probe_actions array that gets processed later, and we also record
    -- the set index so we know which set of simple actions to use.
    local probe_actions = {}
    local set_index = 1
    local move_count = 0
    for _, probe in pairs(all_possible_probes) do
        if AIModule.CheckProbeConditions(ship, target, probe, action_definition.postconditions) == true then
            selected_probe = probe
            set_index = probe.set_index

            for _, action in pairs(probe.actions) do
                -- Keep track of how many actual moves we make.
                if action.action == nil then
                    move_count = move_count + 1
                end

                if action ~= 's0' then
                    table.insert(probe_actions, action)
                end
            end

            if probe.difficulty == 'r' then
                table.insert(simple_actions[set_index], 'stress')
            end

            break
        end
    end

    if action_includes_move_component and move_count == 0 then
        return false
    end

    for index = 1, #simple_actions[set_index] do
        table.insert(AIModule.current_move.action_stack, simple_actions[set_index][#simple_actions[set_index] + 1 - index])
    end
    for index = 1, #probe_actions do
        table.insert(AIModule.current_move.action_stack, probe_actions[#probe_actions + 1 - index])
    end

    if #AIModule.current_move.action_stack > 0 then
        AIModule.PrintActionDescription(action_definition.description, ship, target, selected_probe)
        return true
    end

    return false
end

-- Processes the queued actions in order, movement first and then simple
-- actions. Will wait for the callback to keep processing actions in the case of
-- a movement action
AIModule.ProcessActionStack = function(ship)
    if AIModule.current_move.in_progress == false then
        return
    end

    while #AIModule.current_move.action_stack > 0 do
        local action = table.remove(AIModule.current_move.action_stack)

        if action.action == 'rotateTurret' then
            ship.call('SetTurretArc', {['mount'] = action.mount, ['arc'] = action.arc, ['snap'] = false})
        elseif action == 'stress' then
            DialModule.PerformAction(ship, 'Stress', ship.getVar('owningPlayer'))
        elseif action == 'focus' then
            DialModule.PerformAction(ship, 'Focus', ship.getVar('owningPlayer'))
            table.insert(AIModule.current_move.actions, 'focus')
        elseif action == 'evade' then
            DialModule.PerformAction(ship, 'Evade', ship.getVar('owningPlayer'))
            table.insert(AIModule.current_move.actions, 'evade')
        elseif action == 'targetLock' then
            DialModule.PerformAction(ship, 'Target Lock', ship.getVar('owningPlayer'), {['ship'] = ship, ['target'] = AIModule.current_move.target})
            table.insert(AIModule.current_move.actions, 'targetLock')
        elseif action == 'cloak' then
            DialModule.PerformAction(ship, 'Cloak', ship.getVar('owningPlayer'))
            table.insert(AIModule.current_move.actions, 'cloak')
        elseif action == 'reinforceFore' then
            DialModule.PerformAction(ship, 'Reinforce', ship.getVar('owningPlayer'), {['flip'] = true})
            table.insert(AIModule.current_move.actions, 'reinforce')
        elseif action == 'reinforceAft' then
            DialModule.PerformAction(ship, 'Reinforce', ship.getVar('owningPlayer'))
            table.insert(AIModule.current_move.actions, 'reinforce')
        elseif action == 'coordinate' then
            printToAll('Please manage the coordinate action manually.', color(1.0, 1.0, 0.2, 0.9))
            table.insert(AIModule.current_move.actions, 'coordinate')
        elseif action == 'jam' then
            target = AIModule.current_move.target
            DialModule.PerformAction(target, 'Jam', target.getVar('owningPlayer'))
            printToAll('Please manage the effects of the jam token manually.', color(1.0, 1.0, 0.2, 0.9))
            table.insert(AIModule.current_move.actions, 'jam')
        elseif MoveModule.PerformMove(action, ship, false, AIModule.ProcessActionStack) then
            break
        end
    end

    AIModule.current_move.in_progress = #AIModule.current_move.action_stack > 0
end

AIModule.PrintActionDescription = function(description, ship, target, probe)
    local text = description
    local text_parameters = {}
    if type(description) == 'table' then
        text = description.text
        for _, string_id in pairs(description.strings) do
            if string_id == 'ship' then
                table.insert(text_parameters, ship.getName())
            elseif string_id == 'target' then
                table.insert(text_parameters, target.getName())
            else
                -- If it's not 'ship' or 'target', then it's an action target
                -- that is stored in the chain of the selected action probes.
                -- We'll look up the chain until we find it.
                action_target = ''
                current_probe = probe
                while current_probe ~= nil and action_target == '' do
                    if current_probe.action_targets[string_id] ~= nil then
                        action_target = current_probe.action_targets[string_id].getName()
                    end
                    current_probe = current_probe.parent
                end

                table.insert(text_parameters, action_target)
            end
        end
    else
        text_parameters = {ship.getName()}
    end

    printToAll(string.format(text, unpack(text_parameters)))
end

--[[ The action probe system, part of the AI action submodule.

These functions deal the creating action probes, expanding them, sorting them,
and checking conditions on them.
]]
AIModule.CheckProbeConditions = function(ship, target, probe, conditions)
    -- No conditions, then we can't fail.
    if conditions == nil then
        return true
    end

    local probe_result = true

    for condition, parameters in pairs(conditions) do
        local required_result = parameters
        local arguments = nil
        -- Conditions can either point just to the required result, in which
        -- case they have no arguments, or point to a table which contains both
        -- the required result and arguments.
        if type(parameters) == 'table' then
            required_result = parameters.requiredResult
            arguments = parameters.arguments
        end
        local actual_result = AIModule.condition_functions[condition](ship, target, probe, arguments)
        if actual_result ~= required_result then
            probe_result = false
            break
        end
    end

    return probe_result
end

-- This creates the origin action probe and returns it.
AIModule.GetActionProbe = function(ship)
    local move = 's0'

    if AIModule.current_move.probes[move] == nil then
        AIModule.current_move.probes[move] = {}
    end

    if AIModule.current_move.probes[move].possible == nil then
        AIModule.current_move.probes[move].parent = nil
        AIModule.current_move.probes[move].action_targets = {}
        AIModule.current_move.probes[move].actions = {move}
        AIModule.current_move.probes[move].possible = true
        AIModule.current_move.probes[move].difficulty = 'w'
        AIModule.current_move.probes[move].position = ship.getPosition()
        AIModule.current_move.probes[move].rotation = ship.getRotation()
    end

    return AIModule.current_move.probes[move]
end

-- This function takes an existing probe, and appends all possible moves/actions
-- in the action list onto it, returning a list of those that are possible.
AIModule.ExpandActionProbe = function(ship, probe, actions, difficulty)
    local possible_probes = {}

    local probe_name = ''
    for _, previous_action in pairs(probe.actions) do
        if string.len(probe_name) > 0 then
            probe_name = probe_name .. ','
        end
        probe_name = probe_name .. AIModule.GetActionProbeName(previous_action)
    end

    for _, action in pairs(actions) do
        -- First check if this exists. If it does, and it's possible, then just
        -- return it and skip to the next one.
        local new_probe_name = probe_name .. ',' .. AIModule.GetActionProbeName(action)
        new_probe = AIModule.current_move.probes[new_probe_name]
        if new_probe ~= nil then
            if new_probe.possible == true then
                new_probe.difficulty = difficulty
                table.insert(possible_probes, new_probe)
            end
        else
            local new_probe = {
                ['parent'] = probe,
                ['possible'] = false,
                ['actions'] = table.shallowcopy(probe.actions),
                ['action_targets'] = {},
                ['difficulty'] = difficulty,
            }
            table.insert(new_probe.actions, action)

            if action.action == nil then
                -- If the action doesn't contain an 'action' key, then it's a move.
                local move_code = action

                -- Test whether this probe is even possible.
                local original_ship_state = AIModule.GetShipState(ship)
                AIModule.ApplyProbe(ship, probe)

                local move_info = MoveData.DecodeInfo(move_code, ship)
                local probe_data = MoveModule.MoveProbe.TryFullMove(move_info, ship, MoveModule.GetFullMove)
                if probe_data.done and probe_data.collObj == nil and probe_data.collObs == nil then
                    new_probe.possible = true
                    new_probe.position = probe_data.finalPosRot.pos
                    new_probe.rotation = probe_data.finalPosRot.rot
                    table.insert(possible_probes, new_probe)
                end
                AIModule.current_move.probes[new_probe_name] = new_probe

                AIModule.SetShipState(ship, original_ship_state)
            elseif action.action == 'rotateTurret' then
                -- Turret rotations are always possible so we don't need to test
                -- the action.
                new_probe.possible = true
                new_probe.position = probe.position
                new_probe.rotation = probe.rotation
                new_probe.turrets = {[action.mount] = action.arc}
                table.insert(possible_probes, new_probe)

                AIModule.current_move.probes[new_probe_name] = new_probe
            end
        end
    end

    return possible_probes
end

AIModule.GetActionProbeName = function(action)
    if action.action == nil then
        return action
    elseif action.action == 'rotateTurret' then
        return string.format('rotateTurret(%s,%s)', action.mount, action.arc)
    else
        return ''
    end
end

AIModule.SortProbesByDifficulty = function(e1, e2)
    if e1.difficulty == 'b' and e2.difficulty ~= 'b' then
        return true
    elseif e2.difficulty == 'b' and e1.difficulty ~= 'b' then
        return false
    elseif e1.difficulty == 'w' and e2.difficulty == 'r' then
        return true
    elseif e2.difficulty == 'w' and e1.difficulty == 'r' then
        return false
    end

    return e1.index < e2.index
end

AIModule.GetShipState = function(ship)
    local state = {['position'] = ship.GetPosition(), ['rotation'] = ship.GetRotation(), ['turrets'] = {}}

    local turret_mounts = ship.call('GetAssignedMounts')
    for _, mount in pairs(turret_mounts) do
        state.turrets[mount] = ship.call('GetTurretArc', {['mount'] = mount})
    end

    return state
end

AIModule.SetShipState = function(ship, state)
    ship.SetPosition(state.position)
    ship.SetRotation(state.rotation)

    if state.turrets ~= nil then
        for mount, arc in pairs(state.turrets) do
            ship.call('SetTurretArc', {['mount'] = mount, ['arc'] = arc, ['snap'] = true})
        end
    end
end

AIModule.ApplyProbe = function(ship, probe)
    ship.SetPosition(probe.position)
    ship.SetRotation(probe.rotation)

    if probe.turrets ~= nil then
        for mount, arc in pairs(probe.turrets) do
            ship.call('SetTurretArc', {['mount'] = mount, ['arc'] = arc, ['snap'] = true})
        end
    end
end

AIModule.GetTurretRotationOptions = function(ship, mount)
    -- Build up our list of possible rotations.
    local rotation_options = {}
    local turret_type = ship.call('GetTurretType', {['mount'] = mount})
    if turret_type == 'singleturret' then
        rotation_options = {'front', 'right', 'back', 'left'}
    elseif turret_type == 'doubleturret' then
        rotation_options = {'frontback', 'leftright'}
    end

    -- Remove our current option arc from the list of options.
    local turret_arc = ship.call('GetTurretArc', {['mount'] = mount})
    i = 1
    while i <= #rotation_options do
        if rotation_options[i] == current_arc then
            table.remove(rotation_options, i)
        else
            i = i + 1
        end
    end

    return rotation_options
end

AIModule.condition_functions = {}
AIModule.condition_functions.hasShot = function(ship, target, probe, arguments)
    -- TODO: This should favour a shot at the target. To do so we might need to
    -- create a different condition function "hasShotOnTarget" and have it occur
    -- before the generic hasShot checks.
    local min_range = 1
    local max_range = 3
    if arguments ~= nil then
        min_range = arguments.minRange or min_range
        max_range = arguments.maxRange or max_range
    end

    if probe.shot_range == nil then
        probe.shot_range = -1

        local original_position_rotation = AIModule.GetShipState(ship)
        AIModule.ApplyProbe(ship, probe)
        targets = ArcCheck.GetTargetsInRelationToArc(ship, ship.call('GetAllArcs'))
        targets = table.sieve(targets, AIModule.FilterInArc)
        targets = table.sieve(targets, AIModule.FilterInRange)

        for _, target in pairs(targets) do
            if probe.shot_range == -1 or target.closest.range < probe.shot_range then
                probe.shot_range = target.closest.range
            end
        end

        AIModule.SetShipState(ship, original_position_rotation)
    end

    return probe.shot_range ~= -1 and probe.shot_range >= min_range and probe.shot_range <= max_range
end

AIModule.condition_functions.inTargetsArc = function(ship, target, probe, arguments)
    if probe.in_targets_arc == nil then
        local original_position_rotation = AIModule.GetShipState(ship)
        AIModule.ApplyProbe(ship, probe)

        probe.in_targets_arc = false
        targets = ArcCheck.GetTargetsInRelationToArc(target, target.call('GetAllArcs'), {ship})
        targets = table.sieve(targets, AIModule.FilterInArc)
        targets = table.sieve(targets, AIModule.FilterInRange)
        for _, target_info in pairs(targets) do
            probe.in_targets_arc = true
            break
        end

        AIModule.SetShipState(ship, original_position_rotation)
    end

    return probe.in_targets_arc
end

AIModule.condition_functions.targetMoved = function(ship, target, probe, arguments)
    if probe.target_moved == nil then
        local ship_initiative = ship.getTable('Data')['initiative']
        local target_initiative = target.getTable('Data')['initiative']
        probe.target_moved = ship_initiative > target_initiative -- TODO: This assumes that the AI moves first on ties like in HotAC.
    end

    return probe.target_moved
end

AIModule.condition_functions.targetLocked = function(ship, target, probe, arguments)
    if probe.target_locked == nil then
        probe.target_locked = AIModule.HasTargetLockOnShip(ship, target)
    end

    return probe.target_locked
end

AIModule.condition_functions.targetWithinRange = function(ship, target, probe, arguments)
    local min_range = 1
    local max_range = 3
    if arguments ~= nil then
        min_range = arguments.minRange or min_range
        max_range = arguments.maxRange or max_range
    end

    if probe.target_range == nil then
        local targets = ArcCheck.GetTargetsInRelationToArc(ship, 'all', {target})
        for _, target_info in pairs(targets) do
            probe.target_range = target_info.closest.range
            break
        end
    end

    return probe.target_range >= min_range and probe.target_range <= max_range
end

AIModule.condition_functions.evading = function(ship, target, probe, arguments)
    if probe.evading == nil then
        probe.evading = TokenModule.GetShipTokenCount(ship, 'Evade') > 0
    end

    if probe.evading ~= true then
        for _, action in pairs(AIModule.current_move.actions) do
            if action == 'evade' then
                probe.evading = true
                break
            end
        end
    end

    return probe.evading
end

AIModule.condition_functions.inEnemyArc = function(ship, target, probe, arguments)
    local arc = 'all'
    local wholly_within_arc = true
    local min_enemies = 1
    if arguments ~= nil then
        arc = arguments.arc or arc
        wholly_within_arc = arguments.whollyWithinArc or wholly_within_arc
        min_enemies = arguments.enemyCount or min_enemies
    end

    -- This counts the number of enemies whose arc we are within, and who are
    -- within our specified arc. This is mainly used for the reinforce action
    -- and the fullfront/fullback arc.
    local condition_index = arc .. ',' .. tostring(wholly_within_arc)
    if probe.num_enemy_arcs == nil or probe.num_enemy_arcs[condition_index] == nil then
        if probe.num_enemy_arcs == nil then
            probe.num_enemy_arcs = {}
        end
        probe.num_enemy_arcs[condition_index] = 0

        local original_position_rotation = AIModule.GetShipState(ship)
        AIModule.ApplyProbe(ship, probe)

        -- Get all ships within the specified arc.
        enemies_in_arc = ArcCheck.GetTargetsInRelationToArc(ship, arc)
        enemies_in_arc = table.sieve(enemies_in_arc, AIModule.FilterInArc)

        -- If we only want ships that are fully within the arc, then we loop
        -- through all adjacent arcs and remove any ship that appears in both.
        -- So, if we checked the fullfront arc, then we reject all ships that
        -- is also int eh fullback arc.
        if wholly_within_arc and AIModule.arc_adjacencies[arc] ~= nil then
            for _, adjacent_arc in pairs(AIModule.arc_adjacencies[arc]) do
                if #enemies_in_arc > 0 then -- Quick check to avoid unnecessary calls to ArcCheck.GetTargetsInRelationToArc
                    enemies_in_adjacent_arc = ArcCheck.GetTargetsInRelationToArc(ship, adjacent_arc)
                    enemies_in_adjacent_arc = table.sieve(targets, AIModule.FilterInArc)
                    enemies_in_arc = table.sieve(enemies_in_arc,
                        -- Return false if this ship appears in arc_targets.
                        function(el)
                            for _, enemy in pairs(enemies_in_adjacent_arc) do
                                if el.ship == enemy.ship then
                                    return false
                                end
                            end

                            return true
                        end
                    )
                end
            end
        end

        -- Lastly, we iterate over all targets that remain and check if we are
        -- within their arc. For each ship that can fire at us we increment the
        -- number of arcs.
        for _, enemy_ship in pairs(enemies_in_arc) do
            local enemy_arc = ArcCheck.GetTargetsInRelationToArc(enemy_ship.ship, enemy_ship.ship.call('GetAllArcs'), {ship})
            enemy_arc = table.sieve(enemy_arc, AIModule.FilterInArc)
            enemy_arc = table.sieve(enemy_arc, AIModule.FilterInRange)
            for _ in pairs(enemy_arc) do
                probe.num_enemy_arcs[condition_index] = probe.num_enemy_arcs[condition_index] + 1
                break
            end
        end

        AIModule.SetShipState(ship, original_position_rotation)
    end

    return probe.num_enemy_arcs[condition_index] >= min_enemies
end

AIModule.condition_functions.hasCoordinateTarget = function(ship, target, probe, arguments)
    if probe.action_targets.coordinate == nil then
        probe.action_targets.coordinate = false

        -- Range two is 200mm, so triple it to 600mm to be sure of not missing
        -- anything once we take bases into account.
        local friendly_ships = ArcCheck.GetShipsWithinRange(ship, 600, false, true)

        local closest_distance = nil
        for _, friendly_ship in pairs(friendly_ships) do
            local distance = ArcCheck.GetDistanceBetweenShips(ship, friendly_ship)
            if distance ~= nil then
                -- Are we are the right range for coordinate?
                if distance.range >= 1 and distance.range <= 2 then
                    -- Is the ship not stressed?
                    if TokenModule.GetShipTokenCount(friendly_ship, "Stress") == 0 then -- TODO: appears to be an error with counting stress tokens?
                        -- Are we closer than the previously closest ship?
                        if closest_distance == nil or closest_distance > distance.length then
                            probe.action_targets.coordinate = friendly_ship
                            closest_distance = distance.length
                        end
                    end
                end
            end
        end
    end

    return probe.action_targets.coordinate ~= false
end


ArcCheck = {}
ArcCheck.initialized = false
ArcCheck.arc_check_rulers = {}
ArcCheck.current_arc = "none"

ArcCheck.arc_line_segments = {}
ArcCheck.arc_line_segments.small = {}
ArcCheck.arc_line_segments.medium = {}
ArcCheck.arc_line_segments.large = {}
ArcCheck.arc_line_segments.huge = {}

ArcCheck.bullseye_data =
{
    pos={
        small=vector(0,0,Convert_mm_igu(170)),
        medium=vector(0,0,Convert_mm_igu(180)),
        large=vector(0,0,Convert_mm_igu(190)),
        huge=vector(0,0,Convert_mm_igu(110.5))
    },
    size=vector(Convert_mm_igu(14), 0.1, Convert_mm_igu(300))
}

ArcCheck.Initialize = function() -- Arc values based on Muon's assesments (vassal)
     if ArcCheck.initialized == false then
         ArcCheck.CalculateArcLineSegments(ArcCheck.arc_line_segments.small, 81.24, 20, 20)
         ArcCheck.CalculateArcLineSegments(ArcCheck.arc_line_segments.medium, 82.8, 30, 30)
         ArcCheck.CalculateArcLineSegments(ArcCheck.arc_line_segments.large, 83.52, 40, 40)
         ArcCheck.CalculateArcLineSegments(ArcCheck.arc_line_segments.huge, 82.9, 40, 110.5 )
         ArcCheck.initialized = true
     end
 end

--[[ArcCheck.Initialize = function() -- Arc values matching TTS ruler objects
    if ArcCheck.initialized == false then
        ArcCheck.CalculateArcLineSegments(ArcCheck.arc_line_segments.small, 79.1, 20, 20)
        ArcCheck.CalculateArcLineSegments(ArcCheck.arc_line_segments.medium, 82.35, 30, 30)
        ArcCheck.CalculateArcLineSegments(ArcCheck.arc_line_segments.large, 82.9, 40, 40)
        ArcCheck.CalculateArcLineSegments(ArcCheck.arc_line_segments.huge, 82.9, 40, 110.5 )
        ArcCheck.initialized = true
    end
end]]


ArcCheck.CalculateArcLineSegments = function(table, degree, size_w, size_l)
    size_w = Convert_mm_igu(size_w)
    size_l = Convert_mm_igu(size_l)
    local edge_arc = Vect.AngleDeg2D({-size_w, 0, size_l}, {size_w, 0,size_l})
    --print("Size_W:" .. tostring(size_w) .. " size_l:"..size_l .. " edge_arc=".. tostring(edge_arc))
    if size_w == size_l then -- Rectangular base sizes (small, medium and large ships)
        print("Rectangular:".. tostring(size_w)..","..tostring(size_l))
        local r = math.rad(degree/2)
        local a = math.tan(r) * size_l
        table.front =    {   segments={ {vector(-a, 0, size_l), vector(a, 0, size_l)} },-- Front segment
                                degrees={direction=0, spread=degree/2}
                            }
        table.back =     {   segments={ {vector(-a, 0, -size_l), vector(a, 0, -size_l)} }, -- Front segment
                                degrees={direction=180, spread=degree/2}
                            }
        table.left =     {   segments={ {vector(-a, 0, -size_l), vector(-size_w, 0, -size_l)},   -- back segment
                                           {vector(-size_w, 0, -size_l), vector(-size_w, 0, size_l)}, -- left edge
                                           {vector(-size_w, 0, size_l), vector(-a, 0, size_l)}  -- front segment
                                       },
                                degrees={direction=-90, spread=(180-degree)/2}
                            }
        table.right =    {   segments={ {vector(a, 0, -size_l), vector(size_w, 0, -size_l)},   -- back segment
                                           {vector(size_w, 0, -size_l), vector(size_w, 0, size_l)}, -- right edge
                                           {vector(size_w, 0, size_l), vector(a, 0, size_l)}  -- front segment
                                       },
                                degrees={direction=90, spread=(180-degree)/2}
                            }

    else -- Long base size (huge ships)
        print("Long:".. tostring(size_w)..","..tostring(size_l))
        local r = math.rad(90 - degree/2)
        local a = math.tan(r) * size_w
        table.front =    {   segments={  {vector(-size_w, 0, a), vector(-size_w, 0, size_l)}, -- left segment
                                            {vector(-size_w, 0, size_l), vector(size_w, 0, size_l)}, -- front edge
                                            {vector(size_w, 0, size_l), vector(size_w, 0, a)} },-- right segment
                                degrees={direction=0, spread=degree/2}
                            }
        table.back =    {   segments={  {vector(-size_w, 0, -a), vector(-size_w, 0, -size_l)}, -- left segment
                                            {vector(-size_w, 0, -size_l), vector(size_w, 0, -size_l)}, -- back edge
                                            {vector(size_w, 0, -size_l), vector(size_w, 0, -a)} },-- right segment
                                degrees={direction=180, spread=degree/2}
                            }
        table.left =     {   segments={ {vector(-size_w, 0, -a), vector(-size_w, 0, a)}}, -- left segment
                                degrees={direction=-90, spread=(180-degree)/2}
                            }
        table.right =    {   segments={ {vector(size_w, 0, -a), vector(size_w, 0, a)}}, -- right segment
                                degrees={direction=90, spread=(180-degree)/2}
                            }
    end
    table.bullseye = {   segments={ {vector(-ArcCheck.bullseye_data.size[1]/2, 0, size_l), vector(ArcCheck.bullseye_data.size[1]/2, 0, size_l)} }, -- Bullseye segments
                            degrees={direction=0, spread=0, bullseye=true}
                        }
    table.fullfront = {  segments={ {vector(-size_w, 0, 0), vector(-size_w, 0, size_l)},   -- left segment
                                        {vector(-size_w, 0, size_l), vector(size_w, 0, size_l)}, -- front edge
                                        {vector(size_w, 0, size_l), vector(size_w, 0, 0)}  -- right segment
                                       },
                            degrees={direction=0, spread=90}
                        }
    table.fullback = {  segments={ {vector(-size_w, 0, 0), vector(-size_w, 0, -size_l)},   -- left segment
                                       {vector(-size_w, 0, -size_l), vector(size_w, 0, -size_l)}, -- back edge
                                       {vector(size_w, 0, -size_l), vector(size_w, 0, 0)}  -- right segment
                                   },
                            degrees={direction=180, spread=90}
                        }
     table.full =    {   segments={ {vector(-size_w, 0, size_l), vector(size_w, 0, size_l)},   -- front edge
                                       {vector(size_w, 0, size_l), vector(size_w, 0, -size_l)}, -- right edge
                                       {vector(size_w, 0, -size_l), vector(-size_w, 0, -size_l)},  -- back edge
                                       {vector(-size_w, 0, -size_l), vector(-size_w, 0, size_l)}  -- left edge
                                   },
                            degrees={direction=0, spread=180}
                        }
end

function CheckArc(args)
    -- Remove player selection to prevent accidental deletion.
    local playerColors = args.ship.getSelectingPlayers()
    for _, player in ipairs(playerColors) do
        args.ship.removeFromPlayerSelection(player)
    end

    range = args.range or 3
    -- Iterate over the potential targets and display their statuses.
    local spawnedRulers = {}
    if args.arctype ~= "full" then
        printToAll(args.ship.getName() .. ' checks for targets in the ' .. args.arctype .. ' arc:', color(1.0, 1.0, 0.2, 0.9))
    end
    targets = ArcCheck.GetTargetsInRelationToArc(args.ship, args.arctype, nil, range)
    table.sort(targets, ArcCheck.SortTargetsByDesirability)
    local found = false
    for i, target in pairs(targets) do
        ship = target.ship
        if target.in_arc == false then
            --printToAll(' - ' .. ship.getName() .. ' not in arc')
        elseif target.closest.range > range then
            --printToAll(' - ' .. ship.getName() .. ' not in range')
        else
            found = true
            ship.setLock(true)
            table.insert(spawnedRulers, ArcCheck.SpawnObstructionRuler(target.closest))
            if target.other_closest ~= nil then
                table.insert(spawnedRulers, ArcCheck.SpawnObstructionRuler(target.other_closest))
            end

            if args.arctype == "full" then
                printToAll(" - " .. ship.getName().. " in range", color(1.0, 1.0, 0.2, 0.9))
            else

                obstructedtext = ' is'
                if (target.obstructed == 'likely_unobstructed') then
                    obstructedtext = ' is most likely UNOBSTRUCTED'
                elseif (target.obstructed == 'obstructed') then
                    obstructedtext = ' is OBSTRUCTED'
                elseif (target.obstructed == 'likely_obstructed') then
                    obstructedtext = ' is most likely OBSTRUCTED'
                elseif (target.obstructed == 'chosen_obstructed') then
                    obstructedtext = ' can be chosen to be OBSTRUCTED'
                end

                multipletext = ''
                if target.multiple_points == true then
                    multipletext = ' has multiple closest points and'
                end

                bullseyetext = ''
                if target.bullseye == true then
                    bullseyetext = ' in bullseye'
                end
                printToAll(" - " .. ship.getName().. multipletext .. obstructedtext .. ' at range ' ..tostring(target.closest.range) .. bullseyetext, color(1.0, 1.0, 0.2, 0.9))
            end
        end
    end

    if found == false then
        printToAll(' - No valid targets', color(1.0, 1.0, 0.2, 0.9))
    end
    return spawnedRulers
end

--[[ GetTargetsInRelationToArc
This function returns a table containing all non-friendly ships within 900mm and
information based on the provided arc type for each one.

ship: TTS Object, the ship whose arc will be tested.
arc: Table or String. The arc/s of the ship being tested. If a string, it is an
    arc description such as 'front', 'bullseye', etc. See DataPad for full list.
    If a table, it is a list of arc descriptions. Note that a single string
    is expanded (so "frontback" becomes "front", "back"), but table entries are
    not.
fixed_targets: [optional]A list of TTS Objects, if passed in these are the only
    ships that will be checked.

returns a table of targets, each containing the following:
    ship: TTS Object, the ship being targetted
    bullseye: Boolean, true if the target is in the ship's bullseye
    closest: Table, the closest points and the range between the ship and the
        target. See ArcCheck.GetDistanceBetweenLineSegments
    in_arc: Boolean, true if the target is in the specified arc.
    obstructed: String, the state of the obstruction between the ship and the
        target. One of:
        - 'unobstructed' (no obstruction)
        - 'obstructed' (definite obstruction)
        - 'likely_unobstructed' (multiple points, but none are obstructed)
        - 'likely_obstructed' (multiple points, but both are obstructed)
        - 'chosen_obstructed' (multiple points, but only one is obstructed)
    multiple_points: Boolean, true if there is more than one closest point.
        This occurs when the two ships have the same rotation. I this is true,
        then 'other_closest' will be non-nil.
    other_closest: Table, the other closest point. See 'closest' and
        'multiple_points'. This is nil if only one closest point.
--]]
ArcCheck.GetTargetsInRelationToArc = function(ship, arc, fixed_targets, range)
    if ArcCheck.initialized == false then
        ArcCheck.Initialize()
    end

    range = range or 3

    local arc_parts = arc
    if type(arc) == 'string' then
        arc_parts = {arc}
        if arc == "frontback" then
            arc_parts = {"front", "back"}
        elseif arc == "leftright" then
            arc_parts = {"left", "right"}
        elseif arc == "all" then
            arc_parts = {"front", "back", "left", "right"}
        end
    end
    ship.setLock(true)
    local shipSize = ship.getTable("Data").Size or 'small'

    local potential_targets = fixed_targets or ArcCheck.GetPotentialTargets(ship)
    local bullseye_targets = ArcCheck.GetBullseyeTargets(ship, ArcCheck.bullseye_data.pos[shipSize])

    local own_line_segments = {}
    for i, arc in ipairs(arc_parts) do
        local segments = ArcCheck.GetOwnArcLineSegments(ship, ArcCheck.arc_line_segments[shipSize][arc]["segments"])
        for k, segment in ipairs(segments) do
            table.insert(own_line_segments, segment)
        end
    end

    targets = {}
    local found = false
    for k, pt in pairs(potential_targets) do
        target = {['ship'] = pt, ['bullseye'] = false}

        for i, bt in pairs(bullseye_targets) do
            if bt == pt then
                target.bullseye = true
            end
        end
        local target_line_segments = {}
        for i, arc in ipairs(arc_parts) do
            local segments = ArcCheck.GetTargetLineSegmentsInArc(ship, pt, ArcCheck.arc_line_segments[shipSize][arc]["degrees"])
            for k, segment in ipairs(segments) do
                table.insert(target_line_segments, segment)
            end
        end

        if #target_line_segments ~= 0 then
            local other = nil
            local closest = nil
            closest, other = ArcCheck.GetDistanceBetweenLineSegments(own_line_segments, target_line_segments)
            target.in_arc = true
            target.obstructed = 'unobstructed'
            target.closest = closest
            target.multiple_points = false

            if closest.range <= range then
                found = true
                target.closest.obstructions = ArcCheck.CheckObstruction(closest, target.ship, ship)
                target.closest.in_bullseye = target.bullseye
                if other ~= nil then
                    target.obstructed = 'likely_unobstructed'
                    target.multiple_points = true

                    other.obstructions = ArcCheck.CheckObstruction(other, target.ship, ship)
                    other.in_bullseye = target.bullseye
                    target.other_closest = other
                end

                if #closest.obstructions ~= 0 then
                    if other ~= nil then
                        if #other.obstructions ~= 0 then
                            target.obstructed = 'likely_obstructed'
                        else
                            target.obstructed = 'chosen_obstructed'
                        end
                    else
                        target.obstructed = 'obstructed'
                    end
                else
                    if other ~=nil and #other.obstructions ~= 0 then
                        target.obstructed = 'chosen_obstructed'
                    end
                end
            end
        else
            target.in_arc = false
        end

        table.insert(targets, target)
    end
    if found == false then
        ArcCheck.current_arc = "none"
    end

    return targets
end

--[[ ArcCheck.SortTargetsByDesirability
This is a table sorting function, used to sort the results of
GetTargetsInRelationToArc. It sorts based on desirability of selecting a target,
in the following order:
- in arc before out of arc
- closer range band before more distant range band
- less obstructed before more obstructed
- GUID as a fallback
--]]
ArcCheck.SortTargetsByDesirability = function(e1, e2)
    if e1.in_arc == true and e2.in_arc == false then
        return true
    elseif e1.in_arc == false and e2.in_arc == true then
        return false
    elseif e1.in_arc == true then
        if e1.closest.range < e2.closest.range then
            return true
        elseif e1.closest.range > e2.closest.range then
            return false
        end

        -- Gotta be a better way of doing this...
        if e1.obstructed ~= e2.obstructed then
            if e1.obstructed == 'unobstructed' then
                return true
            elseif e2.obstructed == 'unobstructed' then
                return false
            end

            if e1.obstructed == 'likely_unobstructed' then
                return true
            elseif e2.obstructed == 'likely_unobstructed' then
                return false
            end

            if e1.obstructed == 'chosen_obstructed' then
                return true
            elseif e2.obstructed == 'chosen_obstructed' then
                return false
            end

            if e1.obstructed == 'likely_obstructed' then
                return true
            elseif e2.obstructed == 'likely_obstructed' then
                return false
            end

            if e1.obstructed == 'obstructed' then
                return true
            elseif e2.obstructed == 'obstructed' then
                return false
            end
        end
    end

    return e1.ship.getGUID() > e2.ship.getGUID()
end

ArcCheck.CheckObstruction = function(data, ship, ownship)
    local collissions = Physics.cast({
        origin       = data.midpoint,
        orientation  = {0,data.angle, 0},
        direction    = {0,-0.3,0},
        type         = 3,
        size         = {0.1,0.1,data.length},
        max_distance = 3,
        debug        = false
    })
    local hit_obstacles = {}
    for k, hit in pairs(collissions) do
        if (hit.hit_object ~= ship) and (hit.hit_object ~= ownship) and (MoveModule.SelectObstacles(hit.hit_object) or MoveModule.SelectHugeShips(hit.hit_object)) then
            table.insert(hit_obstacles, hit.hit_object)
        end
    end
    return hit_obstacles;
end

ArcCheck.SpawnArcVisualization = function()

  arc = spawnObject({
      type              = "Custom_Model",
      position          = ArcCheck.current_ship.getPosition(),
      rotation          = {0,ArcCheck.current_ship.getRotation().y + 180, 0},
      scale             = {0.3617, 0.3617, 0.3617},
      sound             = false,
      snap_to_grid      = false
  })
  arc.setCustomObject({
      mesh =  '{verifycache}http://cloud-3.steamusercontent.com/ugc/1003682288849959172/A155E2713ECFA2E23D35ED451339ECE69BF8BEF8/',
      material = 3
  })
  arc.setLock(true)
  arc.setColorTint({1,0,0,0.3})
  table.insert(ArcCheck.arc_check_rulers, arc)
end

ArcCheck.SpawnObstructionRuler = function(data)
    if data.range > 0 then
        ruler = spawnObject({
            type              = "Custom_Model",
            position          = vector(data.A[1], 1.21, data.A[3]),
            rotation          = {0, data.angle + 90,0},
            scale             = {0.363, 0.363, 0.5},
            sound             = false,
            snap_to_grid      = false
        })
        ruler.setCustomObject({
            mesh =  '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/models/ArcCheckRuler'.. data.range .. '.obj',
            material = 3
        })
        local tintcolor = color(1.0, 1.0, 0.2, 1.0) -- Yellow obstructed tint
        if #data.obstructions == 0 then
            if data.in_bullseye then
                tintcolor = color(1.0, 0.2, 1.0, 1.0) -- Purple unobstructed bullseye tint
            else
                tintcolor = color(0.2, 0.2, 1.0, 1.0) -- Blue unobstructed tint
            end
        else
            if data.in_bullseye then
                tintcolor = color(1.0, 0.2, 0.0, 1.0) -- orange obstructed bullseye tint
            else
                tintcolor = color(1.0, 1.0, 0.2, 1.0) -- yellow obstructed tint
            end
        end


        ruler.setColorTint(tintcolor)
        ruler.setLock(true)
        return ruler
        --table.insert(ArcCheck.arc_check_rulers, ruler)
    end
end


-- Calculates closest distance between two set of line segments. Returns table with range, and line points
ArcCheck.GetDistanceBetweenLineSegments = function(own_line_segments, target_line_segments)
    local closest = {
        length=10000,
        range = 0,
        midpoint={0,0,0},
        angle=0,
        A={0,0,0},
        B={0,0,0}
    }
    local other = nil
    local epsilon = 0.001 -- This to dumb down the mathematical accuracy to match the analog game experience
    for k_o, seg_o in pairs(own_line_segments) do
        for k_t, seg_t in pairs(target_line_segments) do
            for k_p, point in pairs(seg_t) do
                local distance = ArcCheck.GetDistanceBetweenLineSegmentAndPoint(seg_o, point, false)
                if not ArcCheck.CheckEqualLineSegments(distance.A, distance.B, closest.A, closest.B ) then
                    if (distance.length <= (closest.length + epsilon)) then

                        if math.abs(distance.length - closest.length) < epsilon then
                            --print("Real close: " .. tostring(distance.length).. " - " .. tostring(distance.length - closest.length))
                            if distance.length < closest.length then
                                other = closest
                                closest = distance
                            else
                                other = distance
                            end
                        else
                            --print("Closer: " .. tostring(distance.length) .. " - " .. tostring(distance.length - closest.length))
                            closest = distance
                            other = nil
                        end
                    end
                end
            end
            for k_p, point in pairs(seg_o) do
                local distance = ArcCheck.GetDistanceBetweenLineSegmentAndPoint(seg_t, point, true)
                if not ArcCheck.CheckEqualLineSegments(distance.A, distance.B, closest.A, closest.B ) then
                    if (distance.length <= (closest.length + epsilon)) then
                        if math.abs(distance.length - closest.length) < epsilon then
                            --print("Real close2: " .. tostring(distance.length).. " - " .. tostring(distance.length - closest.length))
                            if distance.length < closest.length then
                                other = closest
                                closest = distance
                            else
                                other = distance
                            end
                        else
                            --print("Closer2: " .. tostring(distance.length) .. " - " .. tostring(distance.length - closest.length))
                            closest = distance
                            other = nil
                        end
                    end
                end
            end
        end
    end
    return closest, other
end

ArcCheck.GetAngleBetweenPoints = function(A,B,C)
    local BA = Vect.Between(B, A)
    local BC = Vect.Between(B, C)
    return Vect.AngleDeg(BA, BC)
end

ArcCheck.CheckEqualLineSegments = function(line1A, line1B, line2A, line2B)
    local epsilon = 0.02
    if Vect.Distance(line1A,line2A) < epsilon then
        return Vect.Distance(line1B,line2B) < epsilon
    elseif Vect.Distance(line1A,line2B) < epsilon then
        return Vect.Distance(line1B,line2A) < epsilon
    end
    return false
end


-- Gets the closest point on a line segment to a point
ArcCheck.GetDistanceBetweenLineSegmentAndPoint = function(segment, point, reverse)
    local P = {}
    -- Check if the angle at the first segment point is larger than 90 degrees, the point bust be it, and the endpoint will be closest point
    if (math.abs(ArcCheck.GetAngleBetweenPoints(segment[2], segment[1], point)) >= 90) then
        P = segment[1]
    elseif (math.abs(ArcCheck.GetAngleBetweenPoints(segment[1], segment[2], point)) >= 90) then
        -- Similarily for the second segment point
        P = segment[2]
    else
    -- The closest point is somewhere in between, along the normal of the line segment
        local u = Vect.ToUnit(Vect.Between(segment[1], segment[2]))
        local baseline_norm = Vector(-u[3], u[2], u[1])
        local d = Vect.DotProd(Vect.Between(point, segment[1]), baseline_norm)
        P = Vect.Sum(point, Vect.Scale(baseline_norm, d))
    end

    if reverse then
        A = point
        B = P
    else
        A = P
        B = point
    end
    local distance = Vect.Distance(P, point)
    local range =math.floor(Convert_igu_mm(distance / 100)) + 1

    local midpoint = Vect.Middle(A, B)
    midpoint[2] = 1.52


    local AB = Vect.Between(A, B)
    local angle = Vect.AngleDeg(AB, vector(0, 0, 1))
    if AB[1] < 0 then
        angle = -angle
    end

    return { length=distance,
             A=A,
             B=B,
             range=range,
             midpoint=midpoint,
             angle=angle
           }
end

-- Returns list of line segments which are within a given arc type
ArcCheck.GetOwnArcLineSegments = function(ship, segments)
    local outsegments = {}
    for k, segment in pairs(segments) do
        table.insert(outsegments, {Vect.Sum(ship.getPosition(), Vect.RotateDeg(segment[1], ship.getRotation()[2] + 180)),
                                   Vect.Sum(ship.getPosition(), Vect.RotateDeg(segment[2], ship.getRotation()[2] + 180))})
    end
    return outsegments
end

-- Finds all potential ships within a little more than range 3 from the ship
ArcCheck.GetPotentialTargets = function(ship, length)
    return ArcCheck.GetShipsWithinRange(ship, length)
end

-- Finds all targets in bullseye
ArcCheck.GetBullseyeTargets = function(ship, pos, length)
    if length != nil then
        length = Convert_mm_igu(length)
    end
    local castSize = vector(ArcCheck.bullseye_data.size[1], ArcCheck.bullseye_data.size[2], length or ArcCheck.bullseye_data.size[3])
    local collissions = Physics.cast({
        origin       = Vect.Sum(ship.getPosition(), Vect.RotateDeg(pos, ship.getRotation()[2] + 180)),
        orientation  = ship.getRotation(),
        direction    = {0,-0.001,0},
        type         = 3,
        size         = castSize,
        max_distance = 1,
        debug        = false
    })
    local myOwningPlayer = ship.getVar("owningPlayer")
    local bullseye_targets = {}
    for k, hit in pairs(collissions) do
        if hit.hit_object.getGUID() ~= ship.getGUID() and MoveModule.SelectShips(hit.hit_object) then
            if hit.hit_object.getVar("owningPlayer") != myOwningPlayer then
                -- remove false targets, where only the nub is hit
                if ArcCheck.VerifyBullseye(ship, hit.hit_object) then
                    table.insert(bullseye_targets, hit.hit_object)
                end
            end
        end
    end
    return bullseye_targets
end

ArcCheck.VerifyBullseye = function(ship, target)
    local left = false
    local right = false
    local half_bullseye = (ArcCheck.bullseye_data.size[1]/2)
    print("Half_bullseye = " .. tostring(half_bullseye))

    -- Translate target corners into ship object Space
    local size = Convert_mm_igu((mm_baseSize[target.getTable("Data").Size]/2))
    local t_rotation = target.getRotation().y
    local s_rotation = ship.getRotation().y
    local target_corners = {}
    target_corners[1] = vector(-size, 0, size)
    target_corners[2] = vector(-size, 0, -size)
    target_corners[3] = vector(size, 0, size)
    target_corners[4] = vector(size, 0, -size)
    for _, target_corner in pairs(target_corners) do
        local world_corner = target_corner:rotateOver('y',t_rotation) + target.getPosition() - ship.getPosition()
        local local_corner = world_corner:rotateOver('y', - s_rotation)
        print ("Local corner: " .. tostring(local_corner[1]) .. "," .. tostring(local_corner[2]) ..  "," .. tostring(local_corner[3]))
        if local_corner.x > -half_bullseye then
            right = true
        end
        if local_corner.x < half_bullseye then
            left = true
        end
        if left and right then
            return true
        end

    end
    return false
end


-- Finds friendly or enemy ships within a particular range
ArcCheck.GetShipsWithinRange = function(ship, range, include_enemy_ships, include_friendly_ships)
    range = range or 900
    if include_enemy_ships == nil then
        include_enemy_ships = true
    end
    if include_friendly_ships == nil then
        include_friendly_ships = false
    end

    local cast_radius = Convert_mm_igu(range)
    local collisions = Physics.cast({
        origin       = ship.getPosition() + vector(0,0.1,0),
        direction    = {0,-0.001,0},
        type         = 2,
        size         = {cast_radius, cast_radius, cast_radius},
        max_distance = 1,
        debug        = false
    })

    local ship_owning_player = ship.getVar("owningPlayer")
    local potential_ships = {}
    for k, hit in pairs(collisions) do
        if hit.hit_object.getGUID() ~= ship.getGUID() and MoveModule.SelectShips(hit.hit_object) then
            local is_enemy_ship = hit.hit_object.getVar("owningPlayer") != ship_owning_player
            if (include_enemy_ships and is_enemy_ship) or (include_friendly_ships and not is_enemy_ship) then
                table.insert(potential_ships, hit.hit_object)
            end
        end
    end

    return potential_ships
end


ArcCheck.GetDistanceBetweenShips = function(ship, target, arcs)
    local arcs = arcs or {'front', 'back', 'left', 'right'}
    local ship_size = ship.getTable("Data").Size or 'small'

    local ship_line_segments = {}
    local target_line_segments = {}
    for _, arc in pairs(arcs) do
        local ship_segments = ArcCheck.GetOwnArcLineSegments(ship, ArcCheck.arc_line_segments[ship_size][arc]["segments"])
        for _, ship_segment in pairs(ship_segments) do
            table.insert(ship_line_segments, ship_segment)
        end

        local target_segments = ArcCheck.GetTargetLineSegmentsInArc(ship, target, ArcCheck.arc_line_segments[ship_size][arc]["degrees"])
        for _, target_segment in pairs(target_segments) do
            table.insert(target_line_segments, target_segment)
        end
    end

    if #target_line_segments ~= 0 then
        local closest = nil
        closest, _ = ArcCheck.GetDistanceBetweenLineSegments(ship_line_segments, target_line_segments)
        return closest
    end

    return nil
end


-- Returns a list of line segments which are within the arc
ArcCheck.GetTargetLineSegmentsInArc = function(ship, target, arcinfo)
    local targetShipData = target.getTable("Data")
    -- Get the full line segments for the ship
    local segments = ArcCheck.arc_line_segments[targetShipData.Size]["full"]["segments"]

    local outsegments = {}
    local arc_center_vector = Vect.RotateDeg(vector(0, 0, -30), ship.getRotation()[2] + arcinfo.direction)
    --print("Arc_center_vector = " .. tostring(arc_center_vector[1]).."," .. tostring(arc_center_vector[2]) ..","..tostring(arc_center_vector[3]))
    if arcinfo.bullseye == nil then
        for k, segment in pairs(segments) do
            -- Calculate part of line segment within arc
            local rotated_segment = {Vect.Sum(target.getPosition(), Vect.RotateDeg(segment[1], target.getRotation()[2])),
                                       Vect.Sum(target.getPosition(), Vect.RotateDeg(segment[2], target.getRotation()[2]))}

            -- Check if points are in arc
            local angleoffsets = {Vect.AngleDeg(Vect.Between(ship.getPosition(), rotated_segment[1]), arc_center_vector),
                            Vect.AngleDeg(Vect.Between(ship.getPosition(), rotated_segment[2]), arc_center_vector)}

            --print("Angle offsets: " .. target.getName() .. "[".. tostring(k) .. "] "..  tostring(angleoffsets[1]) .. " - " .. tostring(angleoffsets[2]) )

            if angleoffsets[1] < arcinfo.spread and angleoffsets[2] < arcinfo.spread then
                -- Both points are in arc
                --print("Both in arc")
                table.insert(outsegments, rotated_segment)
            elseif angleoffsets[1] > arcinfo.spread and angleoffsets[2] > arcinfo.spread then
                -- both outside
                if Vect.AngleDeg(Vect.Between(ship.getPosition(), Vect.Middle(rotated_segment[1], rotated_segment[2])), arc_center_vector) < arcinfo.spread then
                    -- print("Both out, in front. deg: " .. tostring(Vect.AngleDeg(Vect.Between(ship.getPosition(), Vect.Middle(rotated_segment[1], rotated_segment[2])), arc_center_vector)))
                    -- The target is infront, but both points are outside the arc.
                    local newsegment = {ArcCheck.GetLineLineIntersection(ship.getPosition(), Vect.Sum(ship.getPosition(), Vect.RotateDeg(arc_center_vector, -arcinfo.spread))
                                          , rotated_segment[1], rotated_segment[2]),
                                  ArcCheck.GetLineLineIntersection(ship.getPosition(), Vect.Sum(ship.getPosition(), Vect.RotateDeg(arc_center_vector, arcinfo.spread))
                                          , rotated_segment[1], rotated_segment[2])}
                    --print("Newsegment: ".. tostring(newsegment[1]) .. "," .. tostring(newsegment[2]))
                    table.insert(outsegments, newsegment)
                else
                    --print("Both out, behind")
                end
            else
                -- one inside, one out
                local p1 = rotated_segment[1]
                if(angleoffsets[1] > arcinfo.spread) then
                    p1 = rotated_segment[2]
                end
                local p2 = ArcCheck.GetLineLineIntersection(ship.getPosition(), Vect.Sum(ship.getPosition(), Vect.RotateDeg(arc_center_vector, arcinfo.spread)) , rotated_segment[1], rotated_segment[2])
                if p2 == nil then
                    p2 = ArcCheck.GetLineLineIntersection(ship.getPosition(), Vect.Sum(ship.getPosition(), Vect.RotateDeg(arc_center_vector, -arcinfo.spread)) , rotated_segment[1], rotated_segment[2])
                end
                if p2 ~= nil then
                    table.insert(outsegments, {p1, p2})
                end
            end
        end
    else -- Special Bullseye handling
        local half_bullseye = ArcCheck.bullseye_data.size[1]/2
        for k, segment in pairs(segments) do
            local rotated_segment = {Vect.Sum(target.getPosition(), Vect.RotateDeg(segment[1], target.getRotation()[2])),
                                       Vect.Sum(target.getPosition(), Vect.RotateDeg(segment[2], target.getRotation()[2]))}
            local ownship_oriented_segment = {Vect.RotateDeg(Vect.Between(ship.getPosition(), rotated_segment[1]), -ship.getRotation()[2]),
                                            Vect.RotateDeg(Vect.Between(ship.getPosition(), rotated_segment[2] ), -ship.getRotation()[2])}
            local x1 = math.min(ownship_oriented_segment[1][1], ownship_oriented_segment[2][1])
            local x2 = math.max(ownship_oriented_segment[1][1], ownship_oriented_segment[2][1])
            print("x1:" .. tostring(x1) .. " x2:" .. tostring(x2))
            print("ownship_oriented_segment[1][3]:" .. tostring(ownship_oriented_segment[1][3]))
            local in_arc = true
            if ownship_oriented_segment[1][3] < 0 then -- Target in front (Yeah it is backwards)
                if x1 < -half_bullseye then
                    x1 = -half_bullseye
                    if x2 > -half_bullseye then
                        x2 = math.min(half_bullseye, x2)
                        p1 = ArcCheck.GetLineLineIntersection(ownship_oriented_segment[1], ownship_oriented_segment[2], vector(x1, ownship_oriented_segment[1][2], 0), vector(x1, ownship_oriented_segment[1][2], -20), true)
                        p2 = ArcCheck.GetLineLineIntersection(ownship_oriented_segment[1], ownship_oriented_segment[2], vector(x2, ownship_oriented_segment[1][2], 0), vector(x2, ownship_oriented_segment[1][2], -20), true)
                        if p1 ~= nil and p2 ~= nil then
                            print("test1")
                          table.insert(outsegments, { Vect.Sum(Vect.RotateDeg(p1, ship.getRotation()[2]), ship.getPosition()),
                                                      Vect.Sum(Vect.RotateDeg(p2, ship.getRotation()[2]), ship.getPosition())})
                        end
                    end
                elseif x1 < half_bullseye then
                    x2 = math.min(half_bullseye, x2)
                    p1 = ArcCheck.GetLineLineIntersection(ownship_oriented_segment[1], ownship_oriented_segment[2], vector(x1, ownship_oriented_segment[1][2], 0), vector(x1, ownship_oriented_segment[1][2], -20), true)
                    p2 = ArcCheck.GetLineLineIntersection(ownship_oriented_segment[1], ownship_oriented_segment[2], vector(x2, ownship_oriented_segment[1][2], 0), vector(x2, ownship_oriented_segment[1][2], -20), true)
                    if p1 ~= nil and p2 ~= nil then
                        print("test2")
                      table.insert(outsegments, { Vect.Sum(Vect.RotateDeg(p1, ship.getRotation()[2]), ship.getPosition()),
                                                  Vect.Sum(Vect.RotateDeg(p2, ship.getRotation()[2]), ship.getPosition())})
                    end
                end
            end
        end
    end
    return outsegments
end

ArcCheck.GetLineLineIntersection = function(p0, p1, p2, p3, expect_intersection)

    local max = 1
    local min = 0
    if expect_intersection then
        max = 1.00001
        min = -0.00001
    end

    local s1_x = p1[1] - p0[1]
    local s1_y = p1[3] - p0[3]
    local s2_x = p3[1] - p2[1]
    local s2_y = p3[3] - p2[3]

    local s = (-s1_y * (p0[1] - p2[1]) + s1_x * (p0[3] - p2[3])) / (-s2_x * s1_y + s1_x * s2_y)
    local t = ( s2_x * (p0[3] - p2[3]) - s2_y * (p0[1] - p2[1])) / (-s2_x * s1_y + s1_x * s2_y)
    if (s >= 0 and s <= max and t >= 0 and t <= max) then
        -- Collision detected
        return vector( p0[1] + (t * s1_x), p0[2], p0[3] + (t * s1_y))
    end

    return nil -- no collission
end


MoveData = {}

-- Lookup table for most of the moves
-- Generated using Matlab, source: https://github.com/tjakubo2/xwing_traj
-- Stored on another object to reduce clutter, passsed on load
MoveData.LUT = {}
MoveData.onLoad = function()
    for k,obj in pairs(getAllObjects()) do
        if obj.getName() == 'MoveLUT' then
            MoveData.LUT.Parse(obj)
        end
    end
end
EventSub.Register('onLoad', MoveData.onLoad)
MoveData.LUT.Parse = function(object)
    MoveData.LUT.Data = object.call('ParseLUT', {})
end

-- Max part value for partial moves
-- Part equal to this is a full move
-- Value is largely irrelevant since part can be a fraction (any kind of number really)
MoveData.partMax = 1000

-- Construct data from a lookup table entry
-- Move info provided from MoveData.DecodeInfo
-- Return format: {xPos_offset, yPos_offset, zPos_offset, yRot_offset}
-- Linear interpolation between points in lookup table
--
-- Only returns data for RIGHT direction move (if applies)
-- Doesn't take any segnor, talon versions etc into considerations
-- Above things are considered MODIFIERS with functions to apply them defined futher
MoveData.LUT.ConstructData = function(moveInfo, part)
    if part == nil then
        part = MoveData.partMax
    end
    if moveInfo.speed == 0 and moveInfo.type == 'straight' then
        return {0, 0, 0, 0}
    end
    part = math.clamp(part, 0, MoveData.partMax)
    local LUTtable = MoveData.LUT.Data[moveInfo.size .. 'Base'][moveInfo.type][moveInfo.speed]
    local LUTindex = (part/MoveData.partMax)*LUTtable.dataNum
    if LUTindex < 1 then LUTindex = 1 end
    -- Interpolation between two nearest indexes
    local aProp = LUTindex - math.floor(LUTindex)
    local bProp = 1 - aProp
    local outPos = Vect.Sum(Vect.Scale(LUTtable.posXZ[math.floor(LUTindex)], bProp), Vect.Scale(LUTtable.posXZ[math.ceil(LUTindex)], aProp))
    local outRot = (LUTtable.rotY[math.floor(LUTindex)] * bProp) + (LUTtable.rotY[math.ceil(LUTindex)] * aProp)

    local outData = {outPos[1], 0, outPos[2], outRot}
    return outData
end

-- Get true move length from LUT data *IN MILIMETERS*
-- True as in trajectory length, not distance between start and end
-- (stored in LUT to reduce load here)
MoveData.MoveLength = function(moveInfo)
    if moveInfo.traits.part == false then
        return nil
    elseif moveInfo.speed == 0 then
        return 0
    else
        return MoveData.LUT.Data[moveInfo.size .. 'Base'][moveInfo.type][moveInfo.speed].length
    end
end



-- Convert an entry from milimeters to in-game units
MoveData.ConvertDataToIGU = function(entry)
    return {Convert_mm_igu(entry[1]), Convert_mm_igu(entry[2]), Convert_mm_igu(entry[3]), entry[4]}
end

-- Change an entry to a left-heading version
MoveData.LeftVariant = function(entry)
    return {-1*entry[1], entry[2], entry[3], -1*entry[4]}
end

-- Change an entry to be k-turn like (+180deg rot at the end)
MoveData.TurnAroundVariant = function(entry)
    return {entry[1], entry[2], entry[3], entry[4]+180}
end

-- Change an entry to be talon-roll like (+90deg INWARD rot at the end)
MoveData.TurnInwardVariant = function(entry)
    local dir = 0
    if entry[1] > 0 then dir = 90
    elseif entry[1] < 0 then dir = -90 end
    return {entry[1], entry[2], entry[3], entry[4]+dir}
end

-- Change an entry to be reverse type
MoveData.ReverseVariant = function(entry)
    return {entry[1], entry[2], -1*entry[3], -1*entry[4]}
end

-- Rotate an entry by given degrees
-- Helps define rolls as straights rotated 90deg sideways etc
MoveData.RotateEntry = function(entry, angDeg)
    local rotEntry = Vect.RotateDeg(entry, angDeg)
    return {rotEntry[1], rotEntry[2], rotEntry[3], entry[4]+angDeg}
end

-- Apply move modifiers that happen even if move is partial
MoveData.ApplyBasicModifiers = function(entry, info)
    local out = table.shallowcopy(entry)
    if (info.type == 'turnSlip' or info.type == 'bankSlip') then
        if info.dir == 'right' then
            out = MoveData.LeftVariant(out)
        end
    elseif info.dir == 'left' then
        out = MoveData.LeftVariant(out)
    end
    if info.extra == 'reverse' then
        out = MoveData.ReverseVariant(out)
    end
    return out
end

-- Apply move modifiers that only happen if move is performed fully
MoveData.ApplyFinalModifiers = function(entry, info)
    local out = table.shallowcopy(entry)
    if info.extra == 'talon' then
        out = MoveData.TurnInwardVariant(out)
    elseif info.extra == 'koiogran' or info.extra == 'segnor' then
        out = MoveData.TurnAroundVariant(out)
    end
    return out
end


-- Decode a move command into table with type, direction, speed etc info
-- TODO make a lookup table?
MoveData.DecodeInfo = function (move_code, ship)
    local info = {
                                        -- [option1] [option2] ... [optionN]  // [errorOption]
                    type='invalid',     -- [straight] [bank] [turn] [roll] [viper] [cloak] [echo] [bankSlip] [ turnSlip]//  [invalid]
                    speed=nil,          -- [1] [2] [3] [4] [5]  //  [nil]
                    dir=nil,            -- [left] [right] [nil]
                    extra=nil,          -- [koiogran] [segnor] [talon] [reverse] [straight] [forward] [backward] [nil]
                    traits =
                    {
                        full=false,     -- [true] [false] if this move can be attempted as a full move
                        part=false      -- [true] [false] if this move can be attempted as a partial move
                    },
                    size=nil,           -- [small] [large]  //  [nil]
                    note=nil,           -- [string] eg. 'banked xxx'       //  [nil]
                    collNote=nil,       -- [string] eg. 'tried to do xxx'  //  [nil]
                    code=move_code      -- [string] eg. 'be2'              //  [nil]
    }
    if ship ~= nil then
        info.size = ship.getTable("Data").Size or 'small'
    else
        info.size = 'small'
    end
    -- Straights and koiograns, regular stuff
    if move_code:sub(1,1) == 's' or move_code:sub(1,1) == 'k' then
        info.type = 'straight'
        info.speed = tonumber(move_code:sub(2,2))
        info.traits.full = true
        info.traits.part = true
        if move_code:sub(1,1) == 'k' then
            info.extra = 'koiogran'
            info.note = 'koiogran turned ' .. info.speed
            info.collNote = 'tried to koiogran turn ' .. info.speed
        elseif move_code:sub(-1,-1) == 'r' then
            info.extra = 'reverse'
            info.note = 'flew reverse ' .. info.speed
            info.collNote = 'tried to fly reverse ' .. info.speed
        elseif move_code:sub(-1,-1) == 'b' then
            info.traits.part = false
            local boostSpd = ''
            if info.speed > 1 then
                boostSpd = ' ' .. info.speed
            end
            info.note = 'boosted straight' .. boostSpd
            info.collNote = 'tried to boost straight' .. boostSpd
        else
            info.note = 'flew straight ' .. info.speed
            info.collNote = 'tried to fly straight ' .. info.speed
        end
        if info.speed == 0 then
            info.traits.part = false
            if info.extra == 'koiogran' then
                info.note = 'turned around'
            else
                info.note = 'is stationary'
            end
        end
    -- Banks, regular stuff
    elseif move_code:sub(1,1) == 'a' then
        info.type = 'adjust'
        info.speed = tonumber(move_code:sub(2,2))
        info.traits.full = true
        info.traits.part = false
        if info.speed == 1 then
            info.note = 'adjusted forward'
            info.collNote = 'tried to adjust forward'
        else
            info.note = 'adjusted backward'
            info.collNote = 'tried to adjust backward'
        end
    elseif move_code:sub(1,1) == 'b' then
        info.type = 'bank'
        info.dir = 'right'
        info.speed = tonumber(move_code:sub(3,3))
        info.traits.full = true
        info.traits.part = true
        if move_code:sub(2,2) == 'l' or move_code:sub(2,2) == 'e' then
            info.dir = 'left'
        end
        if move_code:sub(-1,-1) == 's' then
            info.extra = 'segnor'
            info.note = 'segnor looped ' .. info.dir .. ' ' .. info.speed
            info.collNote = 'tried to segnor loop ' .. info.dir .. ' ' .. info.speed
        elseif move_code:sub(-1,-1) == 't' then
            info.extra = 'talon'
            info.note = 'talon rolled (bank template) ' .. info.dir .. ' ' .. info.speed
            info.collNote = 'tried to talon roll ' .. info.dir .. ' ' .. info.speed
        elseif move_code:sub(-1,-1) == 'r' then
            info.extra = 'reverse'
            info.note = 'flew reverse bank ' .. info.dir .. ' ' .. info.speed
            info.collNote = 'tried to fly reverse bank ' .. info.dir .. ' ' .. info.speed
        elseif move_code:sub(-1,-1) == 'z' then
            info.type = 'bankSlip'
            info.extra = 'bankSlip'
            info.note = 'sliped bank ' .. info.dir .. ' ' .. info.speed
            info.collNote = 'tried to slip bank ' .. info.dir .. ' ' .. info.speed
        elseif move_code:sub(-1,-1) == 'b' then
            info.traits.part = false
            local boostSpd = ''
            if info.speed > 1 then
                boostSpd = ' ' .. info.speed
            end
            info.note = 'boosted ' .. info.dir .. boostSpd
            info.collNote = 'tried to boost ' .. info.dir .. boostSpd
        else
            info.note = 'banked ' .. info.dir .. ' ' .. info.speed
            info.collNote = 'tried to bank ' .. info.dir .. ' ' .. info.speed
        end
    -- Turns, regular stuff
    elseif move_code:sub(1,1) == 't' then
        if info.size == 'huge' then
            info.note = "tried to turn, but huge ships can't do that"
            info.collNote = "tried to turn, but huge ships can't do that"
            return info
        end
        info.type = 'turn'
        info.dir = 'right'
        info.speed = tonumber(move_code:sub(3,3))
        info.traits.full = true
        info.traits.part = true
        if move_code:sub(2,2) == 'l' or move_code:sub(2,2) == 'e' then
            info.dir = 'left'
        end
        if move_code:sub(-1,-1) == 't' then
            info.type = 'talon'
            info.note = 'talon rolled ' .. info.dir .. ' ' .. info.speed
            info.collNote = 'tried to talon roll ' .. info.dir .. ' ' .. info.speed
            if move_code:sub(-2,-2) == 'f' then
                info.type = 'talonF'
                info.note = 'talon rolled ' .. info.dir .. ' ' .. info.speed .. 'adjusting Forward'
                info.collNote = 'tried to talon roll ' .. info.dir .. ' ' .. info.speed .. 'adjusting Forward'
            elseif move_code:sub(-2,-2) == 'b' then
                info.type = 'talonB'
                info.note = 'talon rolled ' .. info.dir .. ' ' .. info.speed .. 'adjusting Backward'
                info.collNote = 'tried to talon roll ' .. info.dir .. ' ' .. info.speed .. 'adjusting Backward'
            end
        elseif move_code:sub(-1,-1) == 's' then
            info.extra = 'segnor'
            info.note = 'segnor looped (turn template) ' .. info.dir .. ' ' .. info.speed
            info.collNote = 'tried to segnor loop (turn template) ' .. info.dir .. ' ' .. info.speed
        elseif move_code:sub(-1,-1) == 'r' then
            info.extra = 'reverse'
            info.note = 'flew reverse turn ' .. info.dir .. ' ' .. info.speed
            info.collNote = 'tried to fly reverse turn ' .. info.dir .. ' ' .. info.speed
        elseif move_code:sub(-1,-1) == 'z' then
            info.type = 'turnSlip'
            info.extra = 'turnSlip'
            info.note = 'sliped turn ' .. info.dir .. ' ' .. info.speed
            info.collNote = 'tried to slip turn ' .. info.dir .. ' ' .. info.speed
        elseif move_code:sub(-1,-1) == 'b' then
            info.traits.part = false
            local boostSpd = ''
            if info.speed > 1 then
                boostSpd = ' ' .. info.speed
            end
            info.note = 'boosted (turn template) ' .. info.dir .. boostSpd
            info.collNote = 'tried to boost (turn template) ' .. info.dir .. boostSpd
        else
            info.note = 'turned ' .. info.dir .. ' ' .. info.speed
            info.collNote = 'tried to turn ' .. info.dir .. ' ' .. info.speed
        end
        if tonumber(move_code:sub(3,3)) == 4 then
            info.traits.part = false
            info.note = 'Pivoted ' .. info.dir
            info.collNote = 'tried pivoting ' .. info.dir
        end
    -- New Barrel Roll
    elseif move_code:sub(1,1) == 'r' then
        info.type = 'roll'
        info.dir = 'right'
        if move_code:sub(2,2) == 'l' or move_code:sub(2,2) == 'e' then
            info.dir = 'left'
        end
        info.speed = tonumber(move_code:sub(3,3))
        info.traits.full = true
        info.traits.part = false
        if tonumber(move_code:sub(3,3)) == 1 then
            info.note = 'barrel rolled ' .. info.dir .. ' forward'
            info.collNote = 'tried barrel rolling ' ..info.dir .. ' forward'
        elseif tonumber(move_code:sub(3,3)) == 2 then
            info.note = 'barrel rolled ' .. info.dir .. ' straight'
            info.collNote = 'tried barrel rolling ' ..info.dir .. ' straight'
        elseif tonumber(move_code:sub(3,3)) == 3 then
            info.note = 'barrel rolled ' .. info.dir .. ' backward'
            info.collNote = 'tried barrel rolling ' ..info.dir .. ' backward'
        end

    -- New Viper roll
    elseif move_code:sub(1,1) == 'v' then
        info.type = 'viper'
        info.dir = 'right'
        if move_code:sub(2,2) == 'l' or move_code:sub(2,2) == 'e' then
            info.dir = 'left'
        end
        info.speed = tonumber(move_code:sub(-1,-1))
        info.traits.full = true
        info.traits.part = false
        if move_code:sub(3,3) == 'f' then
            info.type = 'viperF'
            info.extra = 'forward'
        else
            info.type = 'viperB'
            info.extra = 'backward'
        end
        if tonumber(move_code:sub(-1,-1)) == 1 then
            info.note = 'barrel rolled ' .. info.dir .. ' ' .. info.extra .. ' adjusting forward'
            info.collNote = 'tried barrel rolling ' ..info.dir .. ' ' .. info.extra
        elseif tonumber(move_code:sub(-1,-1)) == 2 then
            info.note = 'barrel rolled ' .. info.dir .. ' ' .. info.extra .. ' adjusting straight'
            info.collNote = 'tried barrel rolling ' ..info.dir .. ' ' .. info.extra
        elseif tonumber(move_code:sub(-1,-1)) == 3 then
            info.note = 'barrel rolled ' .. info.dir .. ' ' .. info.extra .. ' adjusting backward'
            info.collNote = 'tried barrel rolling ' ..info.dir .. ' ' .. info.extra
        end
        -- New Decloak
    elseif move_code:sub(1,1) == 'c' then
        info.type = 'deCloak'
        info.dir = 'right'
        if move_code:sub(2,2) == 'l' or move_code:sub(2,2) == 'e' then
            info.dir = 'left'
        end
        info.speed = tonumber(move_code:sub(-1,-1))
        info.traits.full = true
        info.traits.part = false
        if tonumber(move_code:sub(-1,-1)) == 1 then
            info.note = 'decloaked ' .. info.dir .. ' forward'
            info.collNote = 'tried decloaking ' ..info.dir .. ' forward'
        elseif tonumber(move_code:sub(-1,-1)) == 2 then
            info.note = 'decloaked ' .. info.dir .. ' straight'
            info.collNote = 'tried decloaking ' ..info.dir .. ' straight'
        elseif tonumber(move_code:sub(-1,-1)) == 3 then
            info.note = 'decloaked ' .. info.dir .. ' backward'
            info.collNote = 'tried decloaking ' ..info.dir .. ' backward'
        end
        if move_code:sub(2,2) == 's' then
            info.type = 'straight'
            if info.size == "small" then
                info.speed = 2
            else
                info.speed = 1
            end
            info.dir = nil
            info.note = 'decloaked forward'
            info.collNote = 'tried decloacking forward'
        end
    --New Echo
    elseif move_code:sub(1,1) == 'e' then
        info.type = 'Echo'
        info.dir = 'right'
        if move_code:sub(2,2) == 'l' or move_code:sub(2,2) == 'e' then
            info.dir = 'left'
        end
        info.speed = tonumber(move_code:sub(4,4))
        info.traits.full = true
        info.traits.part = false
        if move_code:sub(3,3) == 'f' then
            info.type = 'echoF'
            info.extra = 'forward'
        elseif move_code:sub(3,3) == 'b' then
            info.type = 'echoB'
            info.extra = 'backward'
        end
        if tonumber(move_code:sub(4,4)) == 1 then
            info.note = 'decloacked ' .. info.dir .. ' ' .. info.extra .. ' adjusting forward'
            info.collNote = 'tried decloacking ' ..info.dir .. ' ' .. info.extra
        elseif tonumber(move_code:sub(4,4)) == 2 then
            info.note = 'decloacked ' .. info.dir .. ' ' .. info.extra .. ' adjusting straight'
            info.collNote = 'tried decloacking ' ..info.dir .. ' ' .. info.extra
        elseif tonumber(move_code:sub(4,4)) == 3 then
            info.note = 'decloacked ' .. info.dir .. ' ' .. info.extra .. ' adjusting backward'
            info.collNote = 'tried decloacking ' ..info.dir .. ' ' .. info.extra
        end
        if move_code:sub(2,2) == 's' then
            info.type = 'bank'
            info.speed = 2
            info.note = 'decloaked banking right'
            info.collNote = 'tried decloacking banking right'
            if move_code:sub(3,3) == 'l' or move_code:sub(3,3) == 'e' then
                info.dir = 'left'
                info.note = 'decloaked banking left'
                info.collNote = 'tried decloacking banking left'
            end
        end
    -- Barrel rolls and decloaks, spaghetti
elseif move_code:sub(1,2) == 'ch' or move_code:sub(1,2) == 'vr' then
        -- Echo's fucking bullshit which goes against ALL the standards
        -- StarViper handled the same
        info.type = 'echo'
        if move_code:sub(1,2) == 'vr' then
            info.type = 'viper'
        end
        info.dir = 'right'
        info.extra = 'forward'
        if move_code:sub(4,4) == 'b' then
            info.extra = 'backward'
        end
        if move_code:sub(3,3) == 'l' or move_code:sub(3,3) == 'e' then
            -- Ones going right/left
            info.dir = 'left'
        elseif move_code:sub(3,3) == 's' then
            -- Ones going forward
            info = MoveData.DecodeInfo('b' .. move_code:sub(4,4) .. '2', ship)
            info.traits.part = false
            info.code = move_code
        end
        if move_code:sub(1,2) == 'ch' then
            -- Echo dedscriptions
            if info.type == 'echo' then
                info.note = 'dechocloaked ' .. info.dir .. ' ' .. info.extra
                info.collNote = 'tried to dechocloak ' .. info.dir .. ' ' .. info.extra
            else
                info.note = 'dechocloaked forward ' .. info.dir
                info.collNote = 'tried to dechocloak forward ' .. info.dir
            end
        else
            -- SV descriptions
            info.note = 'bank rolled ' .. info.dir .. ' ' .. info.extra
            info.collNote = 'tried to bank roll ' .. info.dir .. ' ' .. info.extra
        end
        -- Special 2nd adjust move
        if move_code == 'chadj' or move_code == 'vradj' then
            info.extra = 'adjust'
        end
    elseif move_code:sub(1,1) == 'x' or move_code:sub(1,1) == 'c' then
        -- Rolls
        info.type = 'roll'
        info.dir = 'right'
        info.speed = 1
        if move_code:sub(2,2) == 'l' or move_code:sub(2,2) == 'e' then
            info.dir = 'left'
        end
        info.note = 'barrel rolled'
        info.collNote = 'tried to barrel roll'
        -- Decloaks
        -- Straigh decloak is treated as a roll before, now just return straight 2 data
        if move_code:sub(2,2) == 's' then
            info.type = 'straight'
            info.speed = 2
            info.traits.full = true
            info.note = 'decloaked forward'
            info.collNote = 'tried to decloak forward'
            info.dir = nil
        -- Side decloak is a barrel roll, but with 2 speed
        elseif move_code:sub(1,1) == 'c' then
            info.note = 'decloaked'
            info.collNote = 'tried to decloak'
            info.speed = 2
        end

        -- Forward/backward modifiers
        if info.type ~= 'straight' then
            if move_code:sub(-1,-1) == 'f' then
                info.extra = 'forward'
                info.note = info.note .. ' forward ' .. info.dir
                info.collNote = info.collNote .. ' forward ' .. info.dir
            elseif move_code:sub(-1,-1) == 'b' then
                info.extra = 'backward'
                info.note = info.note .. ' backward ' .. info.dir
                info.collNote = info.collNote .. ' forward ' .. info.dir
            else
                info.note = info.note .. ' ' .. info.dir
                info.collNote = info.collNote .. ' ' .. info.dir
            end
        end
    end
    return info
end

-- Get the offset data for a full move
-- Return format: {xPos_offset, yPos_offset, zPos_offset, yRot_offset}
MoveData.DecodeFullMove = function(move_code, ship)
    local data = {}
    local info = MoveData.DecodeInfo(move_code, ship)
    if info.type == 'invalid' then
        print('MoveData.DecodeFullMove: invalid move type')
        return {0, 0, 0, 0}
    else
        data = MoveData.DecodePartMove(move_code, ship, MoveData.partMax)
    end
    data = MoveData.ApplyFinalModifiers(data, info)
    return data
end

-- Get the offset data for a partial move
-- Return format: {xPos_offset, yPos_offset, zPos_offset, yRot_offset}
MoveData.DecodePartMove = function(move_code, ship, part)
    local data = {}
    local info = MoveData.DecodeInfo(move_code, ship)
    part = math.clamp(part, 0, MoveData.partMax)
    if info.type == 'invalid' then
        print('MoveData.DecodePartMove: invalid move type')
        return {0, 0, 0, 0}
    end
    data = MoveData.LUT.ConstructData(info, part)
    data = MoveData.ApplyBasicModifiers(data, info)
    return data
end


-- END MOVEMENT DATA MODULE
--------


--------
-- MAIN MOVEMENT MODULE
-- Lets us move ships around and handles what comes with moving

MoveModule = {}

-- Convert a typical entry from MoveData functions
-- (this: {xPos_offset, yPos_offset, zPos_offset, yRot_offset} )
-- to a real ship position in world
MoveModule.EntryToPos = function(entry, shipPos)
    local basePos = nil
    local baseRot = nil
    if type(shipPos) == 'userdata' then
        basePos = shipPos.getPosition()
        baseRot = shipPos.getRotation()
    elseif type(shipPos) == 'table' then
        basePos = shipPos.pos
        baseRot = shipPos.rot
    end
    local finalPos = MoveData.ConvertDataToIGU(entry)
    local finalRot = entry[4] + baseRot[2]
    finalPos = Vect.RotateDeg(finalPos, baseRot[2]+180)
    finalPos = Vect.Sum(basePos, finalPos)
    return {pos=finalPos, rot={0, finalRot, 0}}
end

-- Get the position for a ship if it did a full move
-- Returned position and rotation are ready to feed TTS functions with
MoveModule.GetFullMove = function(move, ship)
    local entry = MoveData.DecodeFullMove(move, ship)
    return MoveModule.EntryToPos(entry, ship)
end

-- Get the position for a ship if it did a part of a move
-- Returned position and rotation are ready to feed TTS functions with
MoveModule.GetPartMove = function(move, ship, part)
    local entry = MoveData.DecodePartMove(move, ship, part)
    return MoveModule.EntryToPos(entry, ship)
end


-- HISTORY HANDLING:
-- Lets us undo, redo and save positions a ship was seen at

-- History table: {ship=shipRef, actKey=keyOfHistoryEntryShipWasLastSeenAt (._.), history=entryList}
-- Entry list: {entry1, entry2, entry3, ...}
-- Entry: {pos=position, rot=rotation, move=moveThatGotShipHere, part=partOfMovePerformed}
MoveModule.moveHistory = {}

-- Hostory-related commads
XW_cmd.AddCommand('[qz]', 'historyHandle')
XW_cmd.AddCommand('undo', 'historyHandle')
XW_cmd.AddCommand('redo', 'historyHandle')
XW_cmd.AddCommand('keep', 'historyHandle')

-- Return history of a ship
MoveModule.GetHistory = function(ship)
    for k,hist in pairs(MoveModule.moveHistory) do
        if hist.ship == ship then
            return hist
        end
    end
    table.insert(MoveModule.moveHistory, {ship=ship, actKey=0, history={}})
    return MoveModule.GetHistory(ship)
end

-- Erase all history "forward" from the current state
-- Happens when you undo and then do a move - all positions you undid are lost
MoveModule.ErasePastCurrent = function(ship)
    local histData = MoveModule.GetHistory(ship)
    local k=1
    while histData.history[histData.actKey + k] ~= nil do
        histData.history[histData.actKey + k] = nil
        k = k+1
    end
end

-- Print history, just for debug
MoveModule.PrintHistory = function(ship)
    local histData = MoveModule.GetHistory(ship)
    if histData.actKey == 0 then
        print(ship.getName() .. ': NO HISTORY')
    else
        print(ship.getName() .. '\'s HISTORY:')
        local k=1
        while histData.history[k] ~= nil do
            local entry = histData.history[k]
            local typeStr = ' (' .. entry.finType
            if entry.part ~= nil then
                typeStr = typeStr .. ':' .. entry.part .. ')'
            else
                typeStr = typeStr .. ')'
            end
            if k == histData.actKey then
                print(' >> ' .. entry.move .. typeStr)
            else
                print(' -- ' .. entry.move .. typeStr)
            end
            k = k+1
        end
        print(' -- -- -- -- ')
    end
end

-- Save <some> ship position to the history
-- Saves on the position after current and deletes any past that
MoveModule.AddHistoryEntry = function(ship, entry)
    local histData = MoveModule.GetHistory(ship)
    histData.actKey = histData.actKey+1
    histData.history[histData.actKey] = entry
    MoveModule.ErasePastCurrent(ship)
end

-- How much position can be offset to be considered 'same'
MoveModule.undoPosCutoff = Convert_mm_igu(1)
-- How much rotation can be offset to be considered 'same'
MoveModule.undoRotCutoffDeg = 1

-- Check if the ship is on the curent history position (tolerance above)
MoveModule.IsAtSavedState = function(ship)
    local histData = MoveModule.GetHistory(ship)
    if histData.actKey > 0 then
        local currEntry = histData.history[histData.actKey]
        local dist = Vect.Distance(ship.getPosition(), currEntry.pos)
        local angDiff = math.abs(ship.getRotation()[2] - currEntry.rot[2])
        if math.abs(angDiff) > 180 then
            angDiff = math.abs(angDiff - math.sgn(angDiff)*360)
        end
        return (dist < MoveModule.undoPosCutoff and angDiff < MoveModule.undoRotCutoffDeg)
    end
    return false
end

-- Save curent ship position to the history
-- Can be quiet when not explicitly called by the user
MoveModule.SaveStateToHistory = function(ship, beQuiet)
    local histData = MoveModule.GetHistory(ship)
    -- Don't add an entry if it's current position/rotation
    if MoveModule.IsAtSavedState(ship) then
        if beQuiet ~= true then
            AnnModule.Announce({type='historyHandle', note='already has current position saved'}, 'all', ship)
        end
    else
        local entry = {pos=ship.getPosition(), rot=ship.getRotation(), move='position save', part=nil, finType='special'}
        MoveModule.AddHistoryEntry(ship, entry)
        if beQuiet ~= true then
            AnnModule.Announce({type='historyHandle', note='stored current position'}, 'all', ship)
        end
    end
end

-- Move a ship to a previous state from the history
-- Return true if action was taken
-- Return false if there is no more data
MoveModule.UndoMove = function(ship)
    local histData = MoveModule.GetHistory(ship)
    local announceInfo = {type='historyHandle'}
    -- No history
    if histData.actKey == 0 then
        announceInfo.note = 'has no more moves to undo'
    else
        -- There is history
        local currEntry = histData.history[histData.actKey]
        -- current position not matching history
        if not MoveModule.IsAtSavedState(ship) then
            MoveModule.MoveShip(ship, {finPos={pos=currEntry.pos, rot=currEntry.rot}, noSave=true})
            announceInfo.note = 'moved to the last saved position'
        else
        -- current position matching current histor
            if histData.actKey > 1 then
                local undidMove = currEntry.move
                histData.actKey = histData.actKey - 1
                currEntry = histData.history[histData.actKey]
                MoveModule.MoveShip(ship, {finPos={pos=currEntry.pos, rot=currEntry.rot}, noSave=true})
                announceInfo.note = 'performed an undo of (' .. undidMove .. ')'
            else
                -- There is no data to go back to
                announceInfo.note = 'has no more moves to undo'
            end
        end
    end
    AnnModule.Announce(announceInfo, 'all', ship)
    return shipMoved
end

-- Move a ship to next state from the history
MoveModule.RedoMove = function(ship)
    local histData = MoveModule.GetHistory(ship)
    local announceInfo = {type='historyHandle'}
    -- No history
    if histData.actKey == 0 then
        announceInfo.note = 'has no more moves to redo'
    else
        -- There is history
        if histData.history[histData.actKey+1] == nil then
            -- No more moves forward
            announceInfo.note = 'has no more moves to redo'
        else
            -- Move forward
            histData.actKey = histData.actKey+1
            local currEntry = histData.history[histData.actKey]
            MoveModule.MoveShip(ship, {finPos={pos=currEntry.pos, rot=currEntry.rot}, noSave=true})
            announceInfo.note = 'performed a redo of (' .. currEntry.move .. ')'
        end
    end
    AnnModule.Announce(announceInfo, 'all', ship)
    return shipMoved
end

-- Get the last move code from ship history
-- Always returns an "entry" table, if there's no move, move key is 'none'
MoveModule.GetLastMove = function(ship)
    local histData = MoveModule.GetHistory(ship)
    if histData.actKey < 1 then
        return {move='none'}
    else
        return table.shallowcopy(histData.history[histData.actKey])
    end
end

-- Get some old move from ship history (arg in number of moves back)
-- Always returns an "entry" table, if there's no move, move key is 'none'
MoveModule.GetOldMove = function(ship, numMovesBack)
    local histData = MoveModule.GetHistory(ship)
    if histData.actKey-numMovesBack < 1 then
        return {move='none'}
    else
        return table.shallowcopy(histData.history[histData.actKey-numMovesBack])
    end
end

-- THING THAT ALLOWS US TOR ESTORE SHIP POSITION AFTER IT WAS DELETED
-- Table of deleted ships last positions
MoveModule.emergencyRestore = {}
-- Pointer at the most recently added restore entry
MoveModule.restoreBufferPointer = 0
-- Max size of the restore entry table
MoveModule.restoreBufferSize = 25
-- Restore command
XW_cmd.AddCommand('restore#[1-9][0-9]?', 'historyHandle')

-- Try to restore some ship position to an entry with given key
MoveModule.Restore = function(ship, key)
    if #MoveModule.emergencyRestore < key or key <= 0 then
        AnnModule.Announce({type='historyHandle', note='Restore key (number after the #) invalid'}, 'all')
        return false
    else
        local data = MoveModule.emergencyRestore[key]
        ship.setPosition(data.savedPos.pos)
        ship.setRotation(data.savedPos.rot)
        MoveModule.SaveStateToHistory(ship, true)
        AnnModule.Announce({type='historyHandle', note='has been restored to position ' .. data.srcName .. ' was last seen at'}, 'all', ship)
        return true
    end
end

-- Save some restore data and notify the user of it
MoveModule.AddRestorePoint = function(entry)
    local newKey = MoveModule.restoreBufferPointer + 1
    if newKey > MoveModule.restoreBufferSize then
        newKey = 1
    end
    AnnModule.Announce({type='historyHandle', note=entry.srcName .. '\'s ship has been deleted - you can respawn the model and use \'restore#' .. newKey .. '\' command to restore its position'}, 'all')
    MoveModule.emergencyRestore[newKey] = entry
    MoveModule.restoreBufferPointer = newKey
end

-- Handle destroyed objects
-- Create a restore entry from last set position in history
-- Delete history if present
MoveModule.onObjectDestroyed = function(obj)
    if not ObjType.IsOfType(obj, 'ship') then return end
    if MoveModule.GetLastMove(obj).move ~= 'none' then
        local lastMove = MoveModule.GetLastMove(obj)
        MoveModule.AddRestorePoint({srcName=obj.getName(), savedPos={pos=lastMove.pos, rot=lastMove.rot}})
    end
    for k,hist in pairs(MoveModule.moveHistory) do
        if hist.ship == ship then
            table.remove(MoveModule.moveHistory, k)
            break
        end
    end
end

-- Get the history table with "serialized" positions/rotations
-- I hate this so much
-- Devs, fix your shit, goddamnit
MoveModule.GetSaveData = function()
    local currHistory = {}
    for k,hist in pairs(MoveModule.moveHistory) do
        if hist.history[1] ~= nil then
            local currEntry = MoveModule.GetLastMove(hist.ship)
            currEntry.pos = TTS_Serialize(currEntry.pos)
            currEntry.rot = TTS_Serialize(currEntry.rot)
            table.insert(currHistory, {ship=hist.ship.getGUID(), actKey=1, history={currEntry}})
        end
    end
    if currHistory[1] == nil then return nil else
    return currHistory end
end


-- Restore provided table and notify of the results
MoveModule.RestoreSaveData = function(saveTable)
    if saveTable == nil then
        return
    end
    local count = 0
    local missCount = 0
    for k,hist in pairs(saveTable) do
        hist.ship = getObjectFromGUID(hist.ship)
        if hist.ship == nil then
            missCount = missCount + 1
        else
            count = count + 1
            table.insert(MoveModule.moveHistory, hist)
        end
    end
    local info = ' - Restored last position save for ' .. count .. ' ship(s)'
    if missCount > 0 then
        info = info .. ' (' .. missCount .. ' ship model(s) missing)'
    end
    if count > 0 or missCount > 0 then
        return info
    end
end

SaveManager.Register('MoveModule', MoveModule.GetSaveData, MoveModule.RestoreSaveData)

-- Join hit tables t1 .. t5 resulting from Physics.cast call
-- Return a table of unique objects that pass selection function
-- (apaprently cant use '...' arg type when a function is a table field)
-- Arguments:
--      exclObj     <- object excluded from return table (for casts over a ship)
--      SelectFun   <- function taking an object and returning true/false (obj type selection)
--      t1 .. t5    <- hit tables returned from Physics.cast, some can be nil or empty
-- Return:
--      Concatenated table of unique objects from hit tables that also passed selection function
MoveModule.JoinHitTables = function(exclObj, SelectFun, t1, t2, t3, t4, t5)
    local gTable = {[exclObj.getGUID()]=true}
    local out = {}
    local tbls = {a=t1, b=t2, c=t3, d=t4, e=t5}
    for k,hTable in pairs(tbls) do
        for k2,hit in pairs(hTable) do
            if SelectFun(hit.hit_object) and gTable[hit.hit_object.getGUID()] == nil then
                gTable[hit.hit_object.getGUID()] = true
                table.insert(out, hit.hit_object)
            end
        end
    end
    return out
end

-- Selection function for MoveModule.JoinHitTables - ships only
MoveModule.SelectShips = function(obj)
    return ((obj.tag == 'Figurine') and (obj.getVar('__XW_Ship')==true))
end

-- Selection function for MoveModule.JoinHitTables - huge ships only
MoveModule.SelectHugeShips = function(obj)
    return MoveModule.SelectShips(obj) and (obj.getTable('Data').Size == 'huge')
end


-- Selection function for MoveModule.JoinHitTables - obstacles only
MoveModule.SelectObstacles = function(obj)
    local name = obj.getName()
    return ((name:find('Asteroid') or name:find('Debris') or name:find('Chute debris') or name:find('Cloud') or name:find('Spare') or name:find('Obstacle')) ~= nil)
end

-- Selection function for MoveModule.JoinHitTables - mine tokens only
MoveModule.SelectMineTokens = function(obj)
    local name = obj.getName()
    return (name:find('Mine') or name:find('Connor') or name:find('Chute debris') or name:find('Probe') or name:find('Buzz')) ~= nil
end

-- Selection function for MoveModule.JoinHitTables - mines and obstacles
MoveModule.SelectMinesAndObstacleTokens = function(obj)
    return MoveModule.SelectObstacles(obj) or MoveModule.SelectMineTokens(obj)
end

-- Selection function for MoveModule.JoinHitTables - anything aside from global table object
MoveModule.SelectAny = function(obj)
    return obj.getGUID() ~= nil
end

-- Cast data for checking collisions over a ship type shape
MoveModule.castData = {}
MoveModule.castData.small = {}
MoveModule.castData.small.base = {
    debug=false,
    direction = {0, -0.001, 0},
    type=3,
    size={Convert_mm_igu(40), Convert_mm_igu(6), Convert_mm_igu(40)},
    -- + Origin
    -- + Orientation
}
MoveModule.castData.small.nubFR = {
    debug=false,
    localPos = {-1*Convert_mm_igu(11.38), Convert_mm_igu(-1.86), -1*Convert_mm_igu(20.858)},
    direction = {0, -0.001, 0},
    type=2,
    size={Convert_mm_igu(3.4), Convert_mm_igu(8), Convert_mm_igu(3.4)},
    -- + Origin
}
MoveModule.castData.small.nubFL = {
    debug=false,
    localPos = {Convert_mm_igu(11.38), Convert_mm_igu(-1.86), -1*Convert_mm_igu(20.858)},
    direction = {0, -0.001, 0},
    type=2,
    size={Convert_mm_igu(3.4), Convert_mm_igu(8), Convert_mm_igu(3.4)},
    -- + Origin
}
MoveModule.castData.small.nubBR = {
    debug=false,
    localPos = {-1*Convert_mm_igu(11.38), Convert_mm_igu(-1.86), Convert_mm_igu(20.858)},
    direction = {0, -0.001, 0},
    type=2,
    size={Convert_mm_igu(3.4), Convert_mm_igu(8), Convert_mm_igu(3.4)},
    -- + Origin
}
MoveModule.castData.small.nubBL = {
    debug=false,
    localPos = {Convert_mm_igu(11.38), Convert_mm_igu(-1.86), Convert_mm_igu(20.858)},
    direction = {0, -0.001, 0},
    type=2,
    size={Convert_mm_igu(3.4), Convert_mm_igu(8), Convert_mm_igu(3.4)},
    -- + Origin
}

MoveModule.castData.medium = {}
MoveModule.castData.medium.base = {
    debug=false,
    direction = {0, -0.001, 0},
    type=3,
    size={Convert_mm_igu(60), Convert_mm_igu(6), Convert_mm_igu(60)},
    -- + Origin
    -- + Orientation
}
MoveModule.castData.medium.nubFR = {
    debug=false,
    localPos = {-1*Convert_mm_igu(11.38), Convert_mm_igu(-1.86), -1*Convert_mm_igu(30.858)},
    direction = {0, -0.001, 0},
    type=2,
    size={Convert_mm_igu(3.4), Convert_mm_igu(8), Convert_mm_igu(3.4)},
    -- + Origin
}
MoveModule.castData.medium.nubFL = {
    debug=false,
    localPos = {Convert_mm_igu(11.38), Convert_mm_igu(-1.86), -1*Convert_mm_igu(30.858)},
    direction = {0, -0.001, 0},
    type=2,
    size={Convert_mm_igu(3.4), Convert_mm_igu(8), Convert_mm_igu(3.4)},
    -- + Origin
}
MoveModule.castData.medium.nubBR = {
    debug=false,
    localPos = {-1*Convert_mm_igu(11.38), Convert_mm_igu(-1.86), Convert_mm_igu(30.858)},
    direction = {0, -0.001, 0},
    type=2,
    size={Convert_mm_igu(3.4), Convert_mm_igu(8), Convert_mm_igu(3.4)},
    -- + Origin
}
MoveModule.castData.medium.nubBL = {
    debug=false,
    localPos = {Convert_mm_igu(11.38), Convert_mm_igu(-1.86), Convert_mm_igu(30.858)},
    direction = {0, -0.001, 0},
    type=2,
    size={Convert_mm_igu(3.4), Convert_mm_igu(8), Convert_mm_igu(3.4)},
    -- + Origin
}


MoveModule.castData.large = {}
MoveModule.castData.large.base = {
    debug=false,
    direction = {0, -0.001, 0},
    type=3,
    size={Convert_mm_igu(80), Convert_mm_igu(6), Convert_mm_igu(80)},
    -- + Origin
    -- + Orientation
}
MoveModule.castData.large.nubFR = {
    debug=false,
    localPos = {-1*Convert_mm_igu(11.38), Convert_mm_igu(-1.86), -1*Convert_mm_igu(40.858)},
    direction = {0, -0.001, 0},
    type=2,
    size={Convert_mm_igu(3.4), Convert_mm_igu(8), Convert_mm_igu(3.4)},
    -- + Origin
}
MoveModule.castData.large.nubFL = {
    debug=false,
    localPos = {Convert_mm_igu(11.38), Convert_mm_igu(-1.86), -1*Convert_mm_igu(40.858)},
    direction = {0, -0.001, 0},
    type=2,
    size={Convert_mm_igu(3.4), Convert_mm_igu(8), Convert_mm_igu(3.4)},
    -- + Origin
}
MoveModule.castData.large.nubBR = {
    debug=false,
    localPos = {-1*Convert_mm_igu(11.38), Convert_mm_igu(-1.86), Convert_mm_igu(40.858)},
    direction = {0, -0.001, 0},
    type=2,
    size={Convert_mm_igu(3.4), Convert_mm_igu(8), Convert_mm_igu(3.4)},
    -- + Origin
}
MoveModule.castData.large.nubBL = {
    debug=false,
    localPos = {Convert_mm_igu(11.38), Convert_mm_igu(-1.86), Convert_mm_igu(40.858)},
    direction = {0, -0.001, 0},
    type=2,
    size={Convert_mm_igu(3.4), Convert_mm_igu(8), Convert_mm_igu(3.4)},
    -- + Origin
}

MoveModule.castData.huge = {}
MoveModule.castData.huge.base = {
    debug=false,
    direction = {0, -0.001, 0},
    type=3,
    size={Convert_mm_igu(80), Convert_mm_igu(6), Convert_mm_igu(221)},
    -- + Origin
    -- + Orientation
}
MoveModule.castData.huge.nubFR = {
    debug=false,
    localPos = {-1*Convert_mm_igu(11.38), Convert_mm_igu(-1.86), -1*Convert_mm_igu(111.858)},
    direction = {0, -0.001, 0},
    type=2,
    size={Convert_mm_igu(3.4), Convert_mm_igu(8), Convert_mm_igu(3.4)},
    -- + Origin
}
MoveModule.castData.huge.nubFL = {
    debug=false,
    localPos = {Convert_mm_igu(11.38), Convert_mm_igu(-1.86), -1*Convert_mm_igu(111.858)},
    direction = {0, -0.001, 0},
    type=2,
    size={Convert_mm_igu(3.4), Convert_mm_igu(8), Convert_mm_igu(3.4)},
    -- + Origin
}
MoveModule.castData.huge.nubBR = {
    debug=false,
    localPos = {-1*Convert_mm_igu(11.38), Convert_mm_igu(-1.86), Convert_mm_igu(111.858)},
    direction = {0, -0.001, 0},
    type=2,
    size={Convert_mm_igu(3.4), Convert_mm_igu(8), Convert_mm_igu(3.4)},
    -- + Origin
}
MoveModule.castData.huge.nubBL = {
    debug=false,
    localPos = {Convert_mm_igu(11.38), Convert_mm_igu(-1.86), Convert_mm_igu(111.858)},
    direction = {0, -0.001, 0},
    type=2,
    size={Convert_mm_igu(3.4), Convert_mm_igu(8), Convert_mm_igu(3.4)},
    -- + Origin
}



-- Get cast data for particular ship situation
-- Arguments:
--      ship        <- ship ref (for base size)
--      shipPosRot  <- table with ship check position and rotation ('pos' and 'rot' keys)
--      castType    <- 'base' for base, 'nub[FB][RL]' for one of four nubs
-- Return:
--      Table ready to be fed to Physics.cast
MoveModule.GetCast = function(ship, shipPosRot, castType)
    local baseSize = ship.getTable("Data").Size or 'small'
    local castTable = MoveModule.castData[baseSize][castType]
    --castTable.debug = true
    if castType == 'base' then
        castTable.origin = shipPosRot.pos
        castTable.orientation = shipPosRot.rot
        return castTable
    else
        castTable.origin = Vect.Sum(shipPosRot.pos, Vect.RotateDeg(castTable.localPos, shipPosRot.rot[2]))
        return castTable
    end
end

-- Return all objects that pass selection function and would overlap ship in some situation
-- Arguments:
--      ship        <- ship ref (for base size)
--      shipPosRot  <- table with ship check position and rotation ('pos' and 'rot' keys)
--      SelectFun   <- selection function that returns true/false for an object
-- Return:
--      Concatenated table of all objects that would overlap ship in this situation and pass select function
MoveModule.FullCastCheck = function(ship, shipPosRot, SelectFun)
    return MoveModule.JoinHitTables(
    ship,
    SelectFun,
    Physics.cast(MoveModule.GetCast(ship, shipPosRot, 'base')),
    Physics.cast(MoveModule.GetCast(ship, shipPosRot, 'nubFR')),
    Physics.cast(MoveModule.GetCast(ship, shipPosRot, 'nubFL')),
    Physics.cast(MoveModule.GetCast(ship, shipPosRot, 'nubBR')),
    Physics.cast(MoveModule.GetCast(ship, shipPosRot, 'nubBL'))
    )
end

-- Return all objects that pass selection function and would overlap a template in some situation
-- Arguments:
--      excludeObj   <- Object to exclude from overlapping
--      collList     <- List of already hit objects (from base overlapping)
--      templateData <- table with information on origin, orientation, speed, type and direction
--      SelectFun   <- selection function that returns true/false for an object
-- Return:
--      Concatenated table of all objects that would overlap ship in this situation and pass select function
MoveModule.TemplateCastCheck = function(excludeObj, collList, templateData, SelectFun)
    local gTable = {[excludeObj.getGUID()]=true}

    for k, coll in pairs(collList) do
        gTable[coll.getGUID()] = true
    end

    -- Find template origin and do special handling of special manouvers
    local templateOrigin = {}
    if templateData.extra == "reverse" then
        templateOrigin = MoveModule.GetTemplateOrigin(templateData.origin, templateData.orientation, templateData.shipSize, "back")
        if templateData.dir == "left" then
            templateData.dir = "right"
        elseif templateData.dir == "right" then
            templateData.dir = "left"
        end
    elseif templateData.type == "straight" or  templateData.type == "bank" or templateData.type == "turn" then
        templateOrigin = MoveModule.GetTemplateOrigin(templateData.origin, templateData.orientation, templateData.shipSize, "front")
    elseif templateData.type:find("talon") then
        templateOrigin = MoveModule.GetTemplateOrigin(templateData.origin, templateData.orientation, templateData.shipSize, "front")
        templateData.type = "turn"
    elseif templateData.type == "roll" then
        templateOrigin = MoveModule.GetTemplateOrigin(templateData.origin, templateData.orientation, templateData.shipSize, templateData.dir)
        templateData.speed = 1
    elseif templateData.type == "viper" then
        templateOrigin = MoveModule.GetTemplateOrigin(templateData.origin, templateData.orientation, templateData.shipSize, templateData.dir)
        if templateData.dir == "right" and templateData.extra =="forward" then
            templateData.dir = "left"
        elseif templateData.dir == "left" and templateData.extra == "backward" then
            templateData.dir = "right"
        end
        templateData.speed = 1
        templateData.type = "bank"
    elseif templateData.type == "bankSlip" then
        local template_pos = "left"
        if templateData.dir == "left" then
            template_pos = "right"
        end
        templateOrigin = MoveModule.GetTemplateOrigin(templateData.origin, templateData.orientation, templateData.shipSize, template_pos)
        templateData.type = "bank"
    elseif templateData.type == "turnSlip" then
        local template_pos = "left"
        if templateData.dir == "left" then
            template_pos = "right"
        end
        templateOrigin = MoveModule.GetTemplateOrigin(templateData.origin, templateData.orientation, templateData.shipSize, template_pos)
        templateData.type = "turn"
    elseif templateData.type == "echoF"  then
        templateOrigin = MoveModule.GetTemplateOrigin(templateData.origin, templateData.orientation, templateData.shipSize, templateData.dir)
        templateData.speed = 2
        templateData.type = "bank"
        if templateData.dir == "right" then
            templateData.dir = "left"
        elseif templateData.dir == "left" then
            templateData.dir = "right"
        end
    elseif templateData.type == "echoB"  then
        templateOrigin = MoveModule.GetTemplateOrigin(templateData.origin, templateData.orientation, templateData.shipSize, templateData.dir)
        templateData.speed = 2
        templateData.type = "bank"

    elseif templateData.type == "deCloak" then
        templateOrigin = MoveModule.GetTemplateOrigin(templateData.origin, templateData.orientation, templateData.shipSize, templateData.dir)
        if templateData.shipSize == "small" then
            templateData.speed = 2
        else
            templateData.speed = 1
        end
    else
        return
    end

    if templateData.type == "straight" or templateData.type == "roll" or templateData.type == "deCloak" then
        local offsetDistance = Convert_mm_igu(20)* tonumber(templateData.speed)
        local size = {Convert_mm_igu(20), Convert_mm_igu(6), templateData.speed*Convert_mm_igu(40)}
        if (templateData.type =="roll"  or templateData.type == "deCloak") and templateData.shipSize ~= "small" then
            size = {Convert_mm_igu(40), Convert_mm_igu(6), Convert_mm_igu(20)}
            offsetDistance = Convert_mm_igu(10)
        end
        local offset = vector(offsetDistance * math.sin(math.rad(templateOrigin.rot.y)),
        0, offsetDistance * math.cos(math.rad(templateOrigin.rot.y)) )

        local collissions = Physics.cast({
            origin       = templateOrigin.pos + offset,
            orientation  = templateOrigin.rot,
            direction    = {0,-0.001,0},
            type         = 3,
            size         = size,
            max_distance = 1,
            debug        = cast_debug
        })

        MoveModule.AddCollissionEntry(gTable, collList, collissions, SelectFun)
    elseif templateData.type == "bank" then
        local radius = 0
        if templateData.speed == 1 then
            radius = Convert_mm_igu(80)
        elseif templateData.speed == 2 then
            radius = Convert_mm_igu(130)
        elseif templateData.speed == 3 then
            radius = Convert_mm_igu(180)
        end
        local iterations = 10
        local radianStep = math.pi /(4*iterations)
        local dir_mod = 1
        if templateData.dir == "left" then
            dir_mod = -1
        end
        local c = math.cos(math.rad(templateOrigin.rot.y))
        local s = math.sin(math.rad(templateOrigin.rot.y))
        for i = 0, iterations do
            local radians = radianStep*i
            local orientation_offset = vector(0, math.deg(radians), 0)
            -- Calculate world position for template
            local pz = math.sin(radians)*radius
            local px = dir_mod * (1 - math.cos(radians))*radius
            -- Translate point to template origin
            local position_offset = vector(px * c + pz * s, 0, pz * c - px * s)

            local collissions = Physics.cast({
                origin       = templateOrigin.pos + position_offset,
                orientation  = templateOrigin.rot + orientation_offset * dir_mod,
                direction    = {0,-0.001,0},
                type         = 3,
                size         = {Convert_mm_igu(20), Convert_mm_igu(6), Convert_mm_igu(1)},
                max_distance = 1,
                debug        = cast_debug
            })
            MoveModule.AddCollissionEntry(gTable, collList, collissions, SelectFun)

        end
    elseif templateData.type == "turn" then
        local radius = 0
        if templateData.speed == 1 then
            radius = Convert_mm_igu(35)
        elseif templateData.speed == 2 then
            radius = Convert_mm_igu(62)
        elseif templateData.speed == 3 then
            radius = Convert_mm_igu(90)
        end
        local iterations = 10
        local radianStep = math.pi /(2*iterations)
        local dir_mod = 1
        if templateData.dir == "left" then
            dir_mod = -1
        end
        local c = math.cos(math.rad(templateOrigin.rot.y))
        local s = math.sin(math.rad(templateOrigin.rot.y))
        for i = 0, iterations do
            local radians = radianStep*i
            local orientation_offset = vector(0, math.deg(radians), 0)
            -- Calculate world position for template
            local pz = math.sin(radians)*radius
            local px = dir_mod * (1 - math.cos(radians))*radius
            -- Translate point to template origin
            local position_offset = vector(px * c + pz * s, 0, pz * c - px * s)

            local collissions = Physics.cast({
                origin       = templateOrigin.pos + position_offset,
                orientation  = templateOrigin.rot + orientation_offset * dir_mod,
                direction    = {0,-0.001,0},
                type         = 3,
                size         = {Convert_mm_igu(20), Convert_mm_igu(6), Convert_mm_igu(1)},
                max_distance = 1,
                debug        = cast_debug
            })
            MoveModule.AddCollissionEntry(gTable, collList, collissions, SelectFun)

        end
    end
end


-- Adds objects from the collissions table to the collList if it pass the selectfun
-- and is not already present
-- Arguments:
--      gTable          <- GUID table, containing allready present objects
--      collList        <- List of hit objects that have passed the select fun
--      collissions     <- Table of hits returned from a Physics.cast()
--      SelectFun       <- Function that returns true if object if of correct type
MoveModule.AddCollissionEntry = function(gTable, collList, collissions, SelectFun)
    for k,hit in pairs(collissions) do
        if gTable[hit.hit_object.getGUID()] == nil and SelectFun(hit.hit_object) then
            gTable[hit.hit_object.getGUID()] = true
            table.insert(collList, hit.hit_object)
        end
    end
end

-- Return all position and rotation for a template originating position based on ship size and direction
-- Arguments:
--      shipOrigin      <- The ship origin
--      shipOrientation <- Orientation of the ship
--      shipSize        <- Size of the ship (small, medium, large)
--      templateDir     <- Which direction to get position and orientation for
-- Return:
--      TemplateOrigin (position and rotation)
MoveModule.GetTemplateOrigin = function(shipOrigin, shipOrientation, shipSize, templateDir)
    -- OBS: Ships are placed backwards
    local orientation = shipOrientation
    orientation.y = orientation.y + 180
    if templateDir == "left" then
        orientation.y = orientation.y - 90
    elseif templateDir == "right" then
        orientation.y = orientation.y + 90
    elseif templateDir == "back" then
        orientation.y = orientation.y - 180
    end

    local distance = Convert_mm_igu(20)
    if shipSize == "medium" then
        distance = Convert_mm_igu(30)
    elseif shipSize == "large" then
        distance = Convert_mm_igu(40)
    end

    local position = shipOrigin + vector(distance * math.sin(math.rad(orientation.y)), 0 , distance*math.cos(math.rad(orientation.y)))

    return {pos = position, rot = orientation}
end


-- Check if provided ship in a provided position/rotation would collide with anything from the provided table
-- Return: {coll=collObject, minMargin=howFarCollisionIsStillCertain, numCheck=numCollideChecks}
MoveModule.CheckCollisions = function(ship, shipPosRot, collShipTable)
    local info = {coll=nil, minMargin=0, numCheck=0, numCast=0}
    local shipInfo = {pos=shipPosRot.pos, rot=shipPosRot.rot, ship=ship}
    local shipSize = ship.getTable("Data").Size or 'small'
    local certShipReach = Convert_mm_igu(mm_baseSize[shipSize]/2)              -- distance at which other ships MUST bump it
    local maxShipReach = Convert_mm_igu(mm_baseSize[shipSize]*math.sqrt(2)/2)  -- distance at which other ships CAN bump it

    for k, collShip in pairs(collShipTable) do
        local collShipSize = collShip.getTable("Data").Size or 'small'
        local certBumpDist = certShipReach + Convert_mm_igu(mm_baseSize[collShipSize]/2)            -- distance at which these two particular ships ships MUST bump
        local maxBumpDist = maxShipReach + Convert_mm_igu(mm_baseSize[collShipSize]*math.sqrt(2)/2) -- distance at which these two particular ships ships CAN bump

        local dist = Vect.Distance(shipPosRot.pos, collShip.getPosition())
        if dist < maxBumpDist then
            if dist < certBumpDist then
                info.coll = collShip
                if certBumpDist - dist > info.minMargin then
                    info.minMargin = certBumpDist - dist
                end
            elseif collide(shipInfo, {pos=collShip.getPosition(), rot=collShip.getRotation(), ship=collShip}) == true then
                info.coll = collShip
                info.numCheck = info.numCheck + 1
                break
            end
        end
    end
    if info.coll == nil then
        local hTable = {}
        if shipSize == 'huge' then
            hTable = MoveModule.FullCastCheck(ship, shipPosRot,  MoveModule.SelectHugeShips)
        else
            hTable = MoveModule.FullCastCheck(ship, shipPosRot,  MoveModule.SelectShips)
        end
        info.coll = hTable[1]
    end
    return info
end

MoveModule.partResolutionRough = 1/100  -- Resolution for rough checks (guaranteed)
MoveModule.partResolutionFine = 1/1000  -- Resolution for fine checks  (for forward adjust)

-- Module for trying and finding free positions
MoveModule.MoveProbe = {}

-- Get near ships when trying a move that allows for partial execution
-- Args: SEE MoveModule.MoveProbe.GetFreePart
-- Return: {shipRef1, shipRef2, ... , shipRefN}
MoveModule.MoveProbe.GetShipsNearPart = function(info, ship, partFun, partRange)
    local middlePart = (partRange.to - partRange.from)/2
    local maxShipReach = Convert_mm_igu(mm_baseSize[info.size]*math.sqrt(2))/2
    local moveReach = math.max( Vect.Distance(partFun(info.code, ship, middlePart).pos, partFun(info.code, ship, partRange.to).pos),
                                Vect.Distance(partFun(info.code, ship, middlePart).pos, partFun(info.code, ship, partRange.from).pos) )
    local collShipRange = moveReach + maxShipReach + Convert_mm_igu(mm_largeBase*math.sqrt(2))/2 + Convert_mm_igu(10)
    return ObjType.GetNearOfType(partFun(info.code, ship, MoveData.partMax/2).pos, collShipRange, 'ship', {ship})
end
-- Get first free part for a partial-enabled move (going through parts as partRange specifies)
-- Args:
--      info        <- move info as per MoveData.DecodeInfo
--      ship        <- object ref to a ship we want to move
--      partFun     <- function that takes (moveInfo, shipRef, part) and returns {pos=position, rot=rotation} (pure data, ignores collisions)
--      partRange   <- { from = partValueFromToCheck, to = partValueToCheckTo} ((from < to), (from > to) and (from == to) to all handled)
-- Return:  {
--      part        <- number of the part that was last checked (first free if other args specify free part was found)
--      info        <- nil if free part was found sowmehere, 'first' if partRange.from was free, 'overlap' if no part was free
--      collObj     <- nil if first part was free, object ref to last colliding ship otherwise
--          }
MoveModule.MoveProbe.GetFreePart = function(info, ship, partFun, partRange, moveLength)
    if moveLength == nil then moveLength = 0 end
    moveLength = Convert_mm_igu(moveLength)
    local out = {part = nil, info = nil, collObj = nil}
    local checkNum = {rough=0, fine=0}

    -- Get ships that *can* possibly collide during this move
    local collShips = MoveModule.MoveProbe.GetShipsNearPart(info, ship, partFun, partRange)

    -- Current part and part delts for ROUGH CHECKING
    local actPart = partRange.from
    local partDelta = math.sgn(partRange.to - partRange.from)*(MoveData.partMax*MoveModule.partResolutionRough)
    local minPartDelta = math.abs(partDelta)
    local collision = false

    -- Collision check, then part delta step or margin step
    repeat
        local nPos = partFun(info.code, ship, actPart)
        local collInfo = MoveModule.CheckCollisions(ship, nPos, collShips)
        checkNum.rough = checkNum.rough + collInfo.numCheck
        local distToSkip = nil
        if collInfo.coll ~= nil then
            collision = true
            distToSkip = collInfo.minMargin
            -- If there is a distance we can travel that assures collison will not end
            if distToSkip > 0 then
                -- Calculate how big part it is and skip away
                partDelta = math.sgn(partDelta)*((distToSkip * MoveData.partMax)/moveLength)
                if math.abs(partDelta) < minPartDelta then partDelta = math.sgn(partDelta)*minPartDelta end
            else
                partDelta = math.sgn(partDelta)*minPartDelta
            end
        else
            collision = false
        end
        if collision == true then
            out.collObj = collInfo.coll
            actPart = actPart + partDelta
        end
    -- until we're out of collisions OR we're out of part range
    until collision == false or ((partRange.to - actPart)*math.sgn(partDelta) < 0) or partDelta == 0

    if collision == false and partDelta ~= 0 and actPart ~= partRange.from then
        -- Right now, we're out of any collisions or at part 0 (no move)
        -- Go fineResolution of a move forward until we have a collision, then skip one back
        partDelta = math.sgn(partRange.to - partRange.from)*(MoveData.partMax*MoveModule.partResolutionFine)*-1
        local collInfo
        repeat
            local nPos = partFun(info.code, ship, actPart)
            collInfo = MoveModule.CheckCollisions(ship, nPos, {out.collObj})
            checkNum.fine = checkNum.fine + collInfo.numCheck
            if collInfo.coll ~= nil then
                collision = true
            else
                collision = false
            end
            actPart = actPart + partDelta
        until collision == true or (partRange.from - actPart)*math.sgn(partDelta) < 0
        actPart = actPart - 2*partDelta
        out.collObj = collInfo.coll -- This is what we hit
        out.part = actPart
    elseif collision == false then
        -- This happens if rough check didn't do anything (first part free, but no fullMove function)
        out.part = actPart
        out.info = 'first'
    elseif collision == true then
        -- This happens if rough check didn't escape collisions (no free part)
        out.info = 'overlap'
        out.part = partRange.to
    end
    -- print('-- GetFreePart CHECK_COUNT: ' .. checkNum.rough+checkNum.fine .. ' (' .. checkNum.rough .. ' + ' .. checkNum.fine .. ')')
    return out
end
-- Get near ships when trying a move that only allows for full execution
-- Args: SEE MoveModule.MoveProbe.TryFullMove
-- Return: {shipRef1, shipRef2, ... , shipRefN}
MoveModule.MoveProbe.GetShipsNearFull = function(info, ship, fullFun)
    local maxShipReach = Convert_mm_igu(mm_baseSize[info.size]*math.sqrt(2))/2
    local collShipRange = maxShipReach + Convert_mm_igu(mm_largeBase*math.sqrt(2))/2 + Convert_mm_igu(10)
    return ObjType.GetNearOfType(fullFun(info.code, ship).pos, collShipRange, 'ship', {ship})
end

-- Get near huge ships when trying a move that only allows for full execution
-- Args: SEE MoveModule.MoveProbe.TryFullMove
-- Return: {shipRef1, shipRef2, ... , shipRefN}
MoveModule.MoveProbe.GetHugeShipsNearFull = function(info, ship, fullFun)
    local shipsfound = MoveModule.MoveProbe.GetShipsNearFull(info, ship, fullFun)
    print("GetHugeShipsNearFull")
    shipsfound = table.sieve(shipsfound, function(obj) return (obj.getTable('Data').Size == 'huge') end)
    return shipsfound
end

-- Try a full version of a move
-- Args:
--      info        <- move info as per MoveData.DecodeInfo
--      ship        <- object ref to a ship we want to move
--      fullFun     <- function that takes (moveInfo, shipRef) and returns {pos=position, rot=rotation} (pure data, ignores collisions)
-- Return:  {
--      done        <- TRUE if move was completed, FALSE if it was obstructed
--      finalPosRot <- the final position and rotation after this move
--      collObj     <- nil if completed, object ref to colliding ship otherwise
--      collObs     <- nil if no obstacle moved over, object ref to obstacle if otherwise
--          }
MoveModule.MoveProbe.TryFullMove = function(info, ship, fullFun)
    local collShips = nil
    if info.size == 'huge' then
        collShips = MoveModule.MoveProbe.GetHugeShipsNearFull(info, ship, fullFun)
    else
        collShips = MoveModule.MoveProbe.GetShipsNearFull(info, ship, fullFun)
    end
    local out = {done=nil, finalPosRot=nil, collObj=nil, collObs=nil}
    local checkNum = 0

    local startPosRot = {['pos']=ship.GetPosition(), ['rot']=ship.GetRotation()}
    local finalPosRot = fullFun(info.code, ship)
    out.finalPosRot = finalPosRot

    -- Ship-to-ship collisions
    fullInfo = MoveModule.CheckCollisions(ship, finalPosRot, collShips)
    checkNum = checkNum + fullInfo.numCheck
    if fullInfo.coll == nil then
        out.done = true
    else
        out.done = false
        out.collObj = fullInfo.coll
    end

    -- Ship-to-obstacle collisions
    -- Get any obstacles that we're currently overlapping, and ignore them
    -- for the template check (but not for the final position check)
    local startingObstacleCollisions = MoveModule.CheckMineAndObstacleCollisions(ship, startPosRot, false, nil)

    local templateData =
    {
        origin = ship.GetPosition(),
        orientation = ship.GetRotation(),
        dir = info.dir,
        speed = info.speed,
        type = info.type,
        shipSize = info.size,
        extra = info.extra
    }
    -- Do the template and final position check
    local endingObstacleCollisions = MoveModule.CheckMineAndObstacleCollisions(ship, finalPosRot, false, templateData, startingObstacleCollisions)
    if #endingObstacleCollisions ~= 0 then
        out.collObs = endingObstacleCollisions[1]
    end

    return out
end

-- Get the FINAL position for a given move, including partial move and collisions
-- Follows traits from MoveData.DecodeInfo to try different move functions
-- Return:  {
--      finType     <- 'move' when did full/part mvoe
--                     'stationary' when there was no position change (rotation change allowed)
--                     'overlap' if there was no valid free target position
--                     IF OVERLAP, OTHER KEYS ARE TO BE IGNORED
--      finPos      <- { pos = finalPosition, rot = finalRotation }
--      collObj     <- nil if no collision, object ref to colliding ship otherwise
--      finPart     <- part of partial move performed, 'max' if full move, nil if not applicable
--          }
MoveModule.GetFinalPosData = function(move_code, ship, ignoreCollisions)
    local out = {finPos = nil, collObj = nil, finType = nil, finPart = nil}
    local info = MoveData.DecodeInfo(move_code, ship)

    -- Don't bother with collisions if it's stationary
    if info.speed == 0 then
        ignoreCollisions = true
    end

    -- NON-COLLISION VERSION
    if ignoreCollisions then
        if info.traits.full == true then
        -- If full moves are allowed, get a full move
            out.finPos = MoveModule.GetFullMove(info.code, ship)
            if info.speed == 0 then
                out.finType = 'stationary'
            else
                out.finType = 'move'
            end
            out.finPart = 'max'
            return out
        elseif info.traits.part == true then
        -- If partial moves are allowed, get max part move
            out.finPos = MoveModule.GetPartMove(info.code, ship, MoveData.partMax)
            out.finType = 'move'
            out.finPart = 'max'
            return out
        end

    -- COLLISION VERSION
    else
        -- If move allows for full move check, try it
        if info.traits.full == true then
            local fullData = MoveModule.MoveProbe.TryFullMove(info, ship, MoveModule.GetFullMove)
            while info.size == 'huge' and fullData.done == false do
              info.speed = info.speed -1
              if info.speed == -1 then
                info.speed = 0
                info.code = "s0"
                info.type = "straight"
              else
                info.code = string.gsub(info.code, "%d", info.speed)
              end
              fullData = MoveModule.MoveProbe.TryFullMove(info, ship, MoveModule.GetFullMove)
            end
            if fullData.done == true then
                out.finPos = MoveModule.GetFullMove(info.code, ship)
                out.finType = 'move'
                out.finPart = 'max'
                return out
            end
        end
        -- If move allows for partial execution, try to find a free part
        if info.traits.part == true then
            local partRange = {from=MoveData.partMax, to=0}
            local freePartData = MoveModule.MoveProbe.GetFreePart(info, ship, MoveModule.GetPartMove, partRange, MoveData.MoveLength(info))
            if freePartData.info ~= 'overlap' then
                out.finPos = MoveModule.GetPartMove(info.code, ship, freePartData.part)
                out.finType = 'move'
                out.finPart = freePartData.part
                out.collObj = freePartData.collObj
                return out
            end
        end
        -- If nothing worked out, we have an all-overlap
        out.finType = 'overlap'
        out.finPos = {pos=ship.getPosition(), rot=ship.getRotation()}
        return out
    end
end


-- Move ship to some position and handle stuff around it
-- If move is not stationary, clear target position and move tokens with it
-- Add history entry if save move name is provided
-- Args:
--      ship        <- object reference to ship to move
--      finData     <- {pos = targetPos, rot=targetRot}
--      saveName    <- move code for history save, no save done if nil
--      finFunction <- optional, function to call when the ship has come to rest
--      waitForTokens <- optional, whether or not we have to wait for the ships tokens to also come to a rest
MoveModule.MoveShip = function(ship, finData, saveName, finFunction, waitForTokens)
    if not ShipVerification.VerifyShipBase(ship) then
        return
    end
    XW_cmd.SetBusy(ship)
    MoveModule.RemoveOverlapReminder(ship)
    if finData.type ~= 'stationary' then
        TokenModule.QueueShipTokensMove(ship)
        local baseSize = ship.getTable("Data").Size or 'small'
        local shipReach = Convert_mm_igu(mm_baseSize[baseSize]+5)*(math.sqrt(2)/2)
        TokenModule.ClearPosition(finData.finPos.pos, shipReach, ship)
    end
    local finPos = finData.finPos
    if finData.noSave ~= true then
        MoveModule.SaveStateToHistory(ship, true)
    end
    ship.setPositionSmooth(finPos.pos, false, true)
    ship.setRotationSmooth(finPos.rot, false, true)
    -- Wait for resting, but provide final position to set so smooth move doesn't fuck with accuracy
    MoveModule.WaitForResting(ship, finPos, finFunction, waitForTokens)
    if saveName ~= nil then
        MoveModule.AddHistoryEntry(ship, {pos=finPos.pos, rot=finPos.rot, move=saveName, part=finData.finPart, finType=finData.finType})
    end
end



-- This part controls the waiting part of moving
-- Basically, if anything needs to be done after the ship rests, this can trigger it

-- Ships waiting to be resting
-- Entry: {ship = shipRef, finPos={pos=posToSet, rot=rotToSet}}
MoveModule.restWaitQueue = {}

-- Tokens waiting to be moved with ships
-- Entry: { tokens={t1, t2, ... , tN}, ship=shipWaitingFor }
-- tX: {ref = tokenRef, relPos = pos, relRot = rot}
-- elements wait here until ships are ready
MoveModule.tokenWaitQueue = {}

-- Add ship to the queue so it fires once it completes the move
-- OPTIONAL: finPos     <- position to be set at the end of the wait
-- OPTIONAL: finFun     <- function to be execeuted at the end of the wait (argument: waiting ship)
-- OPTIONAL: tokens     <- whether we also have to wait for the ship's tokens to finish moving afterwards.
MoveModule.WaitForResting = function(ship, finPos, finFun, waitForTokens)
    table.insert(MoveModule.restWaitQueue, {ship=ship, finPos=finPos, finFun=finFun, waitForTokens=waitForTokens})
    startLuaCoroutine(Global, 'restWaitCoroutine')
end

-- This completes when a ship is resting at a table level
-- Does token movement and ship locking after
-- IF a final position was provided in the data table, set it at the end
-- IF a final function was provideed in the data table, execute it at the end
function restWaitCoroutine()
    if MoveModule.restWaitQueue[1] == nil then
        return 1
    end

    local waitData = MoveModule.restWaitQueue[#MoveModule.restWaitQueue]
    local actShip = waitData.ship
    local finPos = waitData.finPos
    local finFun = waitData.finFun
    local waitForTokens = waitData.waitForTokens
    table.remove(MoveModule.restWaitQueue, #MoveModule.restWaitQueue)
    -- Wait
    repeat
        coroutine.yield(0)
    until actShip.resting == true and actShip.isSmoothMoving() == false and actShip.held_by_color == nil

    if finPos ~= nil then
        actShip.setPosition(finPos.pos)
        actShip.setRotation(finPos.rot)
    end

    local newTokenTable = {}
    for k,tokenSetInfo in pairs(MoveModule.tokenWaitQueue) do
        -- Move and pop waiting tokens
        if tokenSetInfo.ship == actShip then
            for k2,tokenData in pairs(tokenSetInfo.tokens) do
                local offset = Vect.RotateDeg(tokenData.relPos, actShip.getRotation()[2])
                local dest = Vect.Sum(offset, actShip.getPosition())
                dest[2] = dest[2]+0.5
                dest = TokenModule.VisiblePosition(tokenData.ref, tokenSetInfo.ship, dest)
                tokenData.ref.setPositionSmooth(dest, false,true)
                local tRot = tokenData.ref.getRotation()
                tokenData.ref.setRotationSmooth({tRot[1], actShip.getRotation()[2] + tokenData.relRot, tRot[3]})
                tokenData.ref.highlightOn({0, 1, 0}, 2)
            end
        else
            -- Index back tokens that are not waiting for this ship
            table.insert(newTokenTable, tokenSetInfo)
        end
    end

    if waitForTokens == true then
        repeat
            coroutine.yield(0)
        until TokenModule.DoesShipHasAnySmoothMovingTokens(actShip) == false
    end

    MoveModule.tokenWaitQueue = newTokenTable
    actShip.lock()
    actShip.highlightOn({0, 1, 0}, 0.1)
    XW_cmd.SetReady(actShip)
    if finFun ~= nil then
        finFun(actShip)
    end
    return 1
end

-- Perform move designated by move_code on a ship and announce the result
-- How move is preformed generally relies on MoveData.DecodeInfo for its code
-- Includes token handling so nothing obscurs the final position
-- Starts the wait coroutine that handles stuff done when ship settles down
-- Takes two optional parameters, the function to call at the end of the move,
-- and whether we have to wait for the tokens to come to a rest before calling
-- it.
MoveModule.PerformMove = function(move_code, ship, ignoreCollisions, finishFunction, waitForTokens)
    ship.lock()
    local originalPos = ship.getPosition()
    local origionalRot = ship.getRotation()
    local info = MoveData.DecodeInfo(move_code, ship)
    local finData = MoveModule.GetFinalPosData(move_code, ship, ignoreCollisions)
    local annInfo = {type=finData.finType, note=info.note, code=info.code}
    if finData.finType == 'overlap' then
        annInfo.note = info.collNote
    elseif finData.finType == 'move' then
        if finData.collObj ~= nil then
            annInfo.note = info.collNote
            annInfo.collidedShip = finData.collObj
        end
    elseif finData.finType == 'stationary' then
        -- And here as well
    end

    if finData.finType ~= 'overlap' then
        MoveModule.MoveShip(ship, finData, move_code, finishFunction, waitForTokens)
        if finData.collObj ~= nil then
            MoveModule.SpawnOverlapReminder(ship)
        end
    end
    AnnModule.Announce(annInfo, 'all', ship)

    local templateData =
    {
        origin = originalPos,
        orientation = origionalRot,
        dir = info.dir,
        speed = info.speed,
        type = info.type,
        shipSize = info.size,
        extra = info.extra
    }

    MoveModule.CheckMineAndObstacleCollisions(ship, finData.finPos, true, templateData)
    --MoveModule.CheckObstacleCollisions(ship, finData.finPos, true, templateData)
    --MoveModule.CheckMineCollisions(ship, finData.finPos, true, templateData)
    return (finData.finType ~= 'overlap')
end

-- Spawn a 'BUMPED' informational button on the base that removes itself on click or next move
MoveModule.SpawnOverlapReminder = function(ship)
    Ship_RemoveOverlapReminder(ship)
    remindButton = {click_function = 'Ship_RemoveOverlapReminder', label = 'BUMPED', rotation =  {0, 0, 0}, width = 1000, height = 350, font_size = 250}

    local size = ship.getTable("Data").Size or 'small'
    if size == 'large' then
        remindButton.position = {0, 0.2, 2}
    elseif size == 'medium' then
        remindButton.position = {0, 0.2, 1.4}
    else
        remindButton.position = {0, 0.3, 0.8}
    end
    ship.createButton(remindButton)
end

-- Remove the 'BUMPED' dummy button from a ship
MoveModule.RemoveOverlapReminder = function(ship)
    local buttons = ship.getButtons()
    if buttons ~= nil then
        for k,but in pairs(buttons) do if but.label == 'BUMPED' then ship.removeButton(but.index) end end
    end
end

-- Check if a ship in some situation is overlapping any obstacles
-- Highlight overlapped obstacles red
-- If 'vocal' set to true, add a notification
-- Return table of overlapped obstacles
MoveModule.CheckObstacleCollisions = function(ship, targetPosRot, vocal, templateData)
    local collList = MoveModule.FullCastCheck(ship, targetPosRot,  MoveModule.SelectObstacles)
    if templateData ~= nil then
        MoveModule.TemplateCastCheck(ship, collList, templateData, MoveModule.SelectObstacles)
    end
    if collList[1] ~= nil then
        local obsList = '('
        for k,obs in pairs(collList) do
            obs.highlightOn({1, 0, 0}, 3)
            obsList = obsList .. obs.getName() .. ', '
        end
        obsList = obsList:sub(1, -3) .. ')'
        if vocal then
            AnnModule.Announce({type='warn', note=ship.getName() .. ' appears to have overlapped an obstacle ' .. obsList}, 'all')
        end
    end
    return collList
end



-- Check if a ship in some situation is overlapping any mine tokens
-- Highlight overlapped tokens red
-- If 'vocal' set to true, add a notification
-- Return table of overlapped tokens
--TODO maybe check mine colision after bomb drop?
MoveModule.CheckMineCollisions = function(ship, targetPosRot, vocal, templateData)
    local collList = MoveModule.FullCastCheck(ship, targetPosRot,  MoveModule.SelectMineTokens)
    if templateData ~= nil then
        MoveModule.TemplateCastCheck(ship, collList, templateData, MoveModule.SelectMineTokens)
    end
    if collList[1] ~= nil then
        local mineList = '('
        for k,mine in pairs(collList) do
            mine.highlightOn({1, 0, 0}, 3)
            mineList = mineList .. mine.getName() .. ', '
        end
        mineList = mineList:sub(1, -3) .. ')'
        if vocal then
            AnnModule.Announce({type='warn', note=ship.getName() .. ' appears to have overlapped a mine token ' .. mineList}, 'all')
        end
    end
    return collList
end

MoveModule.CheckMineAndObstacleCollisions = function(ship, targetPosRot, vocal, templateData, ignoredTemplateObstacles)
    local collList = MoveModule.FullCastCheck(ship, targetPosRot,  MoveModule.SelectMinesAndObstacleTokens)
    if templateData ~= nil then
        MoveModule.TemplateCastCheck(ship, collList, templateData, function(obj)
            if ignoredTemplateObstacles ~= nil then
                for _, ignoredTemplate in pairs(ignoredTemplateObstacles) do
                    if obj == ignoredTemplate then
                        return false
                    end
                end
            end
            return MoveModule.SelectMinesAndObstacleTokens(obj)
        end)
    end
    if vocal then
        if collList[1] ~= nil then
            local hitList = '('
            for k, hitObj in pairs(collList) do
                hitObj.highlightOn({1, 0, 0}, 3)
                hitList = hitList .. hitObj.getName() .. ', '
            end
            hitList = hitList:sub(1, -3) .. ')'
            AnnModule.Announce({type='warn', note=ship.getName() .. ' appears to have overlapped a mine or obstacle token ' .. hitList}, 'all')
        end
    end
    return collList
end

-- Remove the 'BUMPED' button from a ship (click function)
function Ship_RemoveOverlapReminder(ship)
    MoveModule.RemoveOverlapReminder(ship)
end

-- Check which ship has it's base closest to position (large ships have large bases!), that's the owner
--   also check how far it is to the owner-changing position (margin of safety)
-- Kinda tested: margin > 20mm = visually safe
-- Arg can be a token ref or a position
-- Returns {dist=distanceFromOwner, owner=ownerRef, margin=marginForNextCloseShip}
MoveModule.GetTokenOwner = function(tokenPos)
    local out = {owner=nil, dist=0, margin=-1}
    local nearShips = ObjType.GetNearOfType(tokenPos, Convert_mm_igu(120), 'ship')
    if nearShips[1] == nil then return out end
    local baseDist = {}
    -- Take the base size into account for distances
    for k,ship in pairs(nearShips) do
        local realDist = Vect.Distance(tokenPos, ship.getPosition())
        local size = ship.getTable("Data").Size or 'small'
        if size == 'large' then
            realDist = realDist - Convert_mm_igu(10)
        elseif size == 'medium' then
            realDist = realDist - Convert_mm_igu(5)
        elseif size == 'huge' then
            realDist = realDist - Convert_mm_igu(15) -- Todo, check if this arbetary number works
        end
        table.insert(baseDist, {ship=ship, dist=realDist})
    end
    local nearest = baseDist[1]
    for k,data in pairs(baseDist) do
        if data.dist < nearest.dist then nearest = data end
    end
    local nextNearest = {dist=999}
    for k,data in pairs(baseDist) do
        if data.ship ~= nearest.ship and (data.dist < nextNearest.dist) then
            nextNearest = data
        end
    end
    return {owner=nearest.ship, dist=nearest.dist, margin=(nextNearest.dist-nearest.dist)/2}
end

-- END MAIN MOVEMENT MODULE
--------

--------
-- TOKEN MODULE
-- Moves tokens, clears positions from tokens, checks its owners, deducts a visible position after a ship move

TokenModule = {}
-- Table with refs for different token and template sources
TokenModule.tokenSources = {}

TokenModule.tokenAssignments = {}

-- Update token and template sources on each load
TokenModule.onLoad = function()
    for k, obj in pairs(getAllObjects()) do
        if obj.tag == 'Infinite' then
            if obj.getName() == 'Focus' then TokenModule.tokenSources.Focus = {src=obj, hlColor={0, 0.5, 0}}
            elseif obj.getName() == 'Calculate' then TokenModule.tokenSources.Calculate = {src=obj, hlColor={0, 1, 0}}
            elseif obj.getName() == 'Evade' then TokenModule.tokenSources.Evade = {src=obj, hlColor={0, 1, 0}}
            elseif obj.getName() == 'Stress' then TokenModule.tokenSources.Stress = {src=obj, hlColor={0.8, 0, 0}}
            elseif obj.getName() == 'Strain' then TokenModule.tokenSources.Strain = {src=obj, hlColor={0.8, 0, 0}}
            elseif obj.getName() == 'Deplete' then TokenModule.tokenSources.Deplete = {src=obj, hlColor={0.8, 0, 0}}
            elseif obj.getName() == 'Ion' then TokenModule.tokenSources.Ion = {src=obj, hlColor={0.8, 0, 0}}
            elseif obj.getName() == 'Jam' then TokenModule.tokenSources.Jam = {src=obj, hlColor={0.8, 0, 0}}
            elseif obj.getName() == 'Tractor' then TokenModule.tokenSources.Tractor = {src=obj, hlColor={0.8, 0, 0}}
            elseif obj.getName() == 'Disarm' then TokenModule.tokenSources.Disarm = {src=obj, hlColor={0.8, 0, 0}}
            elseif obj.getName() == 'Reinforce' then TokenModule.tokenSources.Reinforce = {src=obj, hlColor={0.8, 0, 0}}
            elseif obj.getName() == 'Cloak' then TokenModule.tokenSources.Cloak = {src=obj, hlColor={0.8, 0, 0}}
            elseif obj.getName() == 'Target Locks' then TokenModule.tokenSources['Target Lock'] = {src=obj, hlColor={0, 0, 1}}
            elseif obj.getName():find('Templates') ~= nil then
                if obj.getName():find('Straight') ~= nil then
                    TokenModule.tokenSources['s' .. obj.getName():sub(1,1)] = obj
                elseif obj.getName():find('Turn') ~= nil then
                    TokenModule.tokenSources['t' .. obj.getName():sub(1,1)] = obj
                elseif obj.getName():find('Bank') ~= nil then
                    TokenModule.tokenSources['b' .. obj.getName():sub(1,1)] = obj
                end
            end
        end
    end
end
EventSub.Register('onLoad', TokenModule.onLoad)

TokenModule.onObjectDestroyed = function(destroyed_object)
    if TokenModule.tokenAssignments[destroyed_object.getGUID()] ~= nil then
        TokenModule.tokenAssignments[destroyed_object.getGUID()].call("RemoveToken",{token=destroyed_object})
        TokenModule.tokenAssignments[destroyed_object.getGUID()] = nil
    end
end

TokenModule.onObjectDropped = function(player_color, object)
    if ObjType.IsOfType(object, 'token') then
        if object.getVar('__XW_TokenType') ~= 'targetLock' then -- Target lock has special onDrop handling on its own
            local spos = object.getPosition()
            local spos = object.getPosition()
            local nearest = nil
            local minDist = 3.6125 -- 100 mm
            for k,ship in pairs(getAllObjects()) do
                if MoveModule.SelectShips(ship) then
                    local pos = ship.getPosition()
                    local dist = math.sqrt(math.pow((spos[1]-pos[1]),2) + math.pow((spos[3]-pos[3]),2))
                    if dist < minDist then
                        nearest = ship
                        minDist = dist
                    end
                end
            end
            TokenModule.AssignToken(object, nearest)
        end
    end
end

EventSub.Register('onObjectDropped', TokenModule.onObjectDropped)


-- How far can tokens be to be considered owned bya  ship
TokenModule.tokenReachDistance = Convert_mm_igu(100)
-- By how much this token has to be distant from other ship "interception zone" to be visible
-- (how far from an owner-switching-border it has to be so you can see whose it is)
TokenModule.visibleMargin = Convert_mm_igu(20)

-- Preset positions for tokens on and near the base
-- Generally used only when their current position switches its owner after a move
-- Positions on the base

TokenModule.basePos = {}

-- On base - small ships
TokenModule.basePos.small = {}
TokenModule.basePos.small.Focus     = { 12,  12}
TokenModule.basePos.small.Calculate = { 12,  24}
TokenModule.basePos.small.Evade     = { 12, -12}
TokenModule.basePos.small.Stress    = {-12,  12}
TokenModule.basePos.small.Ion       = {-12,  -24}
TokenModule.basePos.small.Strain    = {-12,  24}
TokenModule.basePos.small.Deplete    = {-12,  36}

TokenModule.basePos.small.Reinforce = {-24,  24}
TokenModule.basePos.small.Cloak     = {-24, -24}
TokenModule.basePos.small.Jam       = { 24, -12}
TokenModule.basePos.small.Disarm    = { 24,  12}
TokenModule.basePos.small.Tractor   = { 24,  24}

TokenModule.basePos.small.rest      = {-12, -12}

--On base - medium ships
TokenModule.basePos.medium = {}
TokenModule.basePos.medium.Focus     = { 25,  25}
TokenModule.basePos.medium.Calculate = { 25,  35}
TokenModule.basePos.medium.Evade     = { 25, -25}
TokenModule.basePos.medium.Stress    = {-25,  25}
TokenModule.basePos.medium.Ion       = {-25, -35}
TokenModule.basePos.medium.Strain    = {-25,  35}
TokenModule.basePos.medium.Deplete   = {-25,  -45}

TokenModule.basePos.medium.Reinfoce  = {-35,  35}
TokenModule.basePos.medium.Cloak     = {-35, -35}
TokenModule.basePos.medium.Jam       = { 35, -25}
TokenModule.basePos.medium.Disarm    = { 35,  25}
TokenModule.basePos.medium.Tractor   = { 35,  35}

TokenModule.basePos.medium.rest      = {-25, -25}

-- On base - large ships
TokenModule.basePos.large = {}
TokenModule.basePos.large.Focus     = { 30,  30}
TokenModule.basePos.large.Calculate = { 30,  40}
TokenModule.basePos.large.Evade     = { 30,   0}
TokenModule.basePos.large.Stress    = { 30, -30}
TokenModule.basePos.large.Strain    = { 30, -40}
TokenModule.basePos.large.Deplete   = {-30, -40}
TokenModule.basePos.large.Tractor   = {-30,  30}
TokenModule.basePos.large.Ion       = {-30,   0}
TokenModule.basePos.large.Lock      = {  0,  30}

TokenModule.basePos.large.Cloak     = { 30,  30}
TokenModule.basePos.large.Reinforce = {-30,  30}
TokenModule.basePos.large.Jam       = {-30, -30}
TokenModule.basePos.large.Disarm    = { 40,  30}

TokenModule.basePos.large.rest      = {-30, -30}

-- On base - huge ships
TokenModule.basePos.huge = {}
TokenModule.basePos.huge.Focus     = { 30,  30}
TokenModule.basePos.huge.Calculate = { 30,  40}
TokenModule.basePos.huge.Evade     = { 30,   0}
TokenModule.basePos.huge.Stress    = { 30, -30}
TokenModule.basePos.huge.Strain    = { 30, -40}
TokenModule.basePos.huge.Deplete   = {-30, -40}
TokenModule.basePos.huge.Tractor   = {-30,  30}
TokenModule.basePos.huge.Ion       = {-30,   0}
TokenModule.basePos.huge.Lock      = {  0,  30}

TokenModule.basePos.huge.Cloak     = { 30,  30}
TokenModule.basePos.huge.Reinforce = {-30,  30}
TokenModule.basePos.huge.Jam       = {-30, -30}
TokenModule.basePos.huge.Disarm    = { 40,  30}

TokenModule.basePos.huge.rest      = {-30, -30}

-- Positions near the base
-- Near base - small ships
TokenModule.nearPos = {}

TokenModule.nearPos.small = {}
TokenModule.nearPos.small.Focus     = { 35,  25}
TokenModule.nearPos.small.Calculate = { 15,  35}
TokenModule.nearPos.small.Evade     = { 35,   0}
TokenModule.nearPos.small.Stress    = { 35, -25}
TokenModule.nearPos.small.Strain    = { 35, -35}
TokenModule.nearPos.small.Deplete   = {-35, -35}
TokenModule.nearPos.small.Ion       = {-35,  25}
TokenModule.nearPos.small.Tractor   = {-35,   0}
TokenModule.nearPos.small.Lock      = {  0,  40}


TokenModule.nearPos.small.Reinfoce  = {-35,  35}
TokenModule.nearPos.small.Cloak     = {-35, -35}
TokenModule.nearPos.small.Jam       = { 35, -25}
TokenModule.nearPos.small.Disarm    = { 35,  25}

TokenModule.nearPos.small.rest      = {-35, -25}

-- Near base - medium ships
TokenModule.nearPos.medium = {}
TokenModule.nearPos.medium.Focus     = { 45,  28}
TokenModule.nearPos.medium.Calculate = { 45,  56}
TokenModule.nearPos.medium.Evade     = { 45,   0}
TokenModule.nearPos.medium.Stress    = { 45, -28}
TokenModule.nearPos.medium.Strain    = { 45, -45}
TokenModule.nearPos.medium.Deplete   = {-45, -45}
TokenModule.nearPos.medium.Ion       = {-45,  28}
TokenModule.nearPos.medium.Tractor   = {-45,   0}
TokenModule.nearPos.medium.Lock      = {  0,  45}

TokenModule.nearPos.medium.Reinfoce  = {-35,  35}
TokenModule.nearPos.medium.Cloak     = {-35, -35}
TokenModule.nearPos.medium.Jam       = { 35, -25}
TokenModule.nearPos.medium.Disarm    = { 35,  25}

TokenModule.nearPos.medium.rest      = {-45, -35}

-- Near base - large ships
TokenModule.nearPos.large = {}
TokenModule.nearPos.large.Focus     = { 55,  30}
TokenModule.nearPos.large.Calculate = { 55,  30}
TokenModule.nearPos.large.Evade     = { 55,   0}
TokenModule.nearPos.large.Stress    = { 55, -30}
TokenModule.nearPos.large.Strain    = { 55, -55}
TokenModule.nearPos.large.Deplete   = {-55, -55}
TokenModule.nearPos.large.Tractor   = {-55,  45}
TokenModule.nearPos.large.Ion       = {-55,  15}
TokenModule.nearPos.large.Weapons   = {-55, -15}
TokenModule.nearPos.large.Lock      = {  0,  50}

TokenModule.nearPos.large.Reinfoce = {-45,  45}
TokenModule.nearPos.large.Cloak     = {-45, -45}
TokenModule.nearPos.large.Jam       = { 45, -45}
TokenModule.nearPos.large.Disarm    = { 45,  45}

TokenModule.nearPos.large.rest      = {-55, -45}

-- Near base - large ships
TokenModule.nearPos.huge = {}
TokenModule.nearPos.huge.Focus     = { 55,  30}
TokenModule.nearPos.huge.Calculate = { 55,  30}
TokenModule.nearPos.huge.Evade     = { 55,   0}
TokenModule.nearPos.huge.Stress    = { 55, -30}
TokenModule.nearPos.huge.Strain    = { 55, -55}
TokenModule.nearPos.huge.Deplete   = {-55, -55}
TokenModule.nearPos.huge.Tractor   = {-55,  45}
TokenModule.nearPos.huge.Ion       = {-55,  15}
TokenModule.nearPos.huge.Weapons   = {-55, -15}
TokenModule.nearPos.huge.Lock      = {  0,  50}

TokenModule.nearPos.huge.Reinfoce = {-45,  45}
TokenModule.nearPos.huge.Cloak     = {-45, -45}
TokenModule.nearPos.huge.Jam       = { 45, -45}
TokenModule.nearPos.huge.Disarm    = { 45,  45}

TokenModule.nearPos.huge.rest      = {-55, -45}

-- Deduct target token position in the world for a ship, token and some entry from TokenModule.basePos or .nearPos
TokenModule.TokenPos = function(tokenName, ship, posTable)
    local baseSize = ship.getTable("Data").Size or 'small'
    local entry = posTable[baseSize].rest
    for tokenEntryName, tEntry in pairs(posTable[baseSize]) do
        if tokenName:find(tokenEntryName) ~= nil then
            entry = tEntry
        end
    end
    local tsPos = {Convert_mm_igu(entry[1]), 0.5, Convert_mm_igu(entry[2])}
    return Vect.Sum(ship.getPosition(), Vect.RotateDeg(tsPos, ship.getRotation()[2]+180))
end

-- Return position for a given token that is on the base of given ship
TokenModule.BasePosition = function(tokenName, ship)
    local name = nil
    if type(tokenName) == 'string' then
            name = tokenName
    elseif type(tokenName) == 'userdata' then
        name = tokenName.getName()
    end
    return TokenModule.TokenPos(name, ship, TokenModule.basePos)
end
-- Return position for a given token that is near the base of given ship
TokenModule.NearPosition = function(tokenName, ship)
    local name = nil
    if type(tokenName) == 'string' then
            name = tokenName
    elseif type(tokenName) == 'userdata' then
        name = tokenName.getName()
    end
    return TokenModule.TokenPos(name, ship, TokenModule.nearPos)
end

-- Return a visible position for some token near some ship
-- Priorities as follows (OK if token is still visible there as in you can see who is its owner easily):
-- 1. Prefer the position given as 3rd argument if passed
-- 2. Prefer position on a stack if a stack of tokens already belongs to a ship
-- 3. Prefer position NEAR ship base as position table dictates
-- 3. Prefer position ON ship base as position table dictates (if all else fails, this will be returned)
TokenModule.VisiblePosition = function(tokenName, ship, preferredPos)
    -- Check preferred position margin
    if preferredPos ~= nil then
        local prefInfo = TokenModule.TokenOwnerInfo(preferredPos)
        if prefInfo.owner == ship and prefInfo.margin > TokenModule.visibleMargin then
            return preferredPos
        end
    end
    -- Check for present stacks
    local currTokensInfo = TokenModule.GetShipTokensInfo(ship)
    local currStack = {qty=-2, obj=nil}
    for k,tokenInfo in pairs(currTokensInfo) do
        if tokenInfo.token.getName() == tokenName and tokenInfo.token.getQuantity() > currStack.qty and (not tokenInfo.token.IsSmoothMoving()) then
            currStack.obj = tokenInfo.token
            currStack.qty = currStack.obj.getQuantity()
        end
    end
    if currStack.obj ~= nil then
        return Vect.Sum(currStack.obj.getPosition(), {0, 0.7, 0})
    end
    -- Check for near near base position or return base position
    local nearPos = TokenModule.NearPosition(tokenName, ship)
    local nearData = TokenModule.TokenOwnerInfo(nearPos)
    if nearData.margin < TokenModule.visibleMargin then
        return TokenModule.BasePosition(tokenName, ship)
    else
        return nearPos
    end
end

-- Check which tokens belong to a ship and queue them to be moved with it
-- Needs the MoveModule.WaitForResting fired to actually use stuff from this queue
TokenModule.QueueShipTokensMove = function(ship)
    local selfTokens = TokenModule.GetShipTokens(ship)
    local waitTable = {tokens = {}, ship=ship}
    -- Save relative position/rotation
    for k,token in pairs(selfTokens) do
        print("QueueShipTokensMove: " .. token.getName())
        local relPos = Vect.RotateDeg(Vect.Between(ship.getPosition(), token.getPosition()), -1*ship.getRotation()[2])
        local relRot = token.getRotation()[2] - ship.getRotation()[2]
        table.insert(waitTable.tokens, {ref=token, relPos=relPos, relRot=relRot})
    end
    table.insert(MoveModule.tokenWaitQueue, waitTable)
end

-- Table for locks to be set and callback to trigger their naming and coloring
-- Entry: {lock=targetLockRef, color=colorToTint, name=nameToSet}
TokenModule.locksToBeSet = {}

-- Callback to set ALL the locks in wueue
function TokenModule_SetLocks()
    for k,info in pairs(TokenModule.locksToBeSet) do
        info.lock.call('manualSet', {color=info.color, name=info.name})
        info.lock.highlightOn({0,0,0}, 0.01)

        if info.ship ~= nil then
            info.lock.call('setOwner', {ship=info.ship})
        end

        if info.target ~= nil then
            info.lock.call('assignToShip', {ship=info.target})
        end
    end
    TokenModule.locksToBeSet = {}
end

-- Table for locks to be set and callback to trigger their naming and coloring
-- Entry: {lock=targetLockRef, color=colorToTint, name=nameToSet}
TokenModule.tractorsToBeSet = {}

-- Callback to set ALL the locks in wueue
function TokenModule_SetTractors()
    for k,info in pairs(TokenModule.tractorsToBeSet) do
        info.tractor.call('manualSet',{ref=info.ref})
        info.tractor.highlightOn({0,0,0}, 0.01)
    end
    TokenModule.tractorsToBeSet = {}
end

-- Table for tokens to be flipped and callback to trigger their flipping
-- Entry: token
TokenModule.tokensToBeFlipped = {}

function TokenModule_FlipTokens()
    for _, token in pairs(TokenModule.tokensToBeFlipped) do
        token.flip()
    end
    TokenModule.tokensToBeFlipped = {}
end


-- Table for locks to be set and callback to trigger their naming and coloring
-- Entry: {lock=targetLockRef, color=colorToTint, name=nameToSet}
TokenModule.ionsToBeSet = {}

-- Callback to set ALL the locks in wueue
function TokenModule_SetIons()
    for k,info in pairs(TokenModule.ionsToBeSet) do
        info.ion.call('manualSet',{ref=info.ref})
        info.ion.highlightOn({0,0,0}, 0.01)
    end
    TokenModule.ionsToBeSet = {}
end

-- Take a token of some type and move to some position
-- Player color argument only matters when taking target locks
-- Returns ref to a newly taken token
-- Highlights the token with type-aware color
TokenModule.TakeToken = function(type, playerColor, dest, flip)
    local takeTable = {}
    if dest ~= nil then
        takeTable.position = dest
    end
    local highlightColor = TokenModule.tokenSources[type].hlColor
    if type == 'Target Lock' then
        takeTable.callback = 'TokenModule_SetLocks'
        takeTable.callback_owner = Global
    elseif type == 'Ion' then
        takeTable.callback = 'TokenModule_SetIons'
        takeTable.callback_owner = Global
    elseif type == 'Tractor' then
        takeTable.callback = 'TokenModule_SetTractors'
        takeTable.callback_owner = Global
    elseif flip == true then
        takeTable.callback = 'TokenModule_FlipTokens'
        takeTable.callback_owner = Global
    end
    local newToken = TokenModule.tokenSources[type].src.takeObject(takeTable)
    newToken.highlightOn(highlightColor, 3)
    return newToken
end

-- Get owner info from a token or positions
-- Return:  {
--      token   <- passed token ref if arg was a token ref
--      owner   <- ship ref to owner, nil if none
--      dist    <- distance to owner (igu)
--      margin  <- how far from owner token would have to be moved to change owner
--          }
TokenModule.TokenOwnerInfo = function(tokenPos)
    local pos = nil
        local out = {token=nil, owner=nil, dist=0, margin=-1}
    if type(tokenPos) == 'table' then
        pos = tokenPos
    elseif type(tokenPos) == 'userdata' then
        out.token = tokenPos
        pos = tokenPos.getPosition()
    end
    local nearShips = ObjType.GetNearOfType(pos, TokenModule.tokenReachDistance, 'ship')
    if nearShips[1] == nil then return out end
    local baseDist = {}
    -- Take the base size into account for distances
    for k,ship in pairs(nearShips) do
        local realDist = Vect.Distance(pos, ship.getPosition())
        local size = ship.getTable("Data").Size or 'small'
        if size == 'large' then
          realDist = realDist - Convert_mm_igu(10)
        elseif size == 'medium' then
          realDist = realDist - Convert_mm_igu(5)
        end
        table.insert(baseDist, {ship=ship, dist=realDist})
    end
    local nearest = {ship=nil, dist=999}
    local nextNearest = {ship=nil, dist=999}
    for k,data in pairs(baseDist) do
        if data.dist < nearest.dist then
            nextNearest = nearest
            nearest = data
        elseif data.dist < nextNearest.dist then
            nextNearest = data
        end
    end
    out.owner = nearest.ship
    out.dist = nearest.dist
    if nextNearest.ship == nil then
        out.margin = 999
    else
        out.margin = (nextNearest.dist-nearest.dist)/2
    end
    return out
end

-- Return table of MoveModule.GetTokenInfo entries for all tokens withis some distance of given position
TokenModule.GetNearTokensInfo = function(pos, dist)
    local reachDist = TokenModule.tokenReachDistance
    if dist ~= nil then
        reachDist = dist
    end
    local nearTokens = ObjType.GetNearOfType(pos, reachDist, 'token')
    local shipTokensInfo = {}
    for k,token in pairs(nearTokens) do
        local tokenInfo = TokenModule.TokenOwnerInfo(token)
        table.insert(shipTokensInfo, tokenInfo)
    end
    return shipTokensInfo
end

TokenModule.GetShipTokenCount = function(ship, token_name)
    local count = 0;

    for _, token in pairs(TokenModule.GetShipTokens(ship)) do
        if token.getName() == token_name and token.getVar('deleted') == nil then
            local quantity = token.getQuantity()
            if quantity < 0 then
                quantity = 1
            end
            count = count + quantity
        end
    end

    return count
end

-- Return table of MoveModule.GetTokenInfo enties for all tokens that are owned by given ship
TokenModule.GetShipTokensInfo = function(ship)
    local shipTokens = TokenModule.GetShipTokens(ship)
    local shipTokensInfo = {}
    for k,token in pairs(shipTokens) do
        table.insert(shipTokensInfo, TokenModule.TokenOwnerInfo(token))
    end

    return shipTokensInfo
end

-- Return table of object references for all tokens that are owned by given ship
TokenModule.GetShipTokens = function(ship)
    return ship.call("GetTokens")
end

-- Returns whether any of this ships tokens are currently smooth moving.
TokenModule.DoesShipHasAnySmoothMovingTokens = function(ship)
    local ship_tokens = TokenModule.GetShipTokens(ship)
    for _, token in pairs(ship_tokens) do
        if token.isSmoothMoving() then
            return true
        end
    end

    return false
end

-- Clear given distance within position from tokens
-- If given third argument, this hip tokens will be ignored
-- Tokens that have an owner will be moved near(er)/on it
-- Stray tokens will be yanked away
TokenModule.ClearPosition = function(pos, dist, ignoreShip)
    local clearDist = dist + Convert_mm_igu(20)
    local posTokenInfo = TokenModule.GetNearTokensInfo(pos, clearDist)
    for k,tokenInfo in pairs(posTokenInfo) do
        if tokenInfo.token.getButtons() == nil then
            if tokenInfo.owner ~= nil and tokenInfo.owner ~= ignoreShip then
                local visPos = TokenModule.VisiblePosition(tokenInfo.token.getName(), tokenInfo.owner)
                if Vect.Distance(visPos, pos) <= clearDist then
                    local basePos = TokenModule.BasePosition(tokenInfo.token.getName(), tokenInfo.owner)
                    tokenInfo.token.setPositionSmooth(basePos)
                else
                    tokenInfo.token.setPositionSmooth(visPos)
                end
            else
                local ptVect = Vect.Between(pos, tokenInfo.token.getPosition())
                ptVect[2] = 0
                local actDist = Vect.Distance(tokenInfo.token.getPosition(), pos)
                local distToMove = 2*clearDist - actDist
                local targetPos = Vect.Sum(tokenInfo.token.getPosition(), Vect.SetLength(ptVect, distToMove))
                targetPos[2] = targetPos[2] + 0.5
                tokenInfo.token.setPositionSmooth(targetPos)
            end
        end
    end
end

TokenModule.AssignToken = function(token, ship)
    Wait.condition(function()
        local guid = token.getGUID()
        if (TokenModule.tokenAssignments[guid] ~= nil) and (TokenModule.tokenAssignments[guid].tag == 'Figurine') then
            if TokenModule.tokenAssignments[guid].getVar("RemoveToken") ~= nil then
                TokenModule.tokenAssignments[guid].call("RemoveToken", {token=token})
            end
        end
        TokenModule.tokenAssignments[guid] = ship
        if ship ~= nil then
            token.setDescription("Assigned to " .. ship.getName())
            if ship.tag == 'Figurine' then
                if ship.getVar("AddToken") ~= nil then
                    ship.call("AddToken", {token=token})
                end
            end
        else
            token.setDescription("Unassigned")
        end
    end,
    function() return  (not token.spawning) end)

end

TokenModule.UnAssignToken = function(token)
    local guid = token.getGUID()
    if (TokenModule.tokenAssignments[guid] ~= nil) and (TokenModule.tokenAssignments[guid].tag == 'Figurine') then
        if TokenModule.tokenAssignments[guid].getVar("RemoveToken") ~= nil then
            TokenModule.tokenAssignments[guid].call("RemoveToken", {token=token})
        end
    end
    TokenModule.tokenAssignments[guid] = nil
    token.setDescription("Unassigned")
end

-- END TOKEN MODULE
--------


function proxyPerformAction(table)
    ship = table[1]
    actionType = table[2]
    playerColor = table[3]
    args = {remove= (table[4] or false)}
    DialModule.PerformAction(ship, actionType, playerColor, args)
end

DialModule = {}
-- Perform an automated action
-- Can be called externally for stuff like range ruler spawning
DialModule.PerformAction = function(ship, type, playerColor, args)
    local tokenActions = ' Focus Calculate Evade Stress Strain Deplete Target Lock Ion Cloak Jam Reinforce Disarm Tractor Dummy '
    announceInfo = {type='action'}
    -- Ruler spawning
    if type:find('ruler') ~= nil then
        local scPos = type:find(':')
        local rulerCode = type:sub(scPos+1,-1)
        RulerModule.ToggleRuler(ship, rulerCode)
        return
    elseif type:find('spawnMoveTemplate') ~= nil then
        if DialModule.DeleteTemplate(ship) == false then
            local scPos = type:find(':')
            local dialCode = type:sub(scPos+1,-1)
            if DialModule.SpawnTemplate(ship, dialCode) ~= nil then
                announceInfo.note = 'spawned a move template'
            else
                announceInfo.note = 'looks at you weird'
            end
        else
            return
        end
    elseif type:find('deleteMoveTemplate') ~= nil then
      DialModule.DeleteTemplate(ship)
      return
    elseif tokenActions:find(' ' .. type .. ' ') ~= nil then
        if args ~= nil and args.remove == true then
            local tokens = ship.call("GetTokens",{type=string.lower(type)})
            local delToken = nil
            for k,token in pairs(tokens) do
                if token.getVar('deleted') == nil then
                    delToken = token
                end
            end
            if delToken == nil then
                announceInfo.note = 'tried to shed a ' .. type .. ' but doesn\'t have any'
            else
                announceInfo.note = 'sheds a ' .. type .. ' token'
                TokenModule.UnAssignToken(delToken)
                delToken.destruct()
            end
        else

            local destinationShip = ship
            if args ~= nil and args.target ~= nil then
                destinationShip = args.target
            end
            local dest = TokenModule.VisiblePosition(type, destinationShip)
            local flipToken = args ~= nil and args.flip == true
            local newToken = TokenModule.TakeToken(type, playerColor, dest, flipToken)

            if type == 'Target Lock' then
                local lockArguments = {lock=newToken, name=ship.getName(), color=playerColor}
                if args ~= nil and args.ship ~= nil and args.target ~= nil then
                    -- The AI system passes in arguments to automatically assign the
                    -- lock. Process these if they've been passed in.
                    lockArguments.ship=args.ship
                    lockArguments.target=args.target
                end
                table.insert(TokenModule.locksToBeSet, lockArguments)
                announceInfo.note = 'acquired a target lock'
                TokenModule.UnAssignToken(newToken) -- Target locks are not assigned to the spawning ship
            elseif type == 'Ion' then
                table.insert(TokenModule.ionsToBeSet, {ion=newToken, ref=ship})
                announceInfo.note = 'takes an ion token'
                TokenModule.AssignToken(newToken, ship)
            elseif type == 'Tractor' then
                table.insert(TokenModule.tractorsToBeSet, {tractor=newToken, ref=ship})
                announceInfo.note = 'takes a tractor token'
                TokenModule.AssignToken(newToken, ship)
            else
                if flipToken == true then
                    table.insert(TokenModule.tokensToBeFlipped, newToken)
                end
                if type == 'Evade' then
                    announceInfo.note = 'takes an evade token'
                else
                    announceInfo.note = 'takes a ' .. string.lower(type) .. ' token'
                end
                TokenModule.AssignToken(newToken, ship)
            end
        end
    end
    AnnModule.Announce(announceInfo, 'all', ship)
end

-- Spawned tempaltes are kept there
-- Entry: {ship=shipRef, template=templateObjRef}
DialModule.SpawnedTemplates = {}

-- Position data for template spawning
-- "Trim" entries are to fine-tune the position
-- (its quite rough by the numbers since their origin was not perfectly at the center)
DialModule.TemplateData = {}
DialModule.TemplateData.straight = {}
DialModule.TemplateData.straight[1] = {0, -2.5, 20, 0}
DialModule.TemplateData.straight[2] = {0, -2.5, 40, 0}
DialModule.TemplateData.straight[3] = {0, -2.5, 60, 0}
DialModule.TemplateData.straight[4] = {0, -2.5, 80, 0}
DialModule.TemplateData.straight[5] = {0, -2.5, 100, 0}
DialModule.TemplateData.bank = {}
DialModule.TemplateData.bank.leftRot = 45
DialModule.TemplateData.bank.trim = { left = {{-2,0,-4,0}, {-5.5,0,-5.2,0}, {-9.3,0,-6.45,0}}, right={{4.2,0,1.2,0}, {7.8,0,-0.3,0}, {11.5,0,-1.4,0}} }
DialModule.TemplateData.bank[1] = {80*(1-math.cos(math.pi/8)), 0, 80*math.sin(math.pi/8), 180}
DialModule.TemplateData.bank[2] = {130*(1-math.cos(math.pi/8)), 0, 130*math.sin(math.pi/8), 180}
DialModule.TemplateData.bank[3] = {180*(1-math.cos(math.pi/8)), 0, 180*math.sin(math.pi/8), 180}
DialModule.TemplateData.bankSlip = {}
DialModule.TemplateData.bankSlip.leftRot = 45
DialModule.TemplateData.bankSlip.trim = { left = {{-2,0,-4,0}, {-5.5,0,-5.2,0}, {-9.3,0,-6.45,0}}, right={{4.2,0,1.2,0}, {7.8,0,-0.3,0}, {11.5,0,-1.4,0}} }
DialModule.TemplateData.bankSlip[1] = {80*(1-math.cos(math.pi/8)), 0, 80*math.sin(math.pi/8), 180}
DialModule.TemplateData.bankSlip[2] = {130*(1-math.cos(math.pi/8)), 0, 130*math.sin(math.pi/8), 180}
DialModule.TemplateData.bankSlip[3] = {180*(1-math.cos(math.pi/8)), 0, 180*math.sin(math.pi/8), 180}
DialModule.TemplateData.turn = {}
DialModule.TemplateData.turn.leftRot = 90
DialModule.TemplateData.turn.trim = { left = {{0,-2.5,0,0}, {-3,-2.5,-3.66,0}, {-4.7,-2.5,-7.5,0}}, right={{0,-2.5,0,0}, {3,-2.5,-4.1,0}, {4.5,-2.5,-7.8,0}} }
DialModule.TemplateData.turn[1] = {35*(1-math.cos(math.pi/4))+2, 0, 35*math.sin(math.pi/4)-2, 180}
DialModule.TemplateData.turn[2] = {62.5*(1-math.cos(math.pi/4))+5, 0, 62.5*math.sin(math.pi/4)-4, 180}
DialModule.TemplateData.turn[3] = {90*(1-math.cos(math.pi/4))+9, 0, 90*math.sin(math.pi/4)-6, 180}
DialModule.TemplateData.talon = {}
DialModule.TemplateData.talon.leftRot = 90
DialModule.TemplateData.talon.trim = { left = {{0,-2.5,0,0}, {-3,-2.5,-3.66,0}, {-4.7,-2.5,-7.5,0}}, right={{0,-2.5,0,0}, {3,-2.5,-4.1,0}, {4.5,-2.5,-7.8,0}} }
DialModule.TemplateData.talon[1] = {35*(1-math.cos(math.pi/4))+2, 0, 35*math.sin(math.pi/4)-2, 180}
DialModule.TemplateData.talon[2] = {62.5*(1-math.cos(math.pi/4))+5, 0, 62.5*math.sin(math.pi/4)-4, 180}
DialModule.TemplateData.talon[3] = {90*(1-math.cos(math.pi/4))+9, 0, 90*math.sin(math.pi/4)-6, 180}

DialModule.TemplateData.baseOffset = {}
DialModule.TemplateData.baseOffset.small = {0, 0, 20, 0}
DialModule.TemplateData.baseOffset.medium = {0, 0, 30, 0}
DialModule.TemplateData.baseOffset.large = {0, 0, 40, 0}

-- Spawn a tempalte on given ship
-- dialCode is move code PLUS identifier if ship already did it or not
-- be3_A means "spawn a bank left 3 template behind me" (A as in after move)
-- tr1_B means "spawn a turn right 1 tempalte in front of me" (B as in before move)
-- Return template reference
-- TODO toggletemplate?
DialModule.SpawnTemplate = function(ship, dialCode)

    local moveCode = dialCode:sub(1, -3)
    local moveInfo = MoveData.DecodeInfo(moveCode, ship)
    --if moveInfo.speed == 0 then
    --    return nil
    --end
    local tempEntry = DialModule.TemplateData[moveInfo.type][moveInfo.speed]
    local baseSize = ship.getTable("Data").Size or 'small'
    tempEntry = Vect.Sum(tempEntry, DialModule.TemplateData.baseOffset[baseSize])
    local ref = ship
    if dialCode:sub(-1,-1) == 'A' then
        ref = MoveModule.GetOldMove(ship, 1)
    end
    --TODO LAST MOVE LOGIC OUT!!!
    --TODO dont barf if no last move
    if moveInfo.dir == 'left' then
        tempEntry = MoveData.LeftVariant(tempEntry)
        tempEntry[4] = tempEntry[4] + 180 - DialModule.TemplateData[moveInfo.type].leftRot
    end
    if moveInfo.extra == 'reverse' then
        tempEntry = MoveData.ReverseVariant(tempEntry)
        if moveInfo.type ~= 'straight' then
            tempEntry[4] = tempEntry[4] - DialModule.TemplateData[moveInfo.type].leftRot
        end
    end
    if moveInfo.dir ~= nil then
        if moveInfo.extra ~= 'reverse' then
            tempEntry = Vect.Sum(tempEntry, DialModule.TemplateData[moveInfo.type].trim[moveInfo.dir][moveInfo.speed])
        else
            if moveInfo.dir == 'right' then
                moveInfo.dir = 'left'
            elseif moveInfo.dir == 'left' then
                moveInfo.dir = 'right'
            end
            tempEntry = Vect.Sum(tempEntry, Vect.ScaleEach(DialModule.TemplateData[moveInfo.type].trim[moveInfo.dir][moveInfo.speed], {-1, 1, -1, -1}))
        end
    end

    local finPos = MoveModule.EntryToPos(tempEntry, ref)
    local src = TokenModule.tokenSources[moveInfo.type:sub(1,1) .. moveInfo.speed]
    local newTemplate = src.takeObject({position=finPos.pos, rotation=finPos.rot})
    newTemplate.lock()
    newTemplate.setPosition(finPos.pos)
    newTemplate.setRotation(finPos.rot)
    table.insert(DialModule.SpawnedTemplates, {template=newTemplate, ship=ship})
    return newTemplate
end

-- Delete template spawned for a ship, return true if deleted, false if there was none
DialModule.DeleteTemplate = function(ship)
    for k,info in pairs(DialModule.SpawnedTemplates) do
        if info.ship == ship then
            if info.template ~= nil then
                info.template.destruct()
            end
            table.remove(DialModule.SpawnedTemplates, k)
            return true
        end
    end
    return false
end



-- Char width table by Indimeco
StringLen = {}
StringLen.charWidthTable = {
        ['`'] = 2381, ['~'] = 2381, ['1'] = 1724, ['!'] = 1493, ['2'] = 2381,
        ['@'] = 4348, ['3'] = 2381, ['#'] = 3030, ['4'] = 2564, ['$'] = 2381,
        ['5'] = 2381, ['%'] = 3846, ['6'] = 2564, ['^'] = 2564, ['7'] = 2174,
        ['&'] = 2777, ['8'] = 2564, ['*'] = 2174, ['9'] = 2564, ['('] = 1724,
        ['0'] = 2564, [')'] = 1724, ['-'] = 1724, ['_'] = 2381, ['='] = 2381,
        ['+'] = 2381, ['q'] = 2564, ['Q'] = 3226, ['w'] = 3704, ['W'] = 4167,
        ['e'] = 2174, ['E'] = 2381, ['r'] = 1724, ['R'] = 2777, ['t'] = 1724,
        ['T'] = 2381, ['y'] = 2564, ['Y'] = 2564, ['u'] = 2564, ['U'] = 3030,
        ['i'] = 1282, ['I'] = 1282, ['o'] = 2381, ['O'] = 3226, ['p'] = 2564,
        ['P'] = 2564, ['['] = 1724, ['{'] = 1724, [']'] = 1724, ['}'] = 1724,
        ['|'] = 1493, ['\\'] = 1923, ['a'] = 2564, ['A'] = 2777, ['s'] = 1923,
        ['S'] = 2381, ['d'] = 2564, ['D'] = 3030, ['f'] = 1724, ['F'] = 2381,
        ['g'] = 2564, ['G'] = 2777, ['h'] = 2564, ['H'] = 3030, ['j'] = 1075,
        ['J'] = 1282, ['k'] = 2381, ['K'] = 2777, ['l'] = 1282, ['L'] = 2174,
        [';'] = 1282, [':'] = 1282, ['\''] = 855, ['"'] = 1724, ['z'] = 1923,
        ['Z'] = 2564, ['x'] = 2381, ['X'] = 2777, ['c'] = 1923, ['C'] = 2564,
        ['v'] = 2564, ['V'] = 2777, ['b'] = 2564, ['B'] = 2564, ['n'] = 2564,
        ['N'] = 3226, ['m'] = 3846, ['M'] = 3846, [','] = 1282, ['<'] = 2174,
        ['.'] = 1282, ['>'] = 2174, ['/'] = 1923, ['?'] = 2174, [' '] = 1282,
        ['avg'] = 2500
    }

-- Get real string length per char table
StringLen.GetStringLength = function(str)
    local len = 0
    for i = 1, #str do
        local c = str:sub(i,i)
        if StringLen.charWidthTable[c] ~= nil then
            len = len + StringLen.charWidthTable[c]
        else
            len = len + StringLen.charWidthTable.avg
        end
    end
    return len
end

-- Get a short name for some ship
-- Avoid user-added LGS
-- Avoid name prepositions as in ambigNames
-- Avoid too short or long names
-- Add a single number/char on the end if there is one on the ship
DialModule.GetShortName = function(ship)
    local shipNameWords = {}
    local numWords = 0
    local ambigNames = 'The Captain Colonel Cartel Lieutenant Commander Old'
    local shipName = ship.getName()
    shipName = shipName:gsub('LGS', '')             -- Delete LGS
    shipName = shipName:match( "^%s*(.-)%s*$" )     -- Trim whitespaces
    -- Fill words table
    for word in shipName:gmatch('[\'\"%-%w]+') do
        table.insert(shipNameWords, word)
    end
    -- Delete first word if ambiguous and there's more
    if ambigNames:find(shipNameWords[1]) ~= nil and #shipNameWords > 1 then
        table.remove(shipNameWords, 1)
    end
    -- Fucntion for checking if "short name"
    local function sizeJustRight(str)
        if str == nil then
            return false
        end
        return ( (str:len() < 10) --[[and (str:len() > 3)]] )
    end
    -- Delete the first word if too short/long and next is better
    if ( not sizeJustRight(shipNameWords[1]) ) and ( sizeJustRight(shipNameWords[2]) ) then
        table.remove(shipNameWords, 1)
    end
    -- Take the resulting first "valid" word
    local shortName = shipNameWords[1]
    -- If there were apostrophes and they are asymmetrical now, trim them
    if ( (string.find('\'\"', shortName:sub(1,1)) ~= nil) or (string.find('\'\"', shortName:sub(-1,-1)) ~= nil) ) and ( shortName:sub(1,1) ~= shortName:sub(-1,-1) ) then
        shortName = shortName:gsub('\'', '')
        shortName = shortName:gsub('\"', '')
    end
    if shipNameWords[#shipNameWords]:len() == 1 then
        shortName = shortName .. ' ' .. shipNameWords[#shipNameWords]
    end
    return shortName
end

-- END AUTO DIALS MODULE
--------

--------
-- RULERS MODULE

-- Since there are many ruler types (models) and commands, this takes carre of all ruler-related handling
-- TO_DO: ActionModule and include it there

RulerModule = {}

-- Table of existing spawned rulers
-- Entry: {ship=shipRef, tuler=rulerRef, type=rulerTypeCode}
RulerModule.spawnedRulers = {}
-- Click function for ruler button (destroy)
function Ruler_SelfDestruct(obj)
    for k, rTable in pairs(RulerModule.spawnedRulers) do
        if rTable.ruler == obj then
            for _, arcline in pairs(rTable.arclines) do
                if arcline ~= nil then
                    arcline.destruct()
                end
            end
            table.remove(RulerModule.spawnedRulers, k)
            break
        end
    end
    obj.destruct()
end
-- Remove appropriate entry if ruler is destroyed
RulerModule.onObjectDestroyed = function(obj)
    for k,info in pairs(RulerModule.spawnedRulers) do
        if info.ship == obj or info.ruler == obj then
            if info.ship == obj then
                info.ruler.destruct()
            end
            for _, arcline in pairs(info.arclines) do
                arcline.destruct()
            end
            table.remove(RulerModule.spawnedRulers, k)
            break
        end
    end
end

-- RULER MESHES DATABASE
RulerModule.meshes = {}
RulerModule.meshes.smallBase = {}
RulerModule.meshes.smallBase.scale = {0.629, 0.629, 0.629}
RulerModule.meshes.smallBase.diffuse = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/arctexture.png'
RulerModule.meshes.smallBase.collider = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/colliders/Small_base_Collider.obj'
RulerModule.meshes.smallBase.front = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/small_front.obj'
RulerModule.meshes.smallBase.fullfront = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/small_fullfront.obj'
RulerModule.meshes.smallBase.rear = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/small_back.obj'
RulerModule.meshes.smallBase.fullback = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/small_fullback.obj'
RulerModule.meshes.smallBase.sideArc = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/small_side_4.obj'
RulerModule.meshes.smallBase.frontback = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/small_frontback.obj'
RulerModule.meshes.smallBase.leftright = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/small_leftright.obj'
RulerModule.meshes.smallBase.bullseye = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/small_bullseye.obj'
RulerModule.meshes.smallBase.range = {}
RulerModule.meshes.smallBase.range[1] = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/small_range_1.obj'
RulerModule.meshes.smallBase.range[2] = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/small_range_2.obj'
RulerModule.meshes.smallBase.range[3] = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/small_range_3.obj'
RulerModule.meshes.smallBase.range[4] = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/small_range_4.obj'


-- Ruler meshes for medium base JC
RulerModule.meshes.mediumBase = {}
RulerModule.meshes.mediumBase.scale = {0.629, 0.629, 0.629}
RulerModule.meshes.mediumBase.diffuse = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/arctexture.png'
RulerModule.meshes.mediumBase.collider = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/colliders/Medium_base_Collider.obj'
RulerModule.meshes.mediumBase.front = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/medium_front.obj'
RulerModule.meshes.mediumBase.fullfront = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/medium_fullfront.obj'
RulerModule.meshes.mediumBase.rear = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/medium_back.obj'
RulerModule.meshes.mediumBase.fullback = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/medium_fullback.obj'
RulerModule.meshes.mediumBase.sideArc = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/medium_side_4.obj'
RulerModule.meshes.mediumBase.frontback = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/medium_frontback.obj'
RulerModule.meshes.mediumBase.leftright = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/medium_leftright.obj'
RulerModule.meshes.mediumBase.bullseye = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/medium_bullseye.obj'
RulerModule.meshes.mediumBase.range = {}
RulerModule.meshes.mediumBase.range[1] = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/medium_range_1.obj'
RulerModule.meshes.mediumBase.range[2] = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/medium_range_2.obj'
RulerModule.meshes.mediumBase.range[3] = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/medium_range_3.obj'
RulerModule.meshes.mediumBase.range[4] = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/medium_range_4.obj'


RulerModule.meshes.largeBase = {}
RulerModule.meshes.largeBase.scale = {0.629, 0.629, 0.629}
RulerModule.meshes.largeBase.diffuse = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/arctexture.png'
RulerModule.meshes.largeBase.collider = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/colliders/Large_base_Collider.obj'
RulerModule.meshes.largeBase.front = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/large_front.obj'
RulerModule.meshes.largeBase.fullfront = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/large_fullfront.obj'
RulerModule.meshes.largeBase.rear = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/large_back.obj'
RulerModule.meshes.largeBase.fullback = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/large_fullback.obj'
RulerModule.meshes.largeBase.sideArc = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/large_side_4.obj'
RulerModule.meshes.largeBase.frontback = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/large_frontback.obj'
RulerModule.meshes.largeBase.leftright = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/large_leftright.obj'
RulerModule.meshes.largeBase.bullseye = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/large_bullseye.obj'
RulerModule.meshes.largeBase.range = {}
RulerModule.meshes.largeBase.range[1] = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/large_range_1.obj'
RulerModule.meshes.largeBase.range[2] = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/large_range_2.obj'
RulerModule.meshes.largeBase.range[3] = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/large_range_3.obj'
RulerModule.meshes.largeBase.range[4] = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/large_range_4.obj'

RulerModule.meshes.hugeBase = {}
RulerModule.meshes.hugeBase.scale = {0.629, 0.629, 0.629}
RulerModule.meshes.hugeBase.diffuse = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/arctexture.png'
RulerModule.meshes.hugeBase.collider = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/colliders/Huge_base_Collider.obj'
RulerModule.meshes.hugeBase.front = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/huge_front.obj'
RulerModule.meshes.hugeBase.fullfront = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/huge_fullfront.obj'
RulerModule.meshes.hugeBase.rear = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/huge_back.obj'
RulerModule.meshes.hugeBase.fullback = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/huge_fullback.obj'
RulerModule.meshes.hugeBase.sideArc = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/huge_side_4.obj'
RulerModule.meshes.hugeBase.frontback = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/huge_frontback.obj'
RulerModule.meshes.hugeBase.leftright = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/huge_leftright.obj'
RulerModule.meshes.hugeBase.bullseye = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/huge_bullseye.obj'
RulerModule.meshes.hugeBase.range = {}
RulerModule.meshes.hugeBase.range[1] = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/huge_range_1.obj'
RulerModule.meshes.hugeBase.range[2] = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/huge_range_2.obj'
RulerModule.meshes.hugeBase.range[3] = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/huge_range_3.obj'
RulerModule.meshes.hugeBase.range[4] = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/huge_range_15.obj'
RulerModule.meshes.hugeBase.range[5] = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/arcranges/new/huge_range_5.obj'


-- Avaialble ruler codes:
-- R            - 1-3 range rings
-- R1/R2/R3     - 1/2/3 range rings
-- A            - contextual arc
-- AA           - full ruler
-- AP           - primary arc
-- AS           - side arc
-- AR           - rear arc
-- AT           - turret arc
-- AM           - mobile arc
XW_cmd.AddCommand('r[1-5]?', 'rulerHandle')     -- Range "rings"
XW_cmd.AddCommand('[fbs][lrfb]?', 'rulerHandle')  -- Rulers with arc lines
XW_cmd.AddCommand('leftright', 'rulerHandle')
XW_cmd.AddCommand('frontback', 'rulerHandle')
XW_cmd.AddCommand('bull', 'rulerHandle')

-- Translate ruler code to a mesh entry
RulerModule.typeToKey = {}
RulerModule.typeToKey.F = 'front'
RulerModule.typeToKey.FF = 'fullfront'
RulerModule.typeToKey.B = 'rear'
RulerModule.typeToKey.FB = 'fullback'
RulerModule.typeToKey.R = 'range'
RulerModule.typeToKey.SL = 'sideArc'
RulerModule.typeToKey.SR = 'sideArc'
RulerModule.typeToKey.FRONTBACK = 'frontback'
RulerModule.typeToKey.LEFTRIGHT = 'leftright'
RulerModule.typeToKey.BULL = 'bullseye'

RulerModule.typeToArc = {}
RulerModule.typeToArc.F = 'front'
RulerModule.typeToArc.FF = 'fullfront'
RulerModule.typeToArc.B = 'back'
RulerModule.typeToArc.FB = 'fullback'
RulerModule.typeToArc.R1 = 'full'
RulerModule.typeToArc.R2 = 'full'
RulerModule.typeToArc.R3 = 'full'
RulerModule.typeToArc.R = 'full'
RulerModule.typeToArc.SL = 'left'
RulerModule.typeToArc.SR = 'right'
RulerModule.typeToArc.FRONTBACK = 'frontback'
RulerModule.typeToArc.LEFTRIGHT = 'leftright'
RulerModule.typeToArc.BULL = 'bullseye'

RulerModule.typeToRange = {}
RulerModule.typeToRange.F = 3
RulerModule.typeToRange.FF = 3
RulerModule.typeToRange.B = 3
RulerModule.typeToRange.FB = 3
RulerModule.typeToRange.R1 = 1
RulerModule.typeToRange.R2 = 2
RulerModule.typeToRange.R3 = 3
RulerModule.typeToRange.R = 3
RulerModule.typeToRange.SL = 3
RulerModule.typeToRange.SR = 3
RulerModule.typeToRange.FRONTBACK = 3
RulerModule.typeToRange.LEFTRIGHT = 3
RulerModule.typeToRange.BULL = 3



-- Get ruler spawn tables for some ship and some ruler code
-- Return table with "mesh", "collider" and "scale" keys
--  (for appropriate ruler)
RulerModule.GetRulerData = function(ship, rulerType)
    local baseSize = ship.getTable("Data").Size or 'small'
    local out = {mesh = nil, collider = nil, scale = nil}
    if rulerType:sub(1,1) == 'R' then
        rKey = tonumber(rulerType:sub(2,2))
        if rKey == nil then
            if baseSize == huge then
                rKey = 6
            else
                rKey = 4
            end

        end
        out.mesh = RulerModule.meshes[baseSize .. 'Base'].range[rKey]
    else
        local key = RulerModule.typeToKey[rulerType]
        out.mesh = RulerModule.meshes[baseSize .. 'Base'][key]
    end
    out.scale = RulerModule.meshes[baseSize .. 'Base'].scale
    out.collider = RulerModule.meshes[baseSize .. 'Base'].collider
    out.diffuse = RulerModule.meshes[baseSize .. 'Base'].diffuse
    out.material = 3
    return out
end

-- Return a descriptive arc name of command (for announcements)
RulerModule.DescriptiveName = function(ship, rulerType)
    if rulerType:sub(1,1) == 'R' then
        ranges = rulerType:sub(2,2)
        if ranges == '' then
            ranges = '1-3'
        end
        return 'range ' .. ranges .. ' ruler'
    else
        if rulerType == 'A' then
            rulerType = rulerType .. RulerModule.DefaultShipArc(ship)
        end
        local arcName = RulerModule.typeToKey[rulerType]
        return arcName .. ' arc ruler'
    end
end

-- Get the default ship arc type code
-- e.g. whip with just primary arc will return code for priamry arc spawn
RulerModule.DefaultShipArc = function(ship)
    return 'A' --Todo Remove this
end

-- Create tables for spawning a ruler
-- Return:  {
--      params      <- table suitable for spawnObject(params) call
--      custom      <- table suitable for obj.setCustomObject(custom) call
--          }
RulerModule.CreateCustomTables = function(ship, rulerType)
    if rulerType == 'A' then
        rulerType = rulerType .. RulerModule.DefaultShipArc(ship)
    end
    local rulerData = RulerModule.GetRulerData(ship, rulerType)
    local paramsTable = {}
    paramsTable.type = 'Custom_Model'
    paramsTable.position = ship.getPosition()
    paramsTable.rotation = {0, ship.getRotation()[2], 0}
    if rulerType == 'SR' then
        rot = ship.getRotation()[2]
        paramsTable.rotation= {0, rot + 180, 0}
    end

    paramsTable.scale = rulerData.scale

    local customTable = {}

    customTable.mesh = rulerData.mesh
    customTable.collider = rulerData.collider
    customTable.diffuse = rulerData.diffuse
    customTable.material = 3
    return {params = paramsTable, custom = customTable}
end

-- Spawn a ruler for a ship
-- Returns new ruler reference
RulerModule.SpawnRuler = function(ship, rulerType, beQuiet)
    local rulerData = RulerModule.CreateCustomTables(ship, rulerType)
    if rulerData.custom.mesh == nil then
        return nil
    end
    local newRuler = spawnObject(rulerData.params)
    newRuler.setCustomObject(rulerData.custom)
    newRuler.setColorTint(color(1.0, 0.0, 0.0, 0.5))

    local arclines = {}
    if RulerModule.typeToArc[rulerType] then
        arclines = CheckArc({ship=ship,arctype=RulerModule.typeToArc[rulerType], range=RulerModule.typeToRange[rulerType]})
    end
    table.insert(RulerModule.spawnedRulers, {ship = ship, ruler = newRuler, arclines = arclines,type = rulerType})
    newRuler.lock()
    newRuler.setScale(rulerData.params.scale)
    local button = {click_function = 'Ruler_SelfDestruct', label = 'DEL', position = {0, 0.55, 0}, rotation =  {0, 0, 0}, width = 1200, height = 1200, font_size = 250}
    newRuler.createButton(button)
    return newRuler
end

-- Delete existing ruler for a ship
-- Return deleted ruler type or nil if there was none
RulerModule.DeleteRuler = function(ship)
    for k,rTable in pairs(RulerModule.spawnedRulers) do
        if rTable.ship == ship then
            for _, arcline in pairs(rTable.arclines) do
                if arcline ~= nil then
                    arcline.destruct()
                end
            end
            rTable.ruler.destruct()
            local destType = rTable.type
            table.remove(RulerModule.spawnedRulers, k)
            return destType
        end
    end
    return nil
end

-- Toggle ruler for a ship
-- If a ruler of queried type exists, just delete it and return nil
-- If any other ruler exists, delete it (and spawn queried one), return new ruler ref
RulerModule.ToggleRuler = function(ship, rulerType, beQuiet)
    local destType = RulerModule.DeleteRuler(ship)
    if destType ~= rulerType then
        if beQuiet ~= true then
            local annInfo = {type='action'}
            annInfo.note = 'spawned a ' .. RulerModule.DescriptiveName(ship, rulerType) .. ' (' .. rulerType .. ')'
            AnnModule.Announce(annInfo, 'all', ship)
        end
        ship.setLock(true)
        Wait.frames(function() RulerModule.SpawnRuler(ship, rulerType, beQuiet) end,1)
    end
end

-- END RULERS MODULE
--------

--------
-- BOMB MODULE

-- Allows for creating "bomb drops" that snap bomb tokens to position

BombModule = {}

-- Delete button for the spawned template
BombModule.deleteButton = {click_function = 'BombDrop_SelfDestruct', label = 'Cancel', position = {0, 0.1, 0}, rotation =  {0, 0, 0}, scale = {0.1, 0.1, 0.1}, width = 2000, height = 900, font_size = 400}
function BombDrop_SelfDestruct(temp)
    BombModule.DeleteDrop(temp)
end

BombModule.dropTable = {}

XW_cmd.AddCommand('b:s[1-5][r]?', 'bombDrop')
XW_cmd.AddCommand('b:b[rle][1-3][r]?', 'bombDrop')
XW_cmd.AddCommand('b:t[rle][1-3][r]?', 'bombDrop')

-- Spawn a bomb drop, delete old ones
-- If that exact one existed, just delete
BombModule.ToggleDrop = function(ship, dropCode)
    if BombModule.DeleteDrop(ship) ~= dropCode then
        BombModule.SpawnDrop(ship, dropCode)
    end
end

-- Create a bomb drop with a template
BombModule.SpawnDrop = function(ship, dropCode)
    local scPos = dropCode:find(':')
    local templateCode = dropCode:sub(scPos+1,-1)
    DialModule.DeleteTemplate(ship)
    local dropPos = nil
    local temp = nil
    if dropCode:sub(-1, -1) == 'r' then
        -- FRONT drops
        temp = DialModule.SpawnTemplate(ship, templateCode:sub(1, -2) .. '_B')
        temp.createButton(BombModule.deleteButton)
        dropPos = MoveModule.GetFinalPosData(templateCode:sub(1, -2), ship, true)
        dropPos.finPos.rot[2] = dropPos.finPos.rot[2] - 180
    else
        -- BACK drops
        temp = DialModule.SpawnTemplate(ship, templateCode .. 'r_B')
        temp.createButton(BombModule.deleteButton)
        dropPos = MoveModule.GetFinalPosData(templateCode .. 'r', ship, true)
    end
    if dropPos == nil or temp == nil then return end
    table.insert(BombModule.dropTable, {ship=ship, temp=temp, code=dropCode, dest=dropPos.finPos})
end

-- Delete existing drop, return deleted code or nil if there was none
BombModule.DeleteDrop = function(temp_ship)
    local newTable = {}
    local deleteCode = nil
    for k,dTable in pairs(BombModule.dropTable) do
        if dTable.ship == temp_ship or dTable.temp == temp_ship then
            deleteCode = dTable.code
            DialModule.DeleteTemplate(dTable.ship)
        else
            table.insert(newTable, dTable)
        end
    end
    BombModule.dropTable = newTable
    return deleteCode
end

-- Delete drops on ship/template delete
BombModule.onObjectDestroyed = function(obj)
    for k,dTable in pairs(BombModule.dropTable) do
        if dTable.ship == obj or dTable.temp == obj then
            BombModule.DeleteDrop(obj)
        end
    end
end

-- Bomb type -> offset data
BombModule.tokenOffset = {}
BombModule.tokenOffset.standardAoE = {pos={0, Convert_mm_igu(-2), Convert_mm_igu(-4.5)}, rot={0, 90, 0}}
BombModule.tokenOffset.prox = {pos={0, Convert_mm_igu(-2), Convert_mm_igu(15)}, rot={0, 90, 0}}
BombModule.tokenOffset.cluster = {pos={0, Convert_mm_igu(-2), 0}, rot={0, 180, 0}}
BombModule.tokenOffset.connor = {pos={0, Convert_mm_igu(-2), Convert_mm_igu(21)}, rot={0, 180, 0}}
BombModule.tokenOffset.rgc = {pos={0, Convert_mm_igu(-1), Convert_mm_igu(9.5)}, rot={0, 0, 0}}

-- Bomb name -> type data
BombModule.snapTable = {}
BombModule.snapTable['Ion Bomb'] = 'standardAoE'
BombModule.snapTable['Proton Bomb'] = 'standardAoE'
BombModule.snapTable['Seismic Charge'] = 'standardAoE'
BombModule.snapTable['Thermal Detonator'] = 'standardAoE'
BombModule.snapTable.Bomblet = 'standardAoE'
BombModule.snapTable['Electro-Proton Bomb'] = 'standardAoE'
BombModule.snapTable['Proximity Mine'] = 'prox'
BombModule.snapTable['Cluster Mine (middle)'] = 'cluster'
BombModule.snapTable['Connor Net'] = 'connor'
BombModule.snapTable['Rigged Cargo Chute debris'] = 'rgc'

-- Minimum distance to snap
BombModule.snapDist = 1.5
-- Snap on drop
BombModule.OnTokenDrop = function(token)
    -- Get the offset data
    local offset = BombModule.tokenOffset[BombModule.snapTable[token.getName()]]

    -- Deduct closest bomb drop point within snap distance
    local closest = {dist=BombModule.snapDist+1, pointKey=nil}
    local tPos = token.getPosition()
    for k,dTable in pairs(BombModule.dropTable) do
        local newDist = Vect.Distance(tPos, dTable.dest.pos)
        if newDist < closest.dist then
            closest.dist = newDist
            closest.pointKey = k
            closest.temp = dTable.temp
        end
    end

    -- If there was one
    if closest.pointKey ~= nil then
        -- Move the token to the snap points
        local drop = BombModule.dropTable[closest.pointKey]
        local destPos = Vect.Sum(drop.dest.pos, Vect.RotateDeg(offset.pos, drop.dest.rot[2]))
        local size = drop.ship.getTable("Data").Size or 'small'
        if size == 'large' then
            destPos = Vect.Sum(destPos, Vect.RotateDeg({0, 0, Convert_mm_igu(-20)}, drop.dest.rot[2]))
        elseif size == 'medium' then
            destPos = Vect.Sum(destPos, Vect.RotateDeg({0, 0, Convert_mm_igu(-10)}, drop.dest.rot[2]))
        end
        local destRot = Vect.Sum(drop.dest.rot, offset.rot)
        destPos[2] = drop.ship.getPosition()[2] + offset.pos[2]
        token.lock()
        token.setPositionSmooth(destPos, false, true)
        token.setRotationSmooth(destRot, false, true)
        XW_cmd.SetBusy(token)
        MoveModule.WaitForResting(token, {pos=destPos, rot=destRot})
        -- Expand clusters
        if token.getName() == 'Cluster Mine (middle)' then
            BombModule.ExpandCluster({pos=destPos, rot=destRot})
        end
        AnnModule.Announce({type='action', note=drop.ship.getName() .. ' dropped a ' .. token.getName():gsub('%(middle%)', 'set')}, 'all')
        closest.temp.destruct()
        return true
    else
        return false
    end
end

-- Spawn side tokens for cluster mine
BombModule.ExpandCluster = function(center)
    local offset = {Convert_mm_igu(43.5), 0, Convert_mm_igu(-1.5)}
    local tParams = {type='Custom_Token'}
    local tCustom = {image='{verifycache}http://i.imgur.com/MqlYZzR.png', thickness=0.1, merge_distance=5}

    local t1 = spawnObject(tParams)
    t1.setCustomObject(tCustom)
    t1.lock()
    local destOffset1 = Vect.RotateDeg(offset, center.rot[2])
    t1.setPosition(Vect.Sum(center.pos, destOffset1))
    t1.setRotation(center.rot)
    t1.setScale({0.4554, 0.4554, 0.4554})
    t1.setName('Cluster Mine (side)')

    local t2 = spawnObject(tParams)
    t2.setCustomObject(tCustom)
    t2.lock()
    local destOffset2 = Vect.RotateDeg(Vect.ScaleEach(offset, {-1, 1, 1}), center.rot[2])
    t2.setPosition(Vect.Sum(center.pos, destOffset2))
    t2.setRotation(center.rot)
    t2.setScale({0.4554, 0.4554, 0.4554})
    t2.setName('Cluster Mine (side)')
end

-- END BOMB MODULE
--------

--------
-- ANNOUNCEMENTS MODULE

-- For writing out stuff in chat

AnnModule = {}

-- COLOR CONFIGURATION FOR ANNOUNCEMENTS
AnnModule.announceColor = {}
AnnModule.announceColor.moveClear = {0.1, 1, 0.1}     -- Green
AnnModule.announceColor.moveCollision = {1, 0.7, 0.1} -- Orange
AnnModule.announceColor.action = {0.3, 0.3, 1}        -- Blue
AnnModule.announceColor.historyHandle = {0.1, 1, 1}   -- Cyan
AnnModule.announceColor.error = {1, 0.15, 0.15}       -- Red
AnnModule.announceColor.warn = {1, 0.4, 0}            -- Red - orange
AnnModule.announceColor.info = {0.8, 0.1, 0.8}        -- Purple

-- Notify color or all players of some event
-- announceInfo: {type=typeOfEvent, note=notificationString}
AnnModule.Announce = function(info, target, shipPrefix)
    local annString = ''
    local annColor = {1, 1, 1}
    local shipName = ''

    if shipPrefix ~= nil then
        if type(shipPrefix) == 'string' then
            shipName = shipPrefix .. ' '
        elseif type(shipPrefix) == 'userdata' then
            shipName = shipPrefix.getName() .. ' '
        end
    end
    if info.type == 'move' or info.type == 'stationary' then
        if info.collidedShip == nil then
            annString = shipName .. info.note .. ' (' .. info.code .. ')'
            annColor = AnnModule.announceColor.moveClear
        else
            annString = shipName .. info.note .. ' (' .. info.code .. ') but is now touching ' .. info.collidedShip.getName()
            annColor = AnnModule.announceColor.moveCollision
        end
    elseif info.type == 'overlap' then
        annString = shipName .. info.note .. ' (' .. info.code .. ') but there was no space to complete the move'
        annColor = AnnModule.announceColor.moveCollision
    elseif info.type == 'historyHandle' then
        annString = shipName .. info.note
        annColor = AnnModule.announceColor.historyHandle
    elseif info.type == 'action' then
        annString = shipName .. info.note
        annColor = AnnModule.announceColor.action
    elseif info.type:find('error') ~= nil then
        annString = shipName .. info.note
        annColor = AnnModule.announceColor.error
    elseif info.type:find('warn') ~= nil then
        annString = shipName .. info.note
        annColor = AnnModule.announceColor.warn
    elseif info.type:find('info') ~= nil then
        annString = shipName .. info.note
        annColor = AnnModule.announceColor.info
    end

    if target == 'all' then
        printToAll(annString, annColor)
    else
        printToColor(target, annString, annColor)
    end
end

-- Record of players that already got note of some ID
-- Key: playerSteamID
-- Value: table of true's on keys of received noteIDs
AnnModule.notifyRecord = {}

-- Print note to playerColor
-- Any further calls with same noteID will not notify same player
-- Print to everyone if playerColor is 'all'
AnnModule.NotifyOnce = function(note, noteID, playerColor)
    if playerColor == 'all' then
        local seatedPlayers = getSeatedPlayers()
        for _,color in pairs(seatedPlayers) do
            AnnModule.NotifyOnce(note, noteID, color)
        end
    else
        local steamID = Player[playerColor].steam_id
        if AnnModule.notifyRecord[steamID] == nil then
            AnnModule.notifyRecord[steamID] = {}
        end
        if AnnModule.notifyRecord[steamID][noteID] ~= true then
            broadcastToColor(note, playerColor, AnnModule.announceColor.info)
            AnnModule.notifyRecord[steamID][noteID] = true
        end
    end
end


-- END ANNOUNCEMENTS MODULE
--------

--------
-- DIRECT TTS EVENT HANDLING
-- Watch for changed descriptions, handle destroyed objects, saving et cetera

-- ~~~~~~
-- CONFIGURATION:

-- How many frames pass between updating watched objects (ships) list
-- It's so we don't go through massive list of all objects on table each frame (why would we?)
updateFrameInterval = 120
-- ~~~~~~

frameCounter = 0
watchedObj = {}

-- This is called each frame
function update()
    -- If there are no watched objects or frame counter passes threshhold
    if watchedObj[1] == nil or frameCounter > updateFrameInterval then
        watchedObj = {}
        -- Reset the list and add every figurine on the table
        for k,obj in pairs(getAllObjects()) do
            if obj ~= nil and obj.tag == 'Figurine' then
                table.insert(watchedObj, obj)
            end
        end
        frameCounter = 0
    end

    -- If description is not blank, try processing it
    for k, obj in pairs(watchedObj) do
        if obj ~= nil and obj.getDescription() ~= '' then
          Wait.frames(
            function()
              XW_cmd.Process(obj, obj.getDescription())
            end
          , 1) -- Waiting a frame to allow Animated Ships to pick up command

        end
    end

    frameCounter = frameCounter + 1
end

-- When something is destroyed, it is called as an argument here (with 1 more frame to live)
function onObjectDestroyed(dying_object)
    for k, obj in pairs(watchedObj) do if dying_object == obj then table.remove(watchedObj, k) end end
    -- Handle history delete and emergency restore saving
    MoveModule.onObjectDestroyed(dying_object)
    -- Handle killing rulers
    RulerModule.onObjectDestroyed(dying_object)
    -- Handle killing bomb drop templates
    BombModule.onObjectDestroyed(dying_object)
    -- Handle killing tokens
    TokenModule.onObjectDestroyed(dying_object)
end

-- Report peeking on dials
function onObjectPeek(object, player_color)
    local token_type = object.getVar("__XW_TokenType")
    if token_type == "helper:Dial" then
        if object.is_face_down == false then
            local owning_player = object.getVar("playerColor")
            if owning_player == nil then
                owning_player = "no one"
            end
            if player_color ~= owning_player then
                printToAll(player_color .. " player attempted to peek on ".. object.getName() .. "s dial, owned by " .. owning_player .. "!!",{1,0,0})
            else
                printToAll(player_color .. " peeked on " .. object.getName() .. "s dial", {0.6, 0.6, 1})
                local set_manouver = object.getVar("setMan")
                if set_manouver == "" then
                    printToColor(object.getName() .. "s dial is not yet set" , player_color, {0.6, 0.6, 1})
                else
                    local info = MoveData.DecodeInfo(set_manouver)
                    local manouver = info.speed
                    -- [koiogran] [segnor] [talon] [reverse] [straight] [forward] [backward] [nil]
                    if info.extra == "koiogran" then
                        manouver = manouver .. " " .. info.extra
                    else
                        manouver = manouver .. " " .. info.type
                    end
                    if info.dir ~= nil then
                        manouver = manouver .. " " .. info.dir
                    end
                    if info.extra and info.extra ~= "koiogran" then
                        manouver = manouver .. " " .. info.extra
                    end
                    printToColor(object.getName() .. "s dial is set to: " .. manouver , player_color, {0.6, 0.6, 1})
                end
            end
        end
    end
end


-- END DIRECT TTS EVENT HANDLING
--------


--------
-- COLLISION CHECKING MODULE
-- Generally checking if two rotated rectangles overlap

-- ~~~~~~
-- CONFIGURATION:

-- How many milimeters should we widen the base from each side
-- With this at zero, sometimes ships overlap after a move
addidionalCollisionMargin_mm = -0.5
-- ~~~~~~

-- General idea here: http://www.gamedev.net/page/resources/_/technical/game-programming/2d-rotated-rectangle-collision-r2604
-- Originally written by Flolania and Hera Verigo, slightly refitted here

-- Return corners of ship base in a {xPos, zPos} table format
-- shipInfo: {ship=shipObjectReference, pos=shipPosition, rot=shipRotation}
function getCorners(shipInfo)
    local corners = {}
    local spos = shipInfo.pos
    local srot = shipInfo.rot[2]
    local baseSize = shipInfo.ship.getTable("Data").Size or 'small'
    local size = Convert_mm_igu((mm_baseSize[baseSize]/2) + addidionalCollisionMargin_mm)
    local world_coords = {}
    world_coords[1] = {spos[1] - size, spos[3] + size}
    world_coords[2] = {spos[1] + size, spos[3] + size}
    world_coords[3] = {spos[1] + size, spos[3] - size}
    world_coords[4] = {spos[1] - size, spos[3] - size}
    for r, corr in ipairs(world_coords) do
        local xcoord = spos[1] + ((corr[1] - spos[1]) * math.sin(math.rad(srot))) - ((corr[2] - spos[3]) * math.cos(math.rad(srot)))
        local ycoord = spos[3] + ((corr[1] - spos[1]) * math.cos(math.rad(srot))) + ((corr[2] - spos[3]) * math.sin(math.rad(srot)))
        corners[r] = {xcoord,ycoord}
    end
    return corners
end

-- Return axes perpendicular to sides of two rectangles
function getAxis(c1,c2)
    local axis = {}
    axis[1] = {c1[2][1]-c1[1][1],c1[2][2]-c1[1][2]}
    axis[2] = {c1[4][1]-c1[1][1],c1[4][2]-c1[1][2]}
    axis[3] = {c2[2][1]-c2[1][1],c2[2][2]-c2[1][2]}
    axis[4] = {c2[4][1]-c2[1][1],c2[4][2]-c2[1][2]}
    return axis
end

function dot2d(p,o)
    return p[1] * o[1] + p[2] * o[2]
end

-- Check if any part of two rectangles overlap
-- Rectangles as in ship bases of a proper size
-- shipInfo: {ship=shipObjectReference, pos=shipPosition, rot=shipRotation}
function collide(shipInfo1, shipInfo2)
    local c2 = getCorners(shipInfo1)
    local c1 = getCorners(shipInfo2)
    local axis = getAxis(c1,c2)
    local scalars = {}
    for i1 = 1, #axis do
        for i2, set in pairs({c1,c2}) do
            scalars[i2] = {}
            for i3, point in pairs(set) do
                table.insert(scalars[i2],dot2d(point,axis[i1]))
            end
        end
        local s1max = math.max(unpack(scalars[1]))
        local s1min = math.min(unpack(scalars[1]))
        local s2max = math.max(unpack(scalars[2]))
        local s2min = math.min(unpack(scalars[2]))
        if s2min > s1max or s2max < s1min then
            return false
        end
    end
    return true
end

-- END COLLISION CHECKING MODULE
--------

-------
-- Local Reference function, for spawning items relative to the quick build card
function LocalPos(object, position)
    local rot = object.getRotation()
    local lPos = {position[1], position[2], position[3]}
    -- Z-X-Y extrinsic
    local zRot = RotMatrix('z', rot.z)
    lPos = RotateVector(zRot, lPos)
    local xRot = RotMatrix('x', rot.x)
    lPos = RotateVector(xRot, lPos)
    local yRot = RotMatrix('y', rot.y)
    lPos = RotateVector(yRot, lPos)

    return Vect_Sum(lPos, object.getPosition())
end

------

function onObjectSpawned(obj)
    obj.hide_when_face_down = false
end

-- Positions for arc indicator tokens around the ship mounts
-- Used so arc indicators can snap to the relevant positions
mountPositions = {
    ['small'] = {
        ['main'] = {0, 0}
    },
    ['medium'] = {
        ['main'] = {0, 0}
    },
    ['large'] = {
        ['main'] = {0, 0}
    },
    ['huge'] = {
        ['front'] = {0, -2.63},
        ['rear'] = {0, 2.63}
    }
}

-- Save and load ship data lua scriptState
saveAndLoadShipStateLua = [[

__XW_Ship = true

function initContextMenu()
    local added_arcs = {}
    for k, arctype in pairs(self.getTable("Data").arcs) do
        if arctype == 'doubleturret' then
            self.addContextMenuItem("FireArc - Left & Right", function(argument) self.setDescription("leftright") end, false)
            self.addContextMenuItem("FireArc - Front & Back", function(argument) self.setDescription("frontback") end, false)
        elseif arctype == 'singleturret' then
            if added_arcs.front == nil then
                self.addContextMenuItem("FireArc - Front", function(argument) self.setDescription("f") end, false)
                added_arcs.front = true
            end
            if added_arcs.back == nil then
                self.addContextMenuItem("FireArc - Back", function(argument) self.setDescription("b") end, false)
                added_arcs.back = true
            end
            if added_arcs.left == nil then
                self.addContextMenuItem("FireArc - Left", function(argument) self.setDescription("sl") end, false)
                added_arcs.left = true
            end
            if added_arcs.right == nil then
                self.addContextMenuItem("FireArc - Right", function(argument) self.setDescription("sr") end, false)
                added_arcs.right = true
            end
        elseif arctype == 'front' then
            if added_arcs.front == nil then
                self.addContextMenuItem("FireArc - Front", function(argument) self.setDescription("f") end, false)
                added_arcs.front = true
            end
        elseif arctype == 'back' then
            if added_arcs.back == nil then
                self.addContextMenuItem("FireArc - Back", function(argument) self.setDescription("b") end, false)
                added_arcs.back = true
            end
        elseif arctype == 'fullfront' then
            self.addContextMenuItem("FireArc - Full Front", function(argument) self.setDescription("ff") end, false)
        elseif arctype == 'bullseye' then
            self.addContextMenuItem("FireArc - Bullseye", function(argument) self.setDescription("bull") end, false)
        elseif arctype == 'left' then
            if added_arcs.left == nil then
                self.addContextMenuItem("FireArc - Left", function(argument) self.setDescription("sl") end, false)
                added_arcs.left = true
            end
        elseif arctype == 'right' then
            if added_arcs.right == nil then
                self.addContextMenuItem("FireArc - Right", function(argument) self.setDescription("sr") end, false)
                added_arcs.right = true
            end
        end
    end

    if Global.getVar('test_AI') then
        self.AddContextMenuItem("AI move and action", function(argument) Global.call("PerformAIManeuver", {['ship']=self, ['take_action']=true}) end, false)
        self.AddContextMenuItem("AI move", function(argument) Global.call("PerformAIManeuver", {['ship']=self, ['take_action']=false}) end, false)
    end
end

assigned_tokens = {}

-- Add token
function AddToken(args)
    assigned_tokens[args.token.getGUID()] = args.token
end

-- Remove token
function RemoveToken(args)
    assigned_tokens[args.token.getGUID()] = nil
end

-- Get Tokens
function GetTokens(args)
    local tokens = {}
    for guid, token in pairs(assigned_tokens) do
        if token == nil then
            assigned_tokens[guid] = nil
        elseif ((args == nil) or (args.type == nil) or (args.type == token.getVar("__XW_TokenType"))) then
            table.insert(tokens, assigned_tokens[guid])
        end
    end
    return tokens
end

assigned_arc_indicators = {}

function AddArcIndicator(args)
    assigned_arc_indicators[args.location] = args.indicator
end

function RemoveArcIndicator(args)
    for location, indicator in pairs(assigned_arc_indicators) do
        if indicator == args.indicator then
            assigned_arc_indicators[location] = nil
            break
        end
    end
end

function GetAvailableMountPositions(args)
    local mount_positions = Global.getTable('mountPositions')[self.getTable("Data").Size]

    for location, _ in pairs(assigned_arc_indicators) do
        mount_positions[location] = nil
    end

    local ship_position = self.getPosition()
    local ship_rotation = math.rad(self.GetRotation().y) * -1
    for location, position in pairs(mount_positions) do
        local transformed_position = {
            ship_position.x + math.cos(ship_rotation) * position[1] - math.sin(ship_rotation) * position[2],
            ship_position.y,
            ship_position.z + math.sin(ship_rotation) * position[1] + math.cos(ship_rotation) * position[2]
        }
        mount_positions[location] = transformed_position
    end

    return mount_positions
end

function GetFixedArcs(args)
    local fixed_arcs = {}
    for _, arc in pairs(self.getTable("Data").arcs) do
        if arc ~= 'doubleturret' and arc ~= 'singleturret' then
            table.insert(fixed_arcs, arc)
        end
    end

    return fixed_arcs
end

function GetAllTurretArcs(args)
    local turret_arcs = {}
    for _, arc_indicator in pairs(assigned_arc_indicators) do
        local new_turret_arcs = arc_indicator.call('getArcs')

        for _, new_arc in pairs(new_turret_arcs) do
            local found = false
            for _, existing_arc in pairs(turret_arcs) do
                if new_arc == existing_arc then
                    found = true
                    break
                end
            end

            if found == false then
                table.insert(turret_arcs, new_arc)
            end
        end
    end

    return turret_arcs
end

function GetAllArcs(args)
    local arcs = GetFixedArcs()
    local turret_arcs = GetAllTurretArcs()

    for _, turret_arc in pairs(turret_arcs) do
        local found = false
        for _, existing_arc in pairs(arcs) do
            if turret_arc == existing_arc then
                found = true
                break
            end
        end

        if found == false then
            table.insert(arcs, turret_arc)
        end
    end

    return arcs
end

function GetAssignedMounts()
    local assigned_mounts = {}
    for mount, _ in pairs(assigned_arc_indicators) do
        table.insert(assigned_mounts, mount)
    end
    return assigned_mounts
end

function GetTurretArcs(args)
    local turret_mount = args.mount or 'main'
    return assigned_arc_indicators[turret_mount].call('getArcs')
end

function GetTurretArc(args)
    local turret_mount = args.mount or 'main'
    return assigned_arc_indicators[turret_mount].call('getArc')
end

function SetTurretArc(args)
    local turret_mount = args.mount or 'main'
    assigned_arc_indicators[turret_mount].call('setArc', {arc=args.arc, snap=args.snap})
end

function GetTurretType(args)
    local turret_mount = args.mount or 'main'
    local arc_indicator_name = assigned_arc_indicators[turret_mount].GetName()
    if arc_indicator_name.find(self.getName(), 'Dual') ~= nil then
        return 'doubleturret'
    else
        return 'singleturret'
    end
end

-- Save self state
function onSave()
    local state = {shipData=self.getTable("Data")}

    state.tokenData = {tokens={},arcs={}}
    for location, indicator in pairs(assigned_arc_indicators) do
        state.tokenData.arcs[location] = indicator.getGUID()
    end
    for guid, _ in pairs(assigned_tokens) do
        table.insert(state.tokenData.tokens, guid)
    end

    return JSON.encode(state)
end

function linkArcIndicators()
    Wait.condition(
        function()
            for location, guid in pairs(arc_indicator_queue) do
                local arc_indicator = getObjectFromGUID(guid)
                assigned_arc_indicators[location] = arc_indicator
                arc_indicator.call('linkToShip', {ship=self})
            end

            arc_indicator_queue = {}
        end,
        function()
            for location, guid in pairs(arc_indicator_queue) do
                local arc_indicator = getObjectFromGUID(guid)
                if arc_indicator == nil or arc_indicator.getVar('loaded') == false then
                    return false
                end
            end

            return true
        end
    )
end

-- Restore self state
arc_indicator_queue = {}
function onLoad(savedData)
    --print("OnLoad: ".. self.getName() .. " " .. savedData)
    if savedData ~= "" and Data == nil then
        local state =  JSON.decode(savedData)
        self.setTable("Data", state.shipData)
        if state.shipData.arcs ~= nil then
            initContextMenu()
        end

        for _, guid in ipairs(state.tokenData.tokens) do
            assigned_tokens[guid] = getObjectFromGUID(guid)
        end

        local any_arcs = false
        for location, guid in pairs(state.tokenData.arcs) do
            any_arcs = true
            break
        end
        if any_arcs then
            arc_indicator_queue = state.tokenData.arcs
            linkArcIndicators()
        end
    end
end
]]


pilotCardScript =
[[
dial = nil
ship = nil
function addTintObject(params)
    if params[1] == "ship" then
      ship = params[2]
    elseif params[1] == "dial" then
      dial = params[2]
    end
end

function onUpdate()
    local tint = self.getColorTint()
    if tint ~= color(1,1,1,1) then
      self.setColorTint(color(1,1,1,1))
      if dial ~= nil then
        dial.setColorTint(tint)
      end

      for i, attachment in pairs(self.getAttachments()) do
        id = self.removeAttachment(attachment.index)
        id.setColorTint(tint)
        self.addAttachment(id)
      end

      if ship ~= nil then
        for i, attachment in pairs(ship.getAttachments()) do
          id = ship.removeAttachment(attachment.index)
          id.setColorTint(tint)
          ship.addAttachment(id)
        end
      end

    end
end

loaded = false

function onLoad(savestate)
  loaded = true
end

function isLoadedAndStill()
  return loaded and self.resting
end
]]

-------
--spawner function, checks for Pilots and Upgrades lists and spawn the respective objects

function newSpawner(listTable)
    --listTable contains :

    --Pilots[x] = table

    --Upgrades[x] = {string1, string2...}
    --spawnCard = Object reference used to position the spawned material
    --Faction = String

    Pilots = listTable.Pilots
    Upgrades = listTable.Upgrades
    spawnCard = listTable.spawnCard
    Faction = listTable.Faction
    Configuration = listTable.Configuration or {}
    local dialSkin = listTable.factionDial
    spawnedPilotList = {}

    PosBag1 = {5, 5, 0}
    PosBag2 = {10, 10, 0}
    PosBag3 = {15, 15, 0}
    PosBag4 = {20, 20, 0}
    PoaBag5 = {25, 25, 0}
    tempBagAcc = getObjectFromGUID('53ad3d').clone({position = PosBag3}) -- Accessories bag
    tempBagShp = getObjectFromGUID('eb5680').clone({position = PosBag4}) -- Ships bag

    --Stablishes lists of available upgrades, pilots, accessories, ships and mobile upgrades
    listaAcc = tempBagAcc.getObjects()
    listaShp = tempBagShp.getObjects()

    --Store the initial position of the Quick Build Card
    storePos = spawnCard.getPosition()
    storeRot = spawnCard.getRotation()


    shipIndex = 1 --Sets index of ship being spawned

    while Pilots[shipIndex] ~= nil do
        --Values used for accessories spawn and layout
        forceValue = 0
        shieldValue = 0
        UpNum = 0
        Turret  = 0
        dualTurret = 0
        Bombs = 0
        hasMob = 0
        bombTokenDescription = ''
        -- Spawn Mobile Upgrades
        for j, Up in ipairs(Upgrades[shipIndex]) do
            if  Up.Config == true then
                finalPos = LocalPos(spawnCard, {-2, 0, 0})      --Layout adjustment
                spawnCard.setPosition(finalPos)
                pos = LocalPos(spawnCard, {1.5, 0, 5.5})
                rot = spawnCard.getRotation()
                rot.y = rot.y
                cardLink = (Up.card)
                cardBackLink = (Up.cardB)
                deck = Decker.Asset(cardLink, cardBackLink)
                card = Decker.Card(deck,1, 1)
                newUp = card:spawn({position = pos, rotation=rot, scale={0.68,0.68,0.68}})
                newUp.setName(Up.name)
                hasMob = 1
            end
        end
        for j, Up in ipairs(Upgrades[shipIndex]) do
            if Up.Config ~= true then                               --Indicates there's a card left of the pilot card, for layout purposes
                pos = LocalPos(spawnCard, {-1.5 - 2*UpNum, 2-0.2*UpNum, 5.5})
                rot = spawnCard.getRotation()
                rot.y = rot.y - 90
                cardLink = (Up.card)
                cardBLink = (Up.cardB)
                deck = Decker.Asset(cardLink, cardBLink)
                card = Decker.Card(deck,1, 1)
                local rotUp = rot
                rotUp.y = rotUp.y+90
                newUp = card:spawn({position = pos, rotation=rotUp, scale={0.68,0.68,0.68}})
                newUp.setName(Up.name)
                if Up.Condition ~= nil then                                            --Checks and spawn conditions associated to pilots
                    for k, acc in ipairs(listaAcc) do
                        if acc.name == Up.Condition then
                            pos = LocalPos(spawnCard, {-2 - 2*UpNum, 2-0.2*UpNum, 8})
                            rot = spawnCard.getRotation()
                            newAsset = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                            assetClone = newAsset.clone()
                            tempBagAcc.putObject(assetClone)
                        end
                    end
                end
                --Checks and spawns Charge Tokens with appropriate layout (up to 4 tokens)
                charges = Up.Charge
                while charges > 0 do
                    for k, acc in ipairs(listaAcc) do
                        if acc.name == 'Charge' then
                            if charges == 5 then
                                pos = LocalPos(spawnCard, {-1.7 - 2*UpNum,0, 1.9})
                                rot = spawnCard.getRotation()
                            elseif charges == 4 then
                                pos = LocalPos(spawnCard, {-1.7 - 2*UpNum,0, 2.8})
                                rot = spawnCard.getRotation()
                            elseif charges == 3 then
                                pos = LocalPos(spawnCard, {-2.6 - 2*UpNum,0, 2.8})
                                rot = spawnCard.getRotation()
                            elseif charges == 2 then
                                pos = LocalPos(spawnCard, {-1.7 - 2*UpNum,0, 3.7})
                                rot = spawnCard.getRotation()
                            elseif charges == 1 then
                                pos = LocalPos(spawnCard, {-2.6 - 2*UpNum,0, 3.7})
                                rot = spawnCard.getRotation()
                            else
                                charges = 0
                            end
                            chargeToken = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                            chargeClone = chargeToken.clone()
                            tempBagAcc.putObject(chargeClone)
                            charges = charges-1
                        end
                    end
                end
                UpNum = UpNum + 1                       --Update number of upgrade being spawned
            end
        end

        --Pilot and Ship Spawn
        pilotName = Pilots[shipIndex].name

        local tint = color(0,0,0,0)
        if Configuration[pilotName] ~= nil then
            tint = Configuration[pilotName].tint or  color(0,0,0,0)
        end
        card = Pilots[shipIndex].card
        cardB = Pilots[shipIndex].cardB
        pos = LocalPos(spawnCard, {0, 3, 5.5})
        rot = spawnCard.getRotation()
        local newPil = nil
        if card ~= '' then
            if cardB ~= nil then
                deck = Decker.Asset(card, cardB)
                card = Decker.Card(deck,1, 1)
                newPil = card:spawn({position = pos, rotation=rot})
                newPil.setName(pilotName)
                newPil.setLuaScript(pilotCardScript)
                newPil.setLock(true)

                -- Spawn Pilot Identifier
                local card = newPil
                local idpos = pos
                local idrot = rot

                pilotIdSpawnFunc = function()
                  local pilotId = spawnObject({
                      type              = "Custom_Model",
                      position          = idpos,
                      rotation          = idrot,
                      scale             = mm_ship_scale,
                      sound             = false,
                      snap_to_grid      = false,
                  })
                  pilotId.setCustomObject({
                      mesh = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/models/cardid.obj',
                      convex = true,
                      material = 1,
                      type = 0
                  })
                  pilotId.setColorTint(tint)
                  card.addAttachment(pilotId)
                  card.setLock(false)
                end
                Wait.condition(pilotIdSpawnFunc , function() return  (not card.spawning) end)

            end
        end
        if pilotName ~= '' then
            for k, acc in ipairs(listaAcc) do
                local card = newPil
                if acc.name == 'Unassigned Dial' then
                    local dialpos = LocalPos(spawnCard, {0, 3, 12})
                    local dialrot = rot
                    local newDial = tempBagAcc.takeObject(
                        {position = dialpos,
                         rotation = dialrot,
                         guid = acc.guid
                       })
                    dialClone = newDial.clone()
                    tempBagAcc.putObject(dialClone)
                    local conditionFunc = function() return (not card.spawning) and (not newDial.spawning) end
                    local executeFunc = function()
                        newDial.setCustomObject({['diffuse']=dialSkin})
                        newDial = newDial.reload()
                        newDial.setColorTint(tint)
                        newDial.setPosition(dialpos)
                        newDial.setRotation(dialrot)
                        card.call('addTintObject', {'dial',newDial})
                      end
                    Wait.condition(executeFunc , conditionFunc)


                end
            end
        end
        forceValue = Pilots[shipIndex].Force --Checks for force value on Pilot and update forceValue
        if Pilots[shipIndex].Condition ~= nil then                                            --Checks and spawn conditions associated to pilots
            for k, acc in ipairs(listaAcc) do
                if acc.name == Pilots[shipIndex].Condition then
                    pos = LocalPos(spawnCard, {-2 - 2*UpNum, 2-0.2*UpNum, 8})
                    rot = spawnCard.getRotation()
                    newAsset = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                    assetClone = newAsset.clone()
                    tempBagAcc.putObject(assetClone)
                end
            end
        end
        local newShip = nil
        pos = LocalPos(spawnCard, {0, 0, 9})
        rot = spawnCard.getRotation()
        for v, ship in ipairs (listaShp) do
            if ship.name == tostring(Pilots[shipIndex].id) then
                newShip = tempBagShp.takeObject({ position = pos,
                                                  rotation = rot,
                                                  guid = ship.guid
                                                })
                shipClone = newShip.clone()
                tempBagShp.putObject(shipClone)
                newShip.setPosition(pos)
                newShip.setRotation(rot)
            end
        end
        if (newShip == nil) and (Pilots[shipIndex].id ~= 0) then
          newShip = spawnObject({
              type              = "Custom_Model",
              position          = pos,
              rotation          = rot,
              scale             = mm_ship_scale,
              sound             = false,
              snap_to_grid      = false,
          })
        end

        if newShip ~= nil then
            local model = nil
            if Configuration[pilotName].model ~= nil then
                model = Configuration[pilotName].model
            elseif Pilots[shipIndex].mesh ~= nil then
                model = '{verifycache}'..Pilots[shipIndex].mesh
            end
            if model then
                newShip.setCustomObject({mesh = model})
            end
            local texture = nil
            if Configuration[pilotName].texture ~= nil then
                texture = Configuration[pilotName].texture
            elseif Pilots[shipIndex].mesh ~= nil then
                texture = '{verifycache}'..Pilots[shipIndex].texture
            end
            if texture then
                newShip.setCustomObject({diffuse = texture})
            end
            if Configuration[pilotName].modeltint ~= nil then
                newShip.setColorTint(Configuration[pilotName].modeltint)
            end
            newShip.setName(pilotName)
            newShip.setCustomObject({
                collider= ShipVerification.colliders[Pilots[shipIndex].Size],
                convex = true,
                material = 1,
                type = 1
            })
            newShip.setLock(true)
            newShip.setTable("Data", Pilots[shipIndex].Data)
            newShip.setLuaScript(saveAndLoadShipStateLua)
            local ship = newShip
            local card = newPil
            local idpos = pos
            local idrot = rot
            local customObj = {
                convex = true,
                material = 1,
                type = 1
            }
            if Pilots[shipIndex].Size == "small" then
                customObj.mesh='{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/models/Base_ID_Marker.obj'
            elseif Pilots[shipIndex].Size == "medium" then
                customObj.mesh='{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/models/Base%20ID%20MED.obj'
            elseif Pilots[shipIndex].Size == "large" then
                customObj.mesh='{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/models/Base%20ID%20LAR.obj'
            elseif Pilots[shipIndex].Size == "huge" then
                customObj.mesh='{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/models/Base_ID_HUGE.obj'
            end
            shipIdSpawnFunc = function()
              local shipId = spawnObject({
                  type              = "Custom_Model",
                  position          = idpos,
                  rotation          = idrot,
                  scale             = mm_ship_scale*0.99,
                  sound             = false,
                  snap_to_grid      = false,
              })
              shipId.setCustomObject(customObj)
              shipId.setColorTint(tint)
              ship.addAttachment(shipId)
              ship.setLock(false)
              card.call('addTintObject', {'ship',ship})
              ship.call('initContextMenu')
            end
            Wait.condition(shipIdSpawnFunc , function() return (not ship.spawning) and (not card.spawning) end)
        end


        if Pilots[shipIndex].Ship == 3 then
            for k, acc in ipairs(listaAcc) do
                if acc.name == 'StarViper Mk.II roll token' then
                    pos = LocalPos(spawnCard, {-1.5, 3, 8.7})
                    svToken = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                    svClone = svToken.clone()
                    tempBagAcc.putObject(svClone)
                end
            end
        end

        if Pilots[shipIndex].Turret ~= nil then       --Checks if upgrade should trigger the dual mobile arc indicator
            if Pilots[shipIndex].Turret == 2 then
                dualTurret = 1
            else
                Turret = 1
            end
        end
        if Turret == 1 and dualTurret == 0 then                                                       --Checks and spawn arc indicator if needed
            for k, acc in ipairs(listaAcc) do
                if acc.name == 'Arc Indicator'..tostring(Faction) then
                    arcInd = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                    indClone = arcInd.clone()
                    tempBagAcc.putObject(indClone)
                    arcInd.setName(string.gsub(arcInd.getName(), Faction, ''))
                    Turret = 0
                end
            end
        elseif dualTurret == 1 then                                               --Checks and spawn dual arc indicator if needed
            for k, acc in ipairs(listaAcc) do
                if acc.name == 'Dual Arc Indicator'..tostring(Faction) then
                    dualArcInd = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                    indClone = dualArcInd.clone()
                    tempBagAcc.putObject(indClone)
                    dualArcInd.setName(string.gsub(dualArcInd.getName(), Faction, ''))
                    dualTurret = 0
                end
            end
        end
        if Pilots[shipIndex].Bomb == true then                                                       --Checks and spawn bomb drop token if needed
            for k, acc in ipairs(listaAcc) do
                if acc.name == 'Bomb drop token (unassigned)' then
                    pos = LocalPos(spawnCard, {-1.5, 3, 8.7})
                    bombDrop = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                    dropClone = bombDrop.clone()
                    tempBagAcc.putObject(dropClone)
                    bombDrop.setDescription(Pilots[shipIndex].bombD)
                end
            end
        end
        if Pilots[shipIndex].Docking == true then
            for k, acc in ipairs(listaAcc) do
                if acc.name == 'Shuttle Launcher (assigned to mothership)' then
                    pos = LocalPos(spawnCard, {-1.5, 3, 8.7})
                    shuttleDrop = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                    dropClone = shuttleDrop.clone()
                    tempBagAcc.putObject(dropClone)
                end
            end
        end
        if Pilots[shipIndex].wingleader == true then
            for k, acc in ipairs(listaAcc) do
                if acc.name == 'Epic Wing Token' then
                    pos = LocalPos(spawnCard, {-1.5, 3, 8.7})
                    wingtoken = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                    wingtokenclone = wingtoken.clone()
                    tempBagAcc.putObject(wingtokenclone)
                end
            end
        end

        if Pilots[shipIndex].Charge ~= nil then   --Checks and spawns Charge Tokens with appropriate layout (up to 4 tokens)
            charges = Pilots[shipIndex].Charge
            while charges > 0 do
                for k, acc in ipairs(listaAcc) do
                    if acc.name == 'Charge' then
                        if charges == 4 then
                            pos = LocalPos(spawnCard, {-0.9 ,0, 0.6})
                            rot = spawnCard.getRotation()
                        elseif charges == 3 then
                            pos = LocalPos(spawnCard, {0.9 ,0, 1.6})
                            rot = spawnCard.getRotation()
                        elseif charges == 2 then
                            pos = LocalPos(spawnCard, {0 ,0, 1.6})
                            rot = spawnCard.getRotation()
                        elseif charges == 1 then
                            pos = LocalPos(spawnCard, {-0.9 ,0, 1.6})
                            rot = spawnCard.getRotation()
                        else
                            charges = 0
                        end
                        chargeToken = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                        chargeClone = chargeToken.clone()
                        tempBagAcc.putObject(chargeClone)
                        charges = charges-1
                    end
                end
            end
        end
        if Pilots[shipIndex].id ==0 then
            if Pilots[shipIndex].Turret ~= nil then       --Checks if upgrade should trigger the dual mobile arc indicator
                if Pilots[shipIndex].Turret == 2 then
                    dualTurret = 1
                else
                    Turret = 1
                end
            end
            if Turret == 1 and dualTurret == 0 then                                                       --Checks and spawn arc indicator if needed
                for k, acc in ipairs(listaAcc) do
                    if acc.name == 'Arc Indicator'..tostring(Faction) then
                        arcInd = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                        indClone = arcInd.clone()
                        tempBagAcc.putObject(indClone)
                        arcInd.setName(string.gsub(arcInd.getName(), Faction, ''))
                        Turret = 0
                    end
                end
            elseif dualTurret == 1 then                                               --Checks and spawn dual arc indicator if needed
                for k, acc in ipairs(listaAcc) do
                    if acc.name == 'Dual Arc Indicator'..tostring(Faction) then
                        dualArcInd = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                        indClone = dualArcInd.clone()
                        tempBagAcc.putObject(indClone)
                        dualArcInd.setName(string.gsub(dualArcInd.getName(), Faction, ''))
                        dualTurret = 0
                    end
                end
            end
            if Pilots[shipIndex].Bomb == true then                                                       --Checks and spawn bomb drop token if needed
                for k, acc in ipairs(listaAcc) do
                    if acc.name == 'Bomb drop token (unassigned)' then
                        pos = LocalPos(spawnCard, {-1.5, 3, 8.7})
                        bombDrop = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                        dropClone = bombDrop.clone()
                        tempBagAcc.putObject(dropClone)
                        bombDrop.setDescription(Pilots[shipIndex].bombD)
                    end
                end
            end
        end
        while Pilots[shipIndex].Force > 0 do
            for k, acc in ipairs(listaAcc) do
                if acc.name == 'Force' then
                    Pilots[shipIndex].Force = Pilots[shipIndex].Force - 1
                    if hasMob == 1 then                 --adjusts layout if Mobile Upgrade is present
                        pos = LocalPos(spawnCard, {1.7 + 0.9*Pilots[shipIndex].Force, 0, 3.7})
                        rot = spawnCard.getRotation()
                        if forceValue >2 then
                            pos = LocalPos(spawnCard, {1.7 + 0.9*(Pilots[shipIndex].Force-2), 0, 2.8})
                        end
                    else
                        pos = LocalPos(spawnCard, {1.7, 0, 3.7 + 0.9*Pilots[shipIndex].Force})
                        rot = spawnCard.getRotation()
                    end
                    forceToken = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                    forceClone = forceToken.clone()
                    tempBagAcc.putObject(forceClone)
                end
            end
        end
        --Spawns Shields
        while Pilots[shipIndex].Shield > 0 do                                        --spawn shield tokens, layout good for up to 9 shields
            for k, shd in ipairs(listaAcc) do
                if shd.name == 'Shield' then
                    Pilots[shipIndex].Shield = Pilots[shipIndex].Shield - 1
                    pos = LocalPos(spawnCard, { -0.9 + 0.9*Pilots[shipIndex].Shield, 0, 3.4})
                    rot = spawnCard.getRotation()
                    if Pilots[shipIndex].Shield >5  then
                        pos = LocalPos(spawnCard, {-0.9 + 0.9*(Pilots[shipIndex].Shield-6), 0, 1.6})
                    elseif Pilots[shipIndex].Shield >2 then
                        pos = LocalPos(spawnCard, {-0.9 + 0.9*(Pilots[shipIndex].Shield-3), 0, 2.5})
                    end
                    shieldToken = tempBagAcc.takeObject({position = pos, rotation = rot, guid = shd.guid})
                    shieldClone = shieldToken.clone()
                    tempBagAcc.putObject(shieldClone)
                end
            end
        end




        finalPos = LocalPos(spawnCard, {-4 - 2*UpNum, 0, 0})
        spawnCard.setPosition(finalPos)
        shipIndex = shipIndex + 1
        -- Delete cloned bags
        tempBagAcc.destruct()
        tempBagShp.destruct()
    end

    if listTable.Obstacles ~= nil then
        tempObstacleBag = getObjectFromGUID('203cb8').clone({position = PosBag3}) -- Obstacles bag
        obstacleAcc = tempObstacleBag.getObjects()
        for i, obstacleName in ipairs(listTable.Obstacles) do
            local found = false
            for j, obstacle in ipairs(obstacleAcc) do
                if obstacle.name == obstacleName then
                    print("Found obstacle: " .. obstacle.name .. " - " .. obstacleName)
                    pos =  LocalPos(spawnCard, {0, 3, 5.5})
                    rot = spawnCard.getRotation()
                    obstacleToken = tempObstacleBag.takeObject({position = pos, rotation = rot, guid = obstacle.guid})
                    obstacleClone = obstacleToken.clone()
                    tempObstacleBag.putObject(obstacleClone)
                    found = true
                    break
                end
            end
            if not found then
                print("Couldnt find obstacle: " .. obstacleName)
            else
                finalPos = LocalPos(spawnCard, {-4, 0, 0})
                spawnCard.setPosition(finalPos)
            end
        end
        tempObstacleBag.destruct()
    end

    --returns Quick Build Card to initial position
    spawnCard.setPosition(storePos)
    spawnCard.setRotation(storeRot)
end



function RotMatrix(axis, angDeg)
    local ang = math.rad(angDeg)
    local cs = math.cos
    local sn = math.sin

    if axis == 'x' then
        return {
                    { 1,        0,             0 },
                    { 0,   cs(ang),   -1*sn(ang) },
                    { 0,   sn(ang),      cs(ang) }
               }
    elseif axis == 'y' then
        return {
                    {    cs(ang),   0,   sn(ang) },
                    {          0,   1,         0 },
                    { -1*sn(ang),   0,   cs(ang) }
               }
    elseif axis == 'z' then
        return {
                    { cs(ang),   -1*sn(ang),   0 },
                    { sn(ang),      cs(ang),   0 },
                    { 0,                  0,   1 }
               }
    end
end

-- Apply given rotation matrix on given vector
-- (multiply matrix and column vector)
function RotateVector(rotMat, vect)
    local out = {0, 0, 0}
    for i=1,3,1 do
        for j=1,3,1 do
            out[i] = out[i] + rotMat[i][j]*vect[j]
        end
    end
    return out
end

-- Sum of two vectors (of any size)
function Vect_Sum(vec1, vec2)
    local out = {}
    local k = 1
    while vec1[k] ~= nil and vec2[k] ~= nil do
        out[k] = vec1[k] + vec2[k]
        k = k+1
    end
    return out
end

--Decker module

do
    Decker = {}

    -- provide unique ID starting from 20 for present decks
    local nextID
    do
        local _nextID = 20
        nextID = function()
            _nextID = _nextID + 1
            return tostring(_nextID)
        end
    end

    -- Asset signature (equality comparison)
    local function assetSignature(assetData)
        return table.concat({
            assetData.FaceURL,
            assetData.BackURL,
            assetData.NumWidth,
            assetData.NumHeight,
            assetData.BackIsHidden and 'hb' or '',
            assetData.UniqueBack and 'ub' or ''
        })
    end
    -- Asset ID storage to avoid new ones for identical assets
    local idLookup = {}
    local function assetID(assetData)
        local sig = assetSignature(assetData)
        local key = idLookup[sig]
        if not key then
            key = nextID()
            idLookup[sig] = key
        end
        return key
    end

    local assetMeta = {
        deck = function(self, cardNum, options)
            return Decker.AssetDeck(self, cardNum, options)
        end
    }
    assetMeta = {__index = assetMeta}

    -- Create a new CustomDeck asset
    function Decker.Asset(face, back, options)
        local asset = {}
        options = options or {}
        asset.data = {
            FaceURL = face or error('Decker.Asset: faceImg link required'),
            BackURL = back or error('Decker.Asset: backImg link required'),
            NumWidth = options.width or 1,
            NumHeight = options.height or 1,
            BackIsHidden = options.hiddenBack or false,
            UniqueBack = options.uniqueBack or false
        }
        -- Reuse ID if asset existing
        asset.id = assetID(asset.data)
        return setmetatable(asset, assetMeta)
    end

    function Decker.AssetFromData(assetData)
        return setmetatable({data = assetData, id = assetID(assetData)}, assetMeta)
    end

    -- Create a base for JSON objects
    function Decker.BaseObject()
        return {
            Name = 'Base',
            Transform = {
                posX = 0, posY = 5, posZ = 0,
                rotX = 0, rotY = 0, rotZ = 0,
                scaleX = 1, scaleY = 1, scaleZ = 1
            },
            Nickname = '',
            Description = '',
            ColorDiffuse = { r = 1, g = 1, b = 1 },
            Locked = false,
            Grid = true,
            Snap = true,
            Autoraise = true,
            Sticky = true,
            Tooltip = true,
            GridProjection = false,
            Hands = false,
            XmlUI = '',
            LuaScript = '',
            LuaScriptState = '',
            GUID = 'deadbf'
        }
    end
    -- Apply some basic parameters on base JSON object
    function Decker.SetCommonOptions(obj, options)
        options = options or {}
        obj.Nickname = options.name or ''
        obj.Description = options.desc or ''
        obj.LuaScript = options.script or ''
        obj.XmlUI = options.xmlui or ''
        obj.LuaScriptState = options.scriptState or ''
        obj.Locked = options.locked or false
        obj.Tooltip = options.tooltip or true
        obj.GUID = options.guid or 'deadbf'
    end
    -- default spawnObjectJSON params since it doesn't like blank fields
    local function defaultParams(params, json)
        params = params or {}
        params.json = json
        params.position = params.position or {0, 5, 0}
        params.rotation = params.rotation or {0, 0, 0}
        params.scale = params.scale or {1, 1, 1}
        if params.sound == nil then
            params.sound = true
        end
        return params
    end

    -- For copy method
    local deepcopy
    deepcopy = function(t)
        local copy = {}
        for k,v in pairs(t) do
           if type(v) == 'table' then
               copy[k] = deepcopy(v)
           else
               copy[k] = v
           end
        end
        return copy
    end
    -- meta for all Decker derived objects
    local commonMeta = {
        -- return object JSON string, used cached if present
        _cache = function(self)
            if not self.json then
                self.json = JSON.encode(self.data)
            end
            return self.json
        end,
        -- invalidate JSON string cache
        _recache = function(self)
            self.json = nil
            return self
        end,
        spawn = function(self, params)
            params = defaultParams(params, self:_cache())
            return spawnObjectJSON(params)
        end,
        copy = function(self)
            return setmetatable(deepcopy(self), getmetatable(self))
        end,
        setCommon = function(self, options)
            Decker.SetCommonOptions(self.data, options)
            return self
        end,
    }
    -- apply common part on a specific metatable
    local function customMeta(mt)
        for k,v in pairs(commonMeta) do
            mt[k] = v
        end
        mt.__index = mt
        return mt
    end

    -- DeckerCard metatable
    local cardMeta = {
        setAsset = function(self, asset)
            local cardIndex = self.data.CardID:sub(-2, -1)
            self.data.CardID = asset.id .. cardIndex
            self.data.CustomDeck = {[asset.id] = asset.data}
            return self:_recache()
        end,
        getAsset = function(self)
            local deckID = next(self.data.CustomDeck)
            return Decker.AssetFromData(self.data.CustomDeck[deckID])
        end,
        -- reset deck ID to a consistent value script-wise
        _recheckDeckID = function(self)
            local oldID = next(self.data.CustomDeck)
            local correctID = assetID(self.data.CustomDeck[oldID])
            if oldID ~= correctID then
                local cardIndex = self.data.CardID:sub(-2, -1)
                self.data.CardID = correctID .. cardIndex
                self.data.CustomDeck[correctID] = self.data.CustomDeck[oldID]
                self.data.CustomDeck[oldID] = nil
            end
            return self
        end
    }
    cardMeta = customMeta(cardMeta)
    -- Create a DeckerCard from an asset
    function Decker.Card(asset, row, col, options)
        options = options or {}
        local card = Decker.BaseObject()
        card.Name = 'Card'
        -- optional custom fields
        Decker.SetCommonOptions(card, options)
        if options.sideways ~= nil then
            card.SidewaysCard = options.sideways
        end
        -- CardID string is parent deck ID concat with its 0-based index (always two digits)
        local num = (row-1)*asset.data.NumWidth + col - 1
        num = string.format('%02d', num)
        card.CardID = asset.id .. num
        -- just the parent asset reference needed
        card.CustomDeck = {[asset.id] = asset.data}

        local obj = setmetatable({data = card}, cardMeta)
        obj:_cache()
        return obj
    end


    -- DeckerDeck meta
    local deckMeta = {
        count = function(self)
            return #self.data.DeckIDs
        end,
        -- Transform index into positive
        index = function(self, ind)
            if ind < 0 then
                return self:count() + ind + 1
            else
                return ind
            end
        end,
        swap = function(self, i1, i2)
            local ri1, ri2 = self:index(i1), self:index(i2)
            assert(ri1 > 0 and ri1 <= self:count(), 'DeckObj.rearrange: index ' .. i1 .. ' out of bounds')
            assert(ri2 > 0 and ri2 <= self:count(), 'DeckObj.rearrange: index ' .. i2 .. ' out of bounds')
            self.data.DeckIDs[ri1], self.data.DeckIDs[ri2] = self.data.DeckIDs[ri2], self.data.DeckIDs[ri1]
            local co = self.data.ContainedObjects
            co[ri1], co[ri2] = co[ri2], co[ri1]
            return self:_recache()
        end,
        -- rebuild self.data.CustomDeck based on contained cards
        _rescanDeckIDs = function(self, id)
            local cardIDs = {}
            for k,card in ipairs(self.data.ContainedObjects) do
                local cardID = next(card.CustomDeck)
                if not cardIDs[cardID] then
                    cardIDs[cardID] = card.CustomDeck[cardID]
                end
            end
            --[[
            for id,data in pairs(cardIDs) do
                self.data.CustomDeck[id] = data
            end
            for id,data in pairs(self.data.CustomDeck) do
                if not cardIDs[id] then
                    self.data.CustomDeck[id] = nil
                end
            end
            ]]--
            -- eeh, GC gotta earn its keep as well
            self.data.CustomDeck = cardIDs
        end,
        remove = function(self, ind, skipRescan)
            local rind = self:index(ind)
            assert(rind > 0 and rind <= self:count(), 'DeckObj.remove: index ' .. ind .. ' out of bounds')
            local card = self.data.ContainedObjects[rind]
            table.remove(self.data.DeckIDs, rind)
            table.remove(self.data.ContainedObjects, rind)
            if not skipRescan then
                self:_rescanDeckIDs(next(card.CustomDeck))
            end
            return self:_recache()
        end,
        removeMany = function(self, ...)
            local indices = {...}
            table.sort(indices, function(e1,e2) return self:index(e1) > self:index(e2) end)
            for _,ind in ipairs(indices) do
                self:remove(ind, true)
            end
            self:_rescanDeckIDs()
            return self:_recache()
        end,
        insert = function(self, card, ind)
            local rind = self:index(ind)
            assert(rind > 0 and rind <= (self:count()+1), 'DeckObj.insert: index ' .. ind .. ' out of bounds')
            table.insert(self.data.DeckIDs, rind, card.data.CardID)
            table.insert(self.data.ContainedObjects, rind, card.data)
            local id = next(card.data.CustomDeck)
            if not self.data.CustomDeck[id] then
                self.data.CustomDeck[id] = card.data.CustomDeck[id]
            end
            return self:_recache()
        end,
        reverse = function(self)
            local s,e = 1, self:count()
            while s < e do
                self:swap(s, e)
                s = s+1
                e = e-1
            end
            return self:_recache()
        end,
        cardAt = function(self, ind)
            local rind = self:index(ind)
            assert(rind > 0 and rind <= (self:count()+1), 'DeckObj.insert: index ' .. ind .. ' out of bounds')
            local card = setmetatable({data = deepcopy(self.data.ContainedObjects[rind])}, cardMeta)
            card:_cache()
            return card
        end,
        switchAssets = function(self, replaceTable)
            -- destructure replace table into
            -- [ID_to_replace] -> [ID_to_replace_with]
            -- [new_asset_ID] -> [new_asset_data]
            local idReplace = {}
            local assets = {}
            for oldAsset, newAsset in pairs(replaceTable) do
                assets[newAsset.id] = newAsset.data
                idReplace[oldAsset.id] = newAsset.id
            end
            -- update deckIDs
            for k,cardID in ipairs(self.data.DeckIDs) do
                local deckID, cardInd = cardID:sub(1, -3), cardID:sub(-2, -1)
                if idReplace[deckID] then
                    self.data.DeckIDs[k] = idReplace[deckID] .. cardInd
                end
            end
            -- update CustomDeck data - nil replaced
            for replacedID in pairs(idReplace) do
                if self.data.CustomDeck[replacedID] then
                    self.data.CustomDeck[replacedID] = nil
                end
            end
            -- update CustomDeck data - add replacing
            for _,replacingID in pairs(idReplace) do
                self.data.CustomDeck[replacingID] = assets[replacingID]
            end
            -- update card data
            for k,cardData in ipairs(self.data.ContainedObjects) do
                local deckID = next(cardData.CustomDeck)
                if idReplace[deckID] then
                    cardData.CustomDeck[deckID] = nil
                    cardData.CustomDeck[idReplace[deckID]] = assets[idReplace[deckID]]
                end
            end
            return self:_recache()
        end,
        getAssets = function(self)
            local assets = {}
            for id,assetData in pairs(self.data.CustomDeck) do
                assets[#assets+1] = Decker.AssetFromData(assetData)
            end
            return assets
        end
    }
    deckMeta = customMeta(deckMeta)
    -- Create DeckerDeck object from DeckerCards
    function Decker.Deck(cards, options)
        local deck = Decker.BaseObject()
        deck.Name = 'Deck'
        Decker.SetCommonOptions(deck, options)
        deck.DeckIDs = {}
        deck.CustomDeck = {}
        deck.ContainedObjects = {}
        for _,card in ipairs(cards) do
            deck.DeckIDs[#deck.DeckIDs+1] = card.data.CardID
            local id = next(card.data.CustomDeck)
            if not deck.CustomDeck[id] then
                deck.CustomDeck[id] = card.data.CustomDeck[id]
            end
            deck.ContainedObjects[#deck.ContainedObjects+1] = card.data
        end

        local obj = setmetatable({data = deck}, deckMeta)
        obj:_cache()
        return obj
    end
    -- Create DeckerDeck from an asset using X cards on its sheet
    function Decker.AssetDeck(asset, cardNum, options)
        cardNum = cardNum or asset.data.NumWidth * asset.data.NumHeight
        local row, col, width = 1, 1, asset.data.NumWidth
        local cards = {}
        for k=1,cardNum do
            cards[#cards+1] = Decker.Card(asset, row, col)
            col = col+1
            if col > width then
                row, col = row+1, 1
            end
        end
        return Decker.Deck(cards, options)
    end
end

-- for use with Epic Wing Tool to check if the landing space is empty
function epicMoveWingmate(table)
    local ship = table[1]
    local desiredPosRot = {pos=table[2], rot=table[3]}
    print("Ship size=" .. ship.getTable("Data").Size)
    local info = {size=ship.getTable("Data").Size, code="dummy", type=""}
    local fullFunc = function(info,ship) return desiredPosRot end
    result = MoveModule.MoveProbe.TryFullMove(info, ship, fullFunc)
    if result.done then
      MoveModule.MoveShip(ship, {finPos=desiredPosRot})
      return true
    else
      -- Todo announce some stuff
      return false
    end
end
