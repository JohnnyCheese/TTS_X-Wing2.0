-- ~~~~~~
-- Script by dzikakulka
-- Issues, history at: http://github.com/tjakubo2/TTS_xwing
--
-- Based on a work of: Flolania, Hera Vertigo
-- ~~~~~~

-- ~~~~~~
-- Code contributions
--  - Characted width data: Indimeco
--  - http://github.com/Indimeco/Tabletop-Simulator-Misc
-- ~~~~~~

-- Should the code execute print functions or skip them?
-- This should be set to false on every release
print_debug = true

TTS_print = print
function print(...)
    if print_debug == true then
        TTS_print(table.unpack({...}))
    end
end

-- Vector manipulation
#include TTS_lib/Vector/Vector

-- Standard libraries extentions
#include TTS_lib/Util/Util

-- Standard event handling
#include TTS_lib/EventSub/EventSub

-- Object type abstraction
#include TTS_lib/ObjType/ObjType


-- Save/load management
#include TTS_lib/SaveManager/SaveManager

-- Component sizes, unit conversion methods
#include TTS_xwing/src/Dimensions

-- AI behaviour sets
#include TTS_xwing/src/BehaviourDB


-- Modules API, must be loaded last
#include TTS_xwing/src/API

--------
-- MISC FUNCTIONS

-- Dumbest TTS issue ever workaround
function TTS_Serialize(pos)
    return {pos[1], pos[2], pos[3]}
end

ObjType.AddType('ship', function(obj)
    return (obj.tag == 'Figurine')
end)
ObjType.AddType('token', function(obj)
    return (obj.tag == 'Chip' or obj.tag == 'Coin' or (obj.getVar('__XW_Token') and obj.getVar('__XW_TokenIdle')))
end)
ObjType.AddType('dial', function(obj)
    return (obj.tag == 'Card' and XW_cmd.CheckCommand(obj.getDescription()) == 'move')
end)


-- Dud function for info buttons and not yet written sections where Lua complains about no code
function dummy() return end

-- END MISC FUNCTIONS
--------


--------
-- COMMAND HANDLING MODULE
-- Sanitizes input (more like ignores anything not explicitly allowed)
-- Allows other modules to add available commands and passes their execution where they belong

XW_cmd = {}
XW_cmd.commandLUT = {}

-- Table of valid commands: their patterns and general types
XW_cmd.ValidCommands = {}

-- Add given regen expression as a valid command for processing
XW_cmd.AddCommand = function(cmdRegex, type)
    -- When adding available commands, assert beggining and end of string automatically
    if cmdRegex:sub(1,1) ~= '^' then cmdRegex = '^' .. cmdRegex end
    if cmdRegex:sub(-1,-1) ~= '$' then cmdRegex = cmdRegex .. '$' end
    table.insert(XW_cmd.ValidCommands, {string.lower(cmdRegex), type})
end

-- Check if command is registered as valid
-- If it is return its type identifier, if not return nil
XW_cmd.CheckCommand = function(cmd)
    -- Trim whitespaces
    cmd = string.lower(cmd:match( "^%s*(.-)%s*$" ))
    local type = nil
    if XW_cmd.commandLUT[cmd] then
        return XW_cmd.commandLUT[cmd]
    end
    -- Resolve command type
    for k,pat in pairs(XW_cmd.ValidCommands) do
        if cmd:match(pat[1]) ~= nil then
            type = pat[2]
            break
        end
    end
    XW_cmd.commandLUT[cmd] = type
    return type
end

-- (special function)
-- Purge all save data (everything that goes to onSave)
XW_cmd.AddCommand('purgeSave', 'special')
XW_cmd.PurgeSave = function()
    MoveModule.moveHistory = {}
end

-- (special function)
-- Print ship hitory
XW_cmd.AddCommand('hist', 'special')
XW_cmd.ShowHist = function(ship)
    MoveModule.PrintHistory(ship)
end

-- (special function)
-- Check for typical issues with a ship
XW_cmd.AddCommand('diag', 'special')
XW_cmd.Diagnose = function(ship)
    -- Check and unlock XW_cmd lock if it's on
    local issueFound = false
    if ObjType.IsOfType(ship, 'ship') ~= true then return end
    if XW_cmd.isReady(ship) ~= true then
        XW_cmd.SetReady(ship)
        printToAll(ship.getName() .. '\'s deadlock resolved', {0.1, 0.1, 1})
        issueFound = true
    end
    -- Delete lingering buttons
    if ship.getButtons() ~= nil then
        ship.clearButtons()
        printToAll(ship.getName() .. '\'s lingering buttons deleted', {0.1, 0.1, 1})
        issueFound = true
    end
    -- If ship has unrecognized model and said that before, remind
    if ship.getVar('missingModelWarned') == true then
        printToAll('I hope you do remember that I told you about ' .. ship.getName() .. '\'s model being unrecognized when it was first moved/used', {0.1, 0.1, 1})
        issueFound = true
    end
    -- No issues found
    if issueFound ~= true then
        printToAll(ship.getName() .. ' looks OK', {0.1, 1, 0.1})
    end
end

-- Process provided command on a provided object
-- Return true if command has been executed/started
-- Return false if object cannot process commands right now or command was invalid
XW_cmd.Process = function(obj, cmd)

    -- Trim whitespaces
    cmd = cmd:match( "^%s*(.-)%s*$" )

    -- Resolve command type
    local type = XW_cmd.CheckCommand(cmd)

    -- Process special commands without taking lock into consideration
    if type == nil then
        return false
    elseif type == 'special' then
        if cmd == 'diag' then
            XW_cmd.Diagnose(obj)
        elseif cmd == 'purgeSave' then
            XW_cmd.PurgeSave()
        elseif cmd == 'hist' then
            XW_cmd.ShowHist(obj)
        end
    end

    -- Return if not ready, else process
    if XW_cmd.isReady(obj) ~= true then
        return false
    end

    if type == 'demoMove' then
        MoveModule.DemoMove(cmd:sub(3, -1), obj)
    elseif type == 'move' or type == 'actionMove' then
        local info = MoveData.DecodeInfo(cmd, obj)
        MoveModule.PerformMove(cmd, obj)
    elseif type == 'historyHandle' then
        if cmd == 'q' or cmd == 'undo' then
            MoveModule.UndoMove(obj)
        elseif cmd == 'z' or cmd == 'redo' then
            MoveModule.RedoMove(obj)
        elseif cmd == 'keep' then
            MoveModule.SaveStateToHistory(obj, false)
        elseif cmd:sub(1,8) == 'restore#' then
            local keyNum = tonumber(cmd:sub(9, -1))
            MoveModule.Restore(obj, keyNum)
        end
    elseif type == 'dialHandle' then
        if cmd == 'sd' then
            DialModule.SaveNearby(obj)
        elseif cmd == 'rd' then
            DialModule.RemoveSet(obj)
        end
    elseif type == 'rulerHandle' then
        RulerModule.ToggleRuler(obj, string.upper(cmd))
    elseif type == 'action' then
        DialModule.PerformAction(obj, cmd)
    elseif type == 'bombDrop' then
        BombModule.ToggleDrop(obj, cmd)
    end
    obj.setDescription('')
    return true
end

-- Is object not processing some commands right now?
XW_cmd.isReady = function(obj)
    return (obj.getVar('cmdBusy') ~= true)
end

-- Flag the object as processing commands to ignore any in the meantime
XW_cmd.SetBusy = function(obj)
    if XW_cmd.isReady(obj) ~= true then
        print('Nested process on ' .. obj.getName())
    end
    obj.setVar('cmdBusy', true)
end

-- Flag the object as ready to process next command
XW_cmd.SetReady = function(obj)
    if XW_cmd.isReady(obj) == true then
        print('Double ready on ' .. obj.getName())
    end
    obj.setVar('cmdBusy', false)
end

--------
-- MOVEMENT DATA MODULE
-- Stores and processes data about moves
-- NOT aware of any ship position, operation solely on relative movements
-- Used for feeding data about a move to a higher level movement module
-- Exclusively uses milimeters and degrees for values, needs external conversion

-- Possible commands supported by this module
XW_cmd.AddCommand('[sk][012345][r]?', 'move')   -- Straights/Koiograns + stationary moves
XW_cmd.AddCommand('b[rle][0123][str]?', 'move')   -- Banks + segnor and reverse versions
XW_cmd.AddCommand('t[rle][01234][srfbt]?[t]?', 'move')  -- Turns + segnor, talon and reverse versions

XW_cmd.AddCommand('r[rle][123]?', 'actionMove')       --New Roll Done
XW_cmd.AddCommand('v[rle][fb][123]?', 'actionMove')   --New ViperRoll
XW_cmd.AddCommand('c[srle][123]?', 'actionMove')      --New Cloak side
XW_cmd.AddCommand('e[srle][fbrle][123]?', 'actionMove')   --New Echo Cloack


XW_cmd.AddCommand('x[rle][fb]?', 'actionMove')  -- Barrel rolls
XW_cmd.AddCommand('s[12345]b', 'actionMove')    -- Boost straights
XW_cmd.AddCommand('b[rle][123]b', 'actionMove') -- Boost banks
XW_cmd.AddCommand('t[rle][123]b', 'actionMove') -- Boost turns
XW_cmd.AddCommand('a[12]', 'actionMove')        -- Adjusts
--XW_cmd.AddCommand('c[srle]', 'actionMove')      -- Decloaks side middle + straight
--XW_cmd.AddCommand('c[rle][fb]', 'actionMove')   -- Decloaks side forward + backward
--XW_cmd.AddCommand('ch[rle][fb]', 'actionMove')  -- Echo's bullshit
--XW_cmd.AddCommand('chs[rle]', 'actionMove')     -- Echo's bullshit, part 2
--XW_cmd.AddCommand('vr[rle][fb]', 'actionMove')  -- StarViper Mk.II rolls

-- AI Module:
enable_AI = false
AIModule = {}

-- 2000mm is the length between opposite corners of an epic table.
AIModule.max_distance = 2000

-- Information about the most recently executed maneuver by an AI ship. This is
-- stored just before we move the ship, and it used when the ship comes to rest
-- and the callback is fired. Yes, this is a bit of a hack, and yes, I'd love to
-- do it a better way.
AIModule.current_move = {}
AIModule.current_move.in_progress = false
AIModule.current_move.collision = false
AIModule.current_move.difficulty = nil
AIModule.current_move.obstacle = false
AIModule.current_move.stress_count = 0
AIModule.current_move.is_ionised = false
AIModule.current_move.Reset = function()
    AIModule.current_move.collision = false
    AIModule.current_move.difficulty = nil
    AIModule.current_move.obstacle = false
    AIModule.current_move.stress_count = 0
    AIModule.current_move.is_ionised = false
end

-- Sanity check, make sure that all the moves for this ship are actually
-- possible. It won't fix every issue but it'll find most typos. This is not
-- called except when debugging.
AIModule.ValidateMoveTables = function(ship)
    local ship_id = ship.getTable('Data')['shipId']
    local rule_set = BehaviourDB.GetRuleSet()
    local behaviour = rule_set.ships[ship_id]

    for arc, range_tables in pairs(behaviour.move_table) do
        for range, move_table in pairs(range_tables) do
            for roll, move_code in pairs(move_table) do
                if AIModule.GetMoveDifficulty(ship, move_code) == nil then
                    print("Couldn't find maneuver " .. move_code .. " from ship " .. tostring(ship_id) .. "'s move table. Arc: " .. arc .. ", range: " .. range .. ", roll: " .. tostring(roll))
                end
            end
        end
    end
end

-- Only choose ships that are in arc and between ranges 1-3
AIModule.FilterForAITargetting = function(el)
    if el['in_arc'] == false then
        return false
    end

    if el['closest'].range < 1 or el['closest'].range > 3 then
        return false
    end

    return true;
end

-- Assumed to have been filtered first
AIModule.SortTargetsByAIDesirability = function(e1, e2)
    if e1['closest'] ~= nil and e2['closest'] ~= nil then
        if e1['closest'].length < e2['closest'].length then
            return true
        elseif e1['closest'].length > e2['closest'].length then
            return false
        end
    end

    return e1['ship'].getGUID() > e2['ship'].getGUID()
end

function PerformAIManeuver(args)
    local ship = args.ship

    AIModule.PerformManeuver(ship)
end

-- Target selection functions. These take a ship, and return a target ship
AIModule.TargetSelectionFunctions = {}
AIModule.TargetSelectionFunctions['ClosestInArc'] = function(ship)
    local targets = ArcCheck.GetTargetsInRelationToArc(ship, 'front')
    targets = table.sieve(targets, AIModule.FilterForAITargetting)
    --TODO: Replace this with just a simple distance check. It's faster as it's O(n) not O(log(n))
    table.sort(targets, AIModule.SortTargetsByAIDesirability)
    -- Get the first ship as it's already been sorted by distance
    for i, target in pairs(targets) do
        return target['ship']
    end

    return nil
end

AIModule.TargetSelectionFunctions['Closest'] = function(ship)
    local potential_targets = ArcCheck.GetPotentialTargets(ship, AIModule.max_distance)
    local closest_distance = nil
    local closest_target = nil
    for i, target in pairs(potential_targets) do
        local distance = Vect.Length(ship.getPosition() - target.GetPosition())
        if closest_distance == nil or  distance < closest_distance then
            closest_distance = distance
            closest_target = target
        end
    end

    return closest_target
end

AIModule.PerformManeuver = function(ship)
    if AIModule.current_move.in_progress then
        printToAll("Can't perform AI maneuver while another ship is moving.", color(1.0, 1.0, 0.2, 0.9))
        return
    end
    --AIModule.ValidateMoveTables(ship)
    AIModule.current_move.Reset()
    AIModule.current_move.stress_count = TokenModule.GetShipTokenCount(ship, "Stress")
    local stress = AIModule.current_move.stress_count > 0

    local rule_set = BehaviourDB.GetRuleSet()

    local ship_id = ship.getTable('Data')['shipId']
    local ship_behaviour = rule_set.ships[ship_id]

    if ship_behaviour ~= nil then
        printToAll('Performing AI routine for ' .. ship.GetName(), color(1.0, 1.0, 0.2, 0.9))
        local move_code = nil

        -- Find this ship's target.
        local target_ship = nil
        for _, target_selection_function in ipairs(ship_behaviour.target_selection) do
            target_ship = AIModule.TargetSelectionFunctions[target_selection_function](ship)
            if target_ship ~= nil then
                break
            end
        end

        -- Check if we're ionised.
        local is_ionised = AIModule.IsIonised(ship)
        AIModule.current_move.is_ionised = is_ionised

        if target_ship == nil then
            -- TODO: This is undefined behaviour, and highly unlikely to happen.
            -- Should it default to a 2 straight?
            printToAll('Failed to find target')
        elseif is_ionised == true then
            move_code = 's1'
            printToAll('Ionised, skipping movement selection')
        else
            -- Find out the arc that the target is in.
            local target_arc = nil
            local arc_parts = nil

            local ship_size = ship.getTable("Data").Size or 'small'

            if rule_set.useBullseyeArc then
                -- First do a check to see if the ship is in our bullseye.
                -- Move the bullseye position ahead because it's in the middle of
                -- range ruler rather than one end. Could this be moved into the
                -- GetBullseyeTargets function?
                local bullseye_position = vector(ArcCheck.bullseye_data.pos[ship_size][1], ArcCheck.bullseye_data.pos[ship_size][2], ArcCheck.bullseye_data.pos[ship_size][3] + Convert_mm_igu(AIModule.max_distance / 2) - (ArcCheck.bullseye_data.size[3] / 2))
                local bullseye_targets = ArcCheck.GetBullseyeTargets(ship, bullseye_position, AIModule.max_distance)
                for i, bullseye_target in pairs(bullseye_targets) do
                    if bullseye_target == target_ship then
                        target_arc = 'bullseye'
                        arc_parts = {'front'}
                        break
                    end
                end
            end

            if target_arc == nil then
                -- We have our target ship. Now we do some vector maths to get
                -- the angle pointing from our ship to the target ship.
                local ship_facing = Vect.RotateDeg({0, 0, -1}, ship.GetRotation().y)
                local ship_to_target = target_ship.GetPosition() - ship.getPosition()
                local angle_to_target = Vect.AngleDeg(ship_facing, ship_to_target)

                -- angleToTarget is normalised between 0 and 180, to work out if
                -- if it's pointing to our left or our right we need to get the
                -- dot product of the shipToTarget vector and the tangent to our
                -- facing.
                local ship_facing_tangent = {ship_facing[3], 0, -ship_facing[1]}
                local tangent_dot_product = Vect.DotProd(ship_to_target, ship_facing_tangent)
                if tangent_dot_product < 0 then
                    angle_to_target = angle_to_target * -1
                end

                 arc_result = rule_set.degreesToArc(angle_to_target)
                 target_arc = arc_result.target_arc
                 arc_parts = arc_result.arc_parts
            end

            -- Find the range bracket - one of closing, fleeing, distant, or
            -- stress.
            local range_bracket = nil
            if stress then
                range_bracket = 'stress'
                printToAll(' Selected target: ' .. target_ship.getName() .. ', in the ' .. target_arc .. ' arc, while stressed.')
            else
                local target_range = nil
                -- Find the range, if we haven't got it already.
                -- TODO: If a ship is at range 0, then treat it as range 1 and
                -- behind our ship. (pg 19, "Touching")
                if target_range == nil then
                    local own_line_segments = {}
                    for i, arc in ipairs(arc_parts) do
                        local segments = ArcCheck.GetOwnArcLineSegments(ship, ArcCheck.arc_line_segments[ship_size][arc]["segments"])
                        for k, segment in ipairs(segments) do
                            table.insert(own_line_segments, segment)
                        end
                    end

                    local target_line_segments = {}
                    for i, arc in ipairs(arc_parts) do
                        local segments = ArcCheck.GetTargetLineSegmentsInArc(ship, target_ship, ArcCheck.arc_line_segments[ship_size][arc]["degrees"])
                        for k, segment in ipairs(segments) do
                            table.insert(target_line_segments, segment)
                        end
                    end

                    if #target_line_segments ~= 0 then
                        local closest = nil
                        closest, _ = ArcCheck.GetDistanceBetweenLineSegments(own_line_segments, target_line_segments)
                        target_range = closest.range
                    end
                end

                -- If we're at range 2, then we need to check if the target is
                -- moving towards us (closing) or moving away from us (fleeing)
                target_closing = nil
                closing_text = '.'
                if target_range == 2 then
                    local target_ship_facing = Vect.RotateDeg({0, 0, -1}, target_ship.GetRotation().y)
                    local target_to_ship = ship.getPosition() - target_ship.GetPosition()
                    local angle_to_ship = Vect.AngleDeg(target_ship_facing, target_to_ship)

                    if (angle_to_ship < 90) then
                        target_closing = true
                        closing_text = ' and closing.'
                    else
                        target_closing = false
                        closing_text = ' and fleeing.'
                    end
                end

                printToAll(' Selected target: ' .. target_ship.getName() .. ', in the ' .. target_arc .. ' arc at range ' .. tostring(target_range) .. closing_text)

                -- Get the move for our situation.
                -- Convert our target's range and facing into a range bracket.
                range_bracket = 'distant'
                if (target_range <= 1 or (target_range == 2 and target_closing == true)) then
                    range_bracket = 'near'
                elseif (target_range == 3 or (target_range == 2 and target_closing == false)) then
                    range_bracket = 'far'
                end
            end

            -- Check if we need to flip the facing and the final move.
            local flip_move = ship_behaviour.move_table[target_arc] == nil
            if (flip_move) then
                target_arc = rule_set.flipArc(target_arc)
            end

            -- Roll the d6, and keep substracting 1 until we find a move.
            local d6_roll = math.random(6)
            while move_code == nil and d6_roll > 0 do
                move_code = ship_behaviour.move_table[target_arc][range_bracket][d6_roll]
                d6_roll = d6_roll - 1
            end

            -- If we had to flip the arc, then also flip the resulting move.
            if (flip_move) then
                if string.find(move_code, 'l') then
                    move_code = string.gsub(move_code, 'l', 'r')
                elseif string.find(move_code, 'r') then
                    move_code = string.gsub(move_code, 'r', 'l')
                end
            end
        end

        if move_code ~= nil then
            -- If we weren't ionised, then check for collisions. Attempt to
            -- swerve to avoid an obstacle.
            if ship_ionised == false then
                local move_info = MoveData.DecodeInfo(move_code, ship)
                local probe_data = MoveModule.MoveProbe.TryFullMove(move_info, ship, MoveModule.GetFullMove)
                AIModule.current_move.collision = probe_data.collObj ~= nil
                if probe_data.collObs ~= nil then
                    print(' Tried ' .. move_code .. ', hit an obstacle')
                    AIModule.current_move.obstacle = true
                    -- We've hit an obstacle! We'll try to swerve. We pick up to two
                    -- maneuvers that are the closest to our current maneuver, and
                    -- possible for our ship and stress level. Whichever of these
                    -- will get us closer to our target is the one that we try. If
                    -- that move avoids an obstacle, then we choose it instead,
                    -- otherwise we stick with our original maneuver.
                    -- TODO: deal with reverse moves
                    local potential_swerve_moves = {}
                    local swerve_speed = tostring(math.max(1, math.min(3, move_info.speed)))
                    if move_info.type == 'straight' then
                        potential_swerve_moves = {'bl' .. swerve_speed, 'br' .. swerve_speed}
                    elseif move_info.type == 'bank' then
                        potential_swerve_moves = {'t' .. string.sub(move_info.dir, 1, 1) .. swerve_speed, 's' .. swerve_speed}
                    elseif move_info.type == 'turn' then
                        potential_swerve_moves = {'b' .. string.sub(move_info.dir, 1, 1) .. swerve_speed}
                    end

                    local swerve_moves = {}
                    for _, potential_swerve_move_code in ipairs(potential_swerve_moves) do
                        -- If we can't do this move, then get the closest move that
                        -- we can do and try that instead. This may be multiple
                        -- moves, for example if a two-bank is impossible then we
                        -- may be able to try a one-bank and a three-bank. They're
                        -- both the same distance from the original so we'll try
                        -- both.
                        local nearest_move_codes = AIModule.GetNearestMoves(ship, potential_swerve_move_code, stress == false)
                        for _, nearest_move_code in ipairs(nearest_move_codes) do
                            table.insert(swerve_moves, nearest_move_code)
                        end
                    end

                    -- Loop through all of the possible swerve moves, and find out
                    -- which one will get us the closest to our target. This is the
                    -- maneuver that we'll try again with.
                    local closest_swerve_move_code = nil
                    local closest_swerve_distance = nil
                    for _, swerve_move_code in ipairs(swerve_moves) do
                        local post_swerve = MoveModule.GetFullMove(swerve_move_code, ship)
                        local post_swerve_position = Vector(post_swerve.pos[1], post_swerve.pos[2], post_swerve.pos[3])
                        local distance = Vect.Length(post_swerve_position - target_ship.GetPosition())
                        if closest_swerve_distance == nil or distance < closest_swerve_distance then
                            closest_swerve_distance = distance
                            closest_swerve_move_code = swerve_move_code
                        end
                    end

                    if closest_swerve_move_code ~= nil then
                        local swerve_move_info = MoveData.DecodeInfo(closest_swerve_move_code, ship)
                        local swerve_probe_data = MoveModule.MoveProbe.TryFullMove(swerve_move_info, ship, MoveModule.GetFullMove)
                        if swerve_probe_data.collObs == nil then
                            move_code = closest_swerve_move_code
                            print(' Tried ' .. closest_swerve_move_code .. ', avoids the obstacle.')
                            AIModule.current_move.obstacle = false
                            AIModule.current_move.collision = swerve_probe_data.collObj ~= nil
                        else
                            print(' Tried ' .. closest_swerve_move_code .. ', still hits an obstacle.')
                        end
                    end
                end
            end

            -- TODO: Check for edge of table collision

            AIModule.current_move.difficulty = 'b'

            -- If we are ionised, then our move is always blue and we remove
            -- all of our ion tokens. Otherwise, we check for our difficulty.
            if is_ionised then
                while TokenModule.GetShipTokenCount(ship, 'Ion') > 0 do
                    -- BUG: This fails to identify the ion token stack if the
                    -- ship has exactly two stress tokens. If this occurs, the
                    -- ship also leaves behind the single remaining stress
                    -- token. I've done a bit of debugging and it appears that
                    -- when a token stack has "takeObject" called on it, it
                    -- changes from a 'chip' type to a 'generic' type. This
                    -- means that it isn't picked up by ObjType.GetNearOfType.
                    -- This does correct itself if the tokens are moved around
                    -- manually, so I assume that this is just a one-frame
                    -- occurence that wouldn't matter if the AI wasn't doing
                    -- everything at the same time. Potential fix: set
                    -- '__XW_Token' on the token afterwards?
                    DialModule.PerformAction(ship, 'union', ship.getVar('owningPlayer'))
                end
            else
                AIModule.current_move.difficulty = AIModule.GetMoveDifficulty(ship, move_code)
            end
            -- Remove stress _before_ the move - if we wait till afterwards then
            -- the tokens haven't caught up with the ship and the token module
            -- doesn't count them.
            if stress and AIModule.current_move.difficulty == 'b' then
                DialModule.PerformAction(ship, 'unstress', ship.getVar('owningPlayer'))
                AIModule.current_move.stress_count = AIModule.current_move.stress_count - 1
            end

            AIModule.current_move.in_progress = true
            if MoveModule.PerformMove(move_code, ship, false, AIModule.ManeuverPostShipRest) == false then
                -- If the PerformMove function retured false, then the ship
                -- could not move at all. In this case the post-rest callback
                -- won't be fired, so we'll call it ourselves. Also, just in
                -- case, set the collision flag.
                AIModule.current_move.collision = true
                AIModule.ManeuverPostShipRest(ship)
            end
        end
    else
        printToAll('No AI routine found for ship ID ' .. tostring(ship_id), color(1.0, 1.0, 0.2, 0.9))
    end
end

AIModule.ManeuverPostShipRest = function(ship)
    if AIModule.current_move.difficulty == 'r' then
        DialModule.PerformAction(ship, 'Stress', ship.getVar("owningPlayer"))
    elseif AIModule.current_move.stress_count == 0 and AIModule.current_move.collision == false and AIModule.current_move.obstacle == false then
        if AIModule.current_move.is_ionised then
            -- TODO: Only perform a focus action (if possible)
        else
            -- TODO: Action selection.
        end
    end

    AIModule.current_move.in_progress = false
end

--[[ AIModule.GetMoveDifficulty
This function takes a ship and a move code and returns the difficulty of the
move.

ship: TTS Object, the ship performing the move
move_code: String, the move code being queried.

returns a string corresponding to the difficulty of the move for the ship:
    'b': blue maneuver, reduces stress
    'w': white manuever, stress neutral
    'r': red maneuver, causes stress
    nil: maneuver is impossible for the given ship
]]
AIModule.GetMoveDifficulty = function(ship, move_code)
    move_set = ship.getTable('Data')['moveSet']
    for _, raw_move_code in ipairs(move_set) do
        local ship_move_difficulty = string.sub(raw_move_code, 1, 1)
        local ship_move_code = string.sub(raw_move_code, 2)

        if ship_move_code == move_code then
            return ship_move_difficulty
        end
    end

    return nil
end

--[[ AIModule.GetNearestMoves
This function takes a ship and a move code, and returns the nearest maneuvers
that the ship is capable of. This may be the specified move. "Nearest" is
defined as closest in speed. We won't change the angle of the move. So for
example, if tr1 is passed in we will try tr2 and tr3, but not br1.

ship: TTS Object, the ship whose move set the function will be testing
move_code: String, the move code we want to get the closest maneuver to
can_perform_red_maneuvers: Boolean, if true then we will try red maneuvers,
    if false then we won't.

returns a table of move codes, as strings.
]]--
AIModule.GetNearestMoves = function(ship, move_code, can_perform_red_maneuvers)
    move_set = ship.getTable('Data')['moveSet']
    local move_info = MoveData.DecodeInfo(move_code, ship)
    local original_speed = move_info.speed

    -- We're going to loop through all of the ships moves and test for whether
    -- they're possible or not, and each loop we'll increase the speed offset
    -- by one. So 0 first, then -1 and +1, then -2 and +2, ... First we need
    -- to calculate the maximum number of loops we can make.
    local min_speed = 1
    local max_speed = 3
    if move_info.type == 'straight' then
        min_speed = 0
        max_speed = 5
    end
    max_offset = math.max(move_info.speed - min_speed, max_speed - move_info.speed)

    -- Break the move code into sections so we can change the speed easily.
    local speed_position = string.find(move_code, tostring(original_speed))
    local move_pre_speed = string.sub(move_code, 1, speed_position - 1)
    local move_post_speed = string.sub(move_code, speed_position + 1)

    -- Loop through all the moves at the current offset. If we find at least
    -- one possible move, then return it.
    local speed_offset = 0
    while speed_offset <= max_offset do
        -- Prepare a table of 1-2 speeds to try this loop
        local test_speeds = {}
        if speed_offset == 0 then
            table.insert(test_speeds, original_speed)
        else
            for _, direction in ipairs({1, -1}) do
                local test_speed = original_speed + speed_offset * direction
                if test_speed <= max_speed and test_speed >= min_speed then
                    table.insert(test_speeds, test_speed)
                end
            end
        end

        -- Turn the move speeds into move codes
        test_move_codes = {}
        for _, test_speed in ipairs(test_speeds) do
            table.insert(test_move_codes, move_pre_speed .. tostring(test_speed) .. move_post_speed)
        end

        -- Loop through and check if these maneuvers are in our list
        move_replacements = {}
        for _, raw_move_code in ipairs(move_set) do
            local move_difficulty = string.sub(raw_move_code, 1, 1)
            if move_difficulty ~= 'r' or can_perform_red_maneuvers then
                local move_code = string.sub(raw_move_code, 2)
                for _, test_move_code in ipairs(test_move_codes) do
                    if test_move_code == move_code then
                        table.insert(move_replacements, move_code)
                    end
                end
            end
        end

        if #move_replacements ~= 0 then
            return move_replacements
        end

        speed_offset = speed_offset + 1
    end
end

--[[ AIModule.IsIonised
This function returns whether or not a ship has enough ion tokens to ionise it.

ship: TTS Object, the ship performing the move

returns true if the ship is ionised, false otherwise.
]]
AIModule.IsIonised = function(ship)
    local ion_count = TokenModule.GetShipTokenCount(ship, "Ion")
    local ship_size = ship.getTable('Data').Size or 'small'
    if ship_size == 'small' then
        return ion_count >= 1
    elseif ship_size == 'medium' then
        return ion_count >= 2
    elseif ship_size == 'large' then
        return ion_count >= 3
    else
        return ion_count >= 6
    end

    return false
end


ArcCheck = {}
ArcCheck.initialized = false
ArcCheck.arc_check_rulers = {}
ArcCheck.current_arc = "none"

ArcCheck.arc_line_segments = {}
ArcCheck.arc_line_segments.small = {}
ArcCheck.arc_line_segments.medium = {}
ArcCheck.arc_line_segments.large = {}
ArcCheck.arc_line_segments.huge = {}

ArcCheck.bullseye_data =
{
    pos={
        small=vector(0,0,Convert_mm_igu(170)),
        medium=vector(0,0,Convert_mm_igu(180)),
        large=vector(0,0,Convert_mm_igu(190)),
        huge=vector(0,0,Convert_mm_igu(110.5))
    },
    size=vector(Convert_mm_igu(14), 0.1, Convert_mm_igu(300))
}

ArcCheck.Initialize = function() -- Arc values based on Muon's assesments (vassal)
     if ArcCheck.initialized == false then
         ArcCheck.CalculateArcLineSegments(ArcCheck.arc_line_segments.small, 81.24, 20, 20)
         ArcCheck.CalculateArcLineSegments(ArcCheck.arc_line_segments.medium, 82.8, 30, 30)
         ArcCheck.CalculateArcLineSegments(ArcCheck.arc_line_segments.large, 83.52, 40, 40)
         ArcCheck.CalculateArcLineSegments(ArcCheck.arc_line_segments.huge, 82.9, 40, 110.5 )
         ArcCheck.initialized = true
     end
 end

--[[ArcCheck.Initialize = function() -- Arc values matching TTS ruler objects
    if ArcCheck.initialized == false then
        ArcCheck.CalculateArcLineSegments(ArcCheck.arc_line_segments.small, 79.1, 20, 20)
        ArcCheck.CalculateArcLineSegments(ArcCheck.arc_line_segments.medium, 82.35, 30, 30)
        ArcCheck.CalculateArcLineSegments(ArcCheck.arc_line_segments.large, 82.9, 40, 40)
        ArcCheck.CalculateArcLineSegments(ArcCheck.arc_line_segments.huge, 82.9, 40, 110.5 )
        ArcCheck.initialized = true
    end
end]]


ArcCheck.CalculateArcLineSegments = function(table, degree, size_w, size_l)
    size_w = Convert_mm_igu(size_w)
    size_l = Convert_mm_igu(size_l)
    local edge_arc = Vect.AngleDeg2D({-size_w, 0, size_l}, {size_w, 0,size_l})
    --print("Size_W:" .. tostring(size_w) .. " size_l:"..size_l .. " edge_arc=".. tostring(edge_arc))
    if edge_arc > degree then -- Rectangular base sizes (small, medium and large ships)
        local r = math.rad(degree/2)
        local a = math.tan(r) * size_l
        table['front'] =    {   segments={ {vector(-a, 0, size_l), vector(a, 0, size_l)} },-- Front segment
                                degrees={direction=0, spread=degree/2}
                            }
        table['back'] =     {   segments={ {vector(-a, 0, -size_l), vector(a, 0, -size_l)} }, -- Front segment
                                degrees={direction=180, spread=degree/2}
                            }
        table['left'] =     {   segments={ {vector(-a, 0, -size_l), vector(-size_w, 0, -size_l)},   -- back segment
                                           {vector(-size_w, 0, -size_l), vector(-size_w, 0, size_l)}, -- left edge
                                           {vector(-size_w, 0, size_l), vector(-a, 0, size_l)}  -- front segment
                                       },
                                degrees={direction=-90, spread=(180-degree)/2}
                            }
        table['right'] =    {   segments={ {vector(a, 0, -size_l), vector(size_w, 0, -size_l)},   -- back segment
                                           {vector(size_w, 0, -size_l), vector(size_w, 0, size_l)}, -- right edge
                                           {vector(size_w, 0, size_l), vector(a, 0, size_l)}  -- front segment
                                       },
                                degrees={direction=90, spread=(180-degree)/2}
                            }
    else -- Long base size (huge ships)
        local r = math.rad(90 - degree/2)
        local a = math.tan(r) * size_w
        table['front'] =    {   segments={  {vector(-size_w, 0, a), vector(-size_w, 0, size_l)}, -- left segment
                                            {vector(-size_w, 0, size_l), vector(size_w, 0, size_l)}, -- front edge
                                            {vector(size_w, 0, size_l), vector(size_w, 0, a)} },-- right segment
                                degrees={direction=0, spread=degree/2}
                            }
        table['back'] =    {   segments={  {vector(-size_w, 0, -a), vector(-size_w, 0, -size_l)}, -- left segment
                                            {vector(-size_w, 0, -size_l), vector(size_w, 0, -size_l)}, -- back edge
                                            {vector(size_w, 0, -size_l), vector(size_w, 0, -a)} },-- right segment
                                degrees={direction=180, spread=degree/2}
                            }
        table['left'] =     {   segments={ {vector(-size_w, 0, -a), vector(-size_w, 0, a)}}, -- left segment
                                degrees={direction=-90, spread=(180-degree)/2}
                            }
        table['right'] =    {   segments={ {vector(size_w, 0, -a), vector(size_w, 0, a)}}, -- right segment
                                degrees={direction=90, spread=(180-degree)/2}
                            }
    end
    table['bullseye'] = {   segments={ {vector(-ArcCheck.bullseye_data.size[1]/2, 0, size_l), vector(ArcCheck.bullseye_data.size[1]/2, 0, size_l)} }, -- Bullseye segments
                            degrees={direction=0, spread=0, bullseye=true}
                        }
    table['fullfront'] = {  segments={ {vector(-size_w, 0, 0), vector(-size_w, 0, size_l)},   -- left segment
                                        {vector(-size_w, 0, size_l), vector(size_w, 0, size_l)}, -- front edge
                                        {vector(size_w, 0, size_l), vector(size_w, 0, 0)}  -- right segment
                                       },
                            degrees={direction=0, spread=90}
                        }
    table['fullback'] = {  segments={ {vector(-size_w, 0, 0), vector(-size_w, 0, -size_l)},   -- left segment
                                       {vector(-size_w, 0, -size_l), vector(size_w, 0, -size_l)}, -- back edge
                                       {vector(size_w, 0, -size_l), vector(size_w, 0, 0)}  -- right segment
                                   },
                            degrees={direction=180, spread=90}
                        }
     table['full'] =    {   segments={ {vector(-size_w, 0, size_l), vector(size_w, 0, size_l)},   -- front edge
                                       {vector(size_w, 0, size_l), vector(size_w, 0, -size_l)}, -- right edge
                                       {vector(size_w, 0, -size_l), vector(-size_w, 0, -size_l)},  -- back edge
                                       {vector(-size_w, 0, -size_l), vector(-size_w, 0, size_l)}  -- left edge
                                   },
                            degrees={direction=0, spread=180}
                        }
end

function CheckArc(args)
    -- Remove any rulers from old arc checks.
    for k, ruler in pairs(ArcCheck.arc_check_rulers) do
        if ruler != nil then
            ruler.destruct()
        end
    end
    ArcCheck.arc_check_rulers = {}

    -- If we are repeating the exact same arc check, then just toggle the rulers
    -- off and don't actually perform the check.
    if (ArcCheck.current_arc == args.arctype) and (args.ship == ArcCheck.current_ship) then
        ArcCheck.current_arc = "none"
        ArcCheck.current_ship = nil
        return
    end
    ArcCheck.current_arc = args.arctype
    ArcCheck.current_ship = args.ship

    -- Iterate over the potential targets and display their statuses.
    printToAll(args.ship.getName() .. ' checks for targets in the ' .. args.arctype .. ' arc:', color(1.0, 1.0, 0.2, 0.9))
    targets = ArcCheck.GetTargetsInRelationToArc(args.ship, args.arctype)
    table.sort(targets, ArcCheck.SortTargetsByDesirability)
    local found = false
    for i, target in pairs(targets) do
        ship = target['ship']

        if target['in_arc'] == false then
            printToAll(' - ' .. ship.getName() .. ' not in arc')
        elseif target['closest'].range > 3 then
            printToAll(' - ' .. ship.getName() .. ' not in range')
        else
            found = true
            ship.setLock(true)
            ArcCheck.SpawnObstructionRuler(target['closest'])
            if target['other_closest'] ~= nil then
                ArcCheck.SpawnObstructionRuler(target['other_closest'])
            end

            obstructedtext = ' is'
            if (target['obstructed'] == 'likely_unobstructed') then
                obstructedtext = ' is most likely UNOBSTRUCTED'
            elseif (target['obstructed'] == 'obstructed') then
                obstructedtext = ' is OBSTRUCTED'
            elseif (target['obstructed'] == 'likely_obstructed') then
                obstructedtext = ' is most likely OBSTRUCTED'
            elseif (target['obstructed'] == 'chosen_obstructed') then
                obstructedtext = ' can be chosen to be OBSTRUCTED'
            end

            multipletext = ''
            if target['multiple_points'] == true then
                multipletext = ' has multiple closest points and'
            end

            bullseyetext = ''
            if target['bullseye'] == true then
                bullseyetext = ' in bullseye'
            end

            printToAll(" - " .. ship.getName().. multipletext .. obstructedtext .. ' at range ' ..tostring(target['closest'].range) .. bullseyetext, color(1.0, 1.0, 0.2, 0.9))
        end
    end

    if found == false then
        printToAll(' - No valid targets', color(1.0, 1.0, 0.2, 0.9))
    end
end

--[[ GetTargetsInRelationToArc
This function returns a table containing all non-friendly ships within 900mm and
information based on the provided arc type for each one.

ship: TTS Object, the ship whose arc will be tested.
arctype: String, the arc of the ship being tested. 'front', 'bullseye', etc.
    See DataPad for full list.

returns a table of targets, each containing the following:
    ship: TTS Object, the ship being targetted
    bullseye: Boolean, true if the target is in the ship's bullseye
    closest: Table, the closest points and the range between the ship and the
        target. See ArcCheck.GetDistanceBetweenLineSegments
    in_arc: Boolean, true if the target is in the specified arc.
    obstructed: String, the state of the obstruction between the ship and the
        target. One of:
        - 'unobstructed' (no obstruction)
        - 'obstructed' (definite obstruction)
        - 'likely_unobstructed' (multiple points, but none are obstructed)
        - 'likely_obstructed' (multiple points, but both are obstructed)
        - 'chosen_obstructed' (multiple points, but only one is obstructed)
    multiple_points: Boolean, true if there is more than one closest point.
        This occurs when the two ships have the same rotation. I this is true,
        then 'other_closest' will be non-nil.
    other_closest: Table, the other closest point. See 'closest' and
        'multiple_points'. This is nil if only one closest point.
--]]
ArcCheck.GetTargetsInRelationToArc = function(ship, arctype)
    if ArcCheck.initialized == false then
        ArcCheck.Initialize()
    end

    local arc_parts = {arctype}
    if arctype == "frontback" then
        arc_parts = {"front", "back"}
    elseif arctype == "leftright" then
        arc_parts = {"left", "right"}
    end
    ship.setLock(true)
    local shipSize = ship.getTable("Data").Size or 'small'
    local potential_targets = ArcCheck.GetPotentialTargets(ship)
    local bullseye_targets = ArcCheck.GetBullseyeTargets(ship, ArcCheck.bullseye_data.pos[shipSize])
    local own_line_segments = {}
    for i, arc in ipairs(arc_parts) do
        local segments = ArcCheck.GetOwnArcLineSegments(ship, ArcCheck.arc_line_segments[shipSize][arc]["segments"])
        for k, segment in ipairs(segments) do
            table.insert(own_line_segments, segment)
        end
    end

    targets = {}
    local found = false
    for k, pt in pairs(potential_targets) do
        target = {['ship'] = pt, ['bullseye'] = false}

        for i, bt in pairs(bullseye_targets) do
            if bt == pt then
                target['bullseye'] = true
            end
        end
        local target_line_segments = {}
        for i, arc in ipairs(arc_parts) do
            local segments = ArcCheck.GetTargetLineSegmentsInArc(ship, pt, ArcCheck.arc_line_segments[shipSize][arc]["degrees"])
            for k, segment in ipairs(segments) do
                table.insert(target_line_segments, segment)
            end
        end

        if #target_line_segments ~= 0 then
            local other = nil
            local closest = nil
            closest, other = ArcCheck.GetDistanceBetweenLineSegments(own_line_segments, target_line_segments)
            target['in_arc'] = true
            target['obstructed'] = 'unobstructed'
            target['closest'] = closest
            target['multiple_points'] = false

            if closest.range <= 3 then
                found = true
                target['closest'].obstructions = ArcCheck.CheckObstruction(closest)
                target['closest'].in_bullseye = target['bullseye']
                if other ~= nil then
                    target['obstructed'] = 'likely_unobstructed'
                    target['multiple_points'] = true

                    other.obstructions = ArcCheck.CheckObstruction(other)
                    other.in_bullseye = target['bullseye']
                    target['other_closest'] = other
                end

                if #closest.obstructions ~= 0 then
                    if other ~= nil then
                        if #other.obstructions ~= 0 then
                            target['obstructed'] = 'likely_obstructed'
                        else
                            target['obstructed'] = 'chosen_obstructed'
                        end
                    else
                        target['obstructed'] = 'obstructed'
                    end
                else
                    if other ~=nil and #other.obstructions ~= 0 then
                        target['obstructed'] = 'chosen_obstructed'
                    end
                end
            end
        else
            target['in_arc'] = false
        end

        table.insert(targets, target)
    end
    if found == false then
        ArcCheck.current_arc = "none"
    end

    return targets
end

--[[ ArcCheck.SortTargetsByDesirability
This is a table sorting function, used to sort the results of
GetTargetsInRelationToArc. It sorts based on desirability of selecting a target,
in the following order:
- in arc before out of arc
- closer range band before more distant range band
- less obstructed before more obstructed
- GUID as a fallback
--]]
ArcCheck.SortTargetsByDesirability = function(e1, e2)
    if e1['in_arc'] == true and e2['in_arc'] == false then
        return true
    elseif e1['in_arc'] == false and e2['in_arc'] == true then
        return false
    elseif e1['in_arc'] == true then
        if e1['closest'].range < e2['closest'].range then
            return true
        elseif e1['closest'].range > e2['closest'].range then
            return false
        end

        -- Gotta be a better way of doing this...
        if e1['obstructed'] ~= e2['obstructed'] then
            if e1['obstructed'] == 'unobstructed' then
                return true
            elseif e2['obstructed'] == 'unobstructed' then
                return false
            end

            if e1['obstructed'] == 'likely_unobstructed' then
                return true
            elseif e2['obstructed'] == 'likely_unobstructed' then
                return false
            end

            if e1['obstructed'] == 'chosen_obstructed' then
                return true
            elseif e2['obstructed'] == 'chosen_obstructed' then
                return false
            end

            if e1['obstructed'] == 'likely_obstructed' then
                return true
            elseif e2['obstructed'] == 'likely_obstructed' then
                return false
            end

            if e1['obstructed'] == 'obstructed' then
                return true
            elseif e2['obstructed'] == 'obstructed' then
                return false
            end
        end
    end

    return e1['ship'].getGUID() > e2['ship'].getGUID()
end

ArcCheck.CheckObstruction = function(data)
    local collissions = Physics.cast({
        origin       = data.midpoint,
        orientation  = {0,data.angle, 0},
        direction    = {0,-0.3,0},
        type         = 3,
        size         = {0.1,0.1,data.length},
        max_distance = 3,
        debug        = false
    })
    local hit_obstacles = {}
    for k, hit in pairs(collissions) do
        if MoveModule.SelectObstacles(hit.hit_object) then
            table.insert(hit_obstacles, hit.hit_object)
        end
    end
    return hit_obstacles;
end

ArcCheck.SpawnArcVisualization = function()

  arc = spawnObject({
      type              = "Custom_Model",
      position          = ArcCheck.current_ship.getPosition(),
      rotation          = {0,ArcCheck.current_ship.getRotation().y + 180, 0},
      scale             = {0.3617, 0.3617, 0.3617},
      sound             = false,
      snap_to_grid      = false
  })
  arc.setCustomObject({
      mesh =  '{verifycache}http://cloud-3.steamusercontent.com/ugc/1003682288849959172/A155E2713ECFA2E23D35ED451339ECE69BF8BEF8/',
      material = 3
  })
  arc.setLock(true)
  arc.setColorTint({1,0,0,0.3})
  table.insert(ArcCheck.arc_check_rulers, arc)
end

ArcCheck.SpawnObstructionRuler = function(data)
    if data.range > 0 then
        ruler = spawnObject({
            type              = "Custom_Model",
            position          = vector(data.A[1], 1.21, data.A[3]),
            rotation          = {0, data.angle + 90,0},
            scale             = {0.3617, 0.3617, 0.5},
            sound             = false,
            snap_to_grid      = false
        })
        ruler.setCustomObject({
            mesh =  '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/models/ArcCheckRuler'.. data.range .. '.obj',
            material = 3
        })
        local tintcolor = color(1.0, 1.0, 0.2, 1.0) -- Yellow obstructed tint
        if #data.obstructions == 0 then
            if data.in_bullseye then
                tintcolor = color(1.0, 0.2, 1.0, 1.0) -- Purple unobstructed bullseye tint
            else
                tintcolor = color(0.2, 0.2, 1.0, 1.0) -- Blue unobstructed tint
            end
        else
            if data.in_bullseye then
                tintcolor = color(1.0, 0.2, 0.0, 1.0) -- orange obstructed bullseye tint
            else
                tintcolor = color(1.0, 1.0, 0.2, 1.0) -- yellow obstructed tint
            end
        end


        ruler.setColorTint(tintcolor)
        ruler.setLock(true)
        table.insert(ArcCheck.arc_check_rulers, ruler)
    end
end


-- Calculates closest distance between two set of line segments. Returns table with range, and line points
ArcCheck.GetDistanceBetweenLineSegments = function(own_line_segments, target_line_segments)
    local closest = {
        length=10000,
        range = 0,
        midpoint={0,0,0},
        angle=0,
        A={0,0,0},
        B={0,0,0}
    }
    local other = nil
    local epsilon = 0.001 -- This to dumb down the mathematical accuracy to match the analog game experience
    for k_o, seg_o in pairs(own_line_segments) do
        for k_t, seg_t in pairs(target_line_segments) do
            for k_p, point in pairs(seg_t) do
                local distance = ArcCheck.GetDistanceBetweenLineSegmentAndPoint(seg_o, point, false)
                if not ArcCheck.CheckEqualLineSegments(distance.A, distance.B, closest.A, closest.B ) then
                    if (distance.length <= (closest.length + epsilon)) then

                        if math.abs(distance.length - closest.length) < epsilon then
                            --print("Real close: " .. tostring(distance.length).. " - " .. tostring(distance.length - closest.length))
                            if distance.length < closest.length then
                                other = closest
                                closest = distance
                            else
                                other = distance
                            end
                        else
                            --print("Closer: " .. tostring(distance.length) .. " - " .. tostring(distance.length - closest.length))
                            closest = distance
                            other = nil
                        end
                    end
                end
            end
            for k_p, point in pairs(seg_o) do
                local distance = ArcCheck.GetDistanceBetweenLineSegmentAndPoint(seg_t, point, true)
                if not ArcCheck.CheckEqualLineSegments(distance.A, distance.B, closest.A, closest.B ) then
                    if (distance.length <= (closest.length + epsilon)) then
                        if math.abs(distance.length - closest.length) < epsilon then
                            --print("Real close2: " .. tostring(distance.length).. " - " .. tostring(distance.length - closest.length))
                            if distance.length < closest.length then
                                other = closest
                                closest = distance
                            else
                                other = distance
                            end
                        else
                            --print("Closer2: " .. tostring(distance.length) .. " - " .. tostring(distance.length - closest.length))
                            closest = distance
                            other = nil
                        end
                    end
                end
            end
        end
    end
    return closest, other
end

ArcCheck.GetAngleBetweenPoints = function(A,B,C)
    local BA = Vect.Between(B, A)
    local BC = Vect.Between(B, C)
    return Vect.AngleDeg(BA, BC)
end

ArcCheck.CheckEqualLineSegments = function(line1A, line1B, line2A, line2B)
    local epsilon = 0.02
    if Vect.Distance(line1A,line2A) < epsilon then
        return Vect.Distance(line1B,line2B) < epsilon
    elseif Vect.Distance(line1A,line2B) < epsilon then
        return Vect.Distance(line1B,line2A) < epsilon
    end
    return false
end


-- Gets the closest point on a line segment to a point
ArcCheck.GetDistanceBetweenLineSegmentAndPoint = function(segment, point, reverse)
    local P = {}
    -- Check if the angle at the first segment point is larger than 90 degrees, the point bust be it, and the endpoint will be closest point
    if (math.abs(ArcCheck.GetAngleBetweenPoints(segment[2], segment[1], point)) >= 90) then
        P = segment[1]
    elseif (math.abs(ArcCheck.GetAngleBetweenPoints(segment[1], segment[2], point)) >= 90) then
        -- Similarily for the second segment point
        P = segment[2]
    else
    -- The closest point is somewhere in between, along the normal of the line segment
        local u = Vect.ToUnit(Vect.Between(segment[1], segment[2]))
        local baseline_norm = Vector(-u[3], u[2], u[1])
        local d = Vect.DotProd(Vect.Between(point, segment[1]), baseline_norm)
        P = Vect.Sum(point, Vect.Scale(baseline_norm, d))
    end

    if reverse then
        A = point
        B = P
    else
        A = P
        B = point
    end
    local distance = Vect.Distance(P, point)
    local range =math.floor(Convert_igu_mm(distance / 100)) + 1

    local midpoint = Vect.Middle(A, B)
    midpoint[2] = 1.52


    local AB = Vect.Between(A, B)
    local angle = Vect.AngleDeg(AB, vector(0, 0, 1))
    if AB[1] < 0 then
        angle = -angle
    end

    return { length=distance,
             A=A,
             B=B,
             range=range,
             midpoint=midpoint,
             angle=angle
           }
end

-- Returns list of line segments which are within a given arc type
ArcCheck.GetOwnArcLineSegments = function(ship, segments)
    local outsegments = {}
    for k, segment in pairs(segments) do
        table.insert(outsegments, {Vect.Sum(ship.getPosition(), Vect.RotateDeg(segment[1], ship.getRotation()[2] + 180)),
                                   Vect.Sum(ship.getPosition(), Vect.RotateDeg(segment[2], ship.getRotation()[2] + 180))})
    end
    return outsegments
end

-- Finds all potential ships within a little more than range 3 from the ship
ArcCheck.GetPotentialTargets = function(ship, length)
    length = length or 900
    local cast_radius = Convert_mm_igu(length)
    local collissions = Physics.cast({
        origin       = ship.getPosition() + vector(0,0.1,0),
        direction    = {0,0.001,0},
        type         = 2,
        size         = {cast_radius,cast_radius,cast_radius},
        max_distance = 1,
        debug        = false
    })
    local myOwningPlayer = ship.getVar("owningPlayer")
    local potential_ships = {}
    for k, hit in pairs(collissions) do
        if hit.hit_object.getGUID() ~= ship.getGUID() and MoveModule.SelectShips(hit.hit_object) then
            if hit.hit_object.getVar("owningPlayer") != myOwningPlayer then
                table.insert(potential_ships, hit.hit_object)
            end
        end
    end
    return potential_ships
end

-- Finds all targets in bullseye
ArcCheck.GetBullseyeTargets = function(ship, pos, length)
    if length != nil then
        length = Convert_mm_igu(length)
    end
    local castSize = vector(ArcCheck.bullseye_data.size[1], ArcCheck.bullseye_data.size[2], length or ArcCheck.bullseye_data.size[3])
    local collissions = Physics.cast({
        origin       = Vect.Sum(ship.getPosition(), Vect.RotateDeg(pos, ship.getRotation()[2] + 180)),
        orientation  = ship.getRotation(),
        direction    = {0,0.001,0},
        type         = 3,
        size         = castSize,
        max_distance = 1,
        debug        = false
    })
    local myOwningPlayer = ship.getVar("owningPlayer")
    local bullseye_targets = {}
    for k, hit in pairs(collissions) do
        if hit.hit_object.getGUID() ~= ship.getGUID() and MoveModule.SelectShips(hit.hit_object) then
            if hit.hit_object.getVar("owningPlayer") != myOwningPlayer then
                table.insert(bullseye_targets, hit.hit_object)
            end
        end
    end
    return bullseye_targets
end


-- Returns a list of line segments which are within the arc
ArcCheck.GetTargetLineSegmentsInArc = function(ship, target, arcinfo)
    local targetShipData = target.getTable("Data")
    -- Get the full line segments for the ship
    local segments = ArcCheck.arc_line_segments[targetShipData.Size]["full"]["segments"]

    local outsegments = {}
    local arc_center_vector = Vect.RotateDeg(vector(0, 0, -1), ship.getRotation()[2] + arcinfo.direction)
    --print("Arc_center_vector = " .. tostring(arc_center_vector[1]).."," .. tostring(arc_center_vector[2]) ..","..tostring(arc_center_vector[3]))
    if arcinfo.bullseye == nil then
        for k, segment in pairs(segments) do
            -- Calculate part of line segment within arc
            local rotated_segment = {Vect.Sum(target.getPosition(), Vect.RotateDeg(segment[1], target.getRotation()[2])),
                                       Vect.Sum(target.getPosition(), Vect.RotateDeg(segment[2], target.getRotation()[2]))}

            -- Check if points are in arc
            local angleoffsets = {Vect.AngleDeg(Vect.Between(ship.getPosition(), rotated_segment[1]), arc_center_vector),
                            Vect.AngleDeg(Vect.Between(ship.getPosition(), rotated_segment[2]), arc_center_vector)}

            --print("Angle offsets: " .. target.getName() .. "[".. tostring(k) .. "] "..  tostring(angleoffsets[1]) .. " - " .. tostring(angleoffsets[2]) )

            if angleoffsets[1] < arcinfo.spread and angleoffsets[2] < arcinfo.spread then
                -- Both points are in arc
                --print("Both in arc")
                table.insert(outsegments, rotated_segment)
            elseif angleoffsets[1] > arcinfo.spread and angleoffsets[2] > arcinfo.spread then
                -- both outside
                if Vect.AngleDeg(Vect.Between(ship.getPosition(), Vect.Middle(rotated_segment[1], rotated_segment[2])), arc_center_vector) < arcinfo.spread then
                    -- print("Both out, in front. deg: " .. tostring(Vect.AngleDeg(Vect.Between(ship.getPosition(), Vect.Middle(rotated_segment[1], rotated_segment[2])), arc_center_vector)))
                    -- The target is infront, but both points are outside the arc.
                    local newsegment = {ArcCheck.GetLineLineIntersection(ship.getPosition(), Vect.Sum(ship.getPosition(), Vect.RotateDeg(arc_center_vector, -arcinfo.spread))
                                          , rotated_segment[1], rotated_segment[2]),
                                  ArcCheck.GetLineLineIntersection(ship.getPosition(), Vect.Sum(ship.getPosition(), Vect.RotateDeg(arc_center_vector, arcinfo.spread))
                                          , rotated_segment[1], rotated_segment[2])}
                    --print("Newsegment: ".. tostring(newsegment[1]) .. "," .. tostring(newsegment[2]))
                    table.insert(outsegments, newsegment)
                else
                    --print("Both out, behind")
                end
            else
                -- one inside, one out
                local p1 = nil
                if(angleoffsets[1] < arcinfo.spread) then
                    p1 = rotated_segment[1]
                else
                    p1 = rotated_segment[2]
                end

                -- Calculate the Y part of the cross product between the center vector and the ship -> p1 vector
                local sp1 = Vect.Between(ship.getPosition(), p1)
                local xprodY = arc_center_vector[3]*sp1[1] - arc_center_vector[1]*sp1[3]

                if xprodY > 0 then -- Positive y part means positiv spread
                    p2 = ArcCheck.GetLineLineIntersection(ship.getPosition(), Vect.Sum(ship.getPosition(), Vect.RotateDeg(arc_center_vector, arcinfo.spread))
                                          , rotated_segment[1], rotated_segment[2])
                else -- Negative y part means negative spread
                    p2 = ArcCheck.GetLineLineIntersection(ship.getPosition(), Vect.Sum(ship.getPosition(), Vect.RotateDeg(arc_center_vector, -arcinfo.spread))
                                          , rotated_segment[1], rotated_segment[2])
                end
                table.insert(outsegments, {p1, p2})

            end
        end
    else -- Special Bullseye handling
        local half_bullseye = ArcCheck.bullseye_data.size[1]/2
        for k, segment in pairs(segments) do
            local rotated_segment = {Vect.Sum(target.getPosition(), Vect.RotateDeg(segment[1], target.getRotation()[2])),
                                       Vect.Sum(target.getPosition(), Vect.RotateDeg(segment[2], target.getRotation()[2]))}
            local ownship_oriented_segment = {Vect.RotateDeg(Vect.Between(ship.getPosition(), rotated_segment[1]), -ship.getRotation()[2]),
                                            Vect.RotateDeg(Vect.Between(ship.getPosition(), rotated_segment[2] ), -ship.getRotation()[2])}
            local x1 = math.min(ownship_oriented_segment[1][1], ownship_oriented_segment[2][1])
            local x2 = math.max(ownship_oriented_segment[1][1], ownship_oriented_segment[2][1])

            local in_arc = true
            if ownship_oriented_segment[1][3] < 0 then -- Target in front (Yeah it is backwards)
                if x1 < -half_bullseye then
                    x1 = -half_bullseye
                    if x2 > -half_bullseye then
                        x2 = math.min(half_bullseye, x2)
                        p1 = ArcCheck.GetLineLineIntersection(ownship_oriented_segment[1], ownship_oriented_segment[2], vector(x1, ownship_oriented_segment[1][2], 0), vector(x1, ownship_oriented_segment[1][2], 20))
                        p2 = ArcCheck.GetLineLineIntersection(ownship_oriented_segment[1], ownship_oriented_segment[2], vector(x2, ownship_oriented_segment[1][2], 0), vector(x2, ownship_oriented_segment[1][2], 20))
                        if p1 ~= nil and p2 ~= nil then
                          table.insert(outsegments, { Vect.Sum(Vect.RotateDeg(p1, ship.getRotation()[2]), ship.getPosition()),
                                                      Vect.Sum(Vect.RotateDeg(p2, ship.getRotation()[2]), ship.getPosition())})
                        end
                    end
                elseif x1 < half_bullseye then
                    x2 = math.min(half_bullseye, x2)
                    p1 = ArcCheck.GetLineLineIntersection(ownship_oriented_segment[1], ownship_oriented_segment[2], vector(x1, ownship_oriented_segment[1][2], 0), vector(x1, ownship_oriented_segment[1][2], 20))
                    p2 = ArcCheck.GetLineLineIntersection(ownship_oriented_segment[1], ownship_oriented_segment[2], vector(x2, ownship_oriented_segment[1][2], 0), vector(x2, ownship_oriented_segment[1][2], 20))
                    if p1 ~= nil and p2 ~= nil then
                      table.insert(outsegments, { Vect.Sum(Vect.RotateDeg(p1, ship.getRotation()[2]), ship.getPosition()),
                                                  Vect.Sum(Vect.RotateDeg(p2, ship.getRotation()[2]), ship.getPosition())})
                    end
                end
            end
        end
    end
    return outsegments
end

ArcCheck.GetLineLineIntersection = function(p1, p2, p3, p4)

    if ((p2[3] - p1[3]) / (p2[1] - p1[1])) ~= ((p4[3] - p3[3]) / (p4[1] - p3[1])) then
        local d = ((p2[1] - p1[1]) * (p4[3] - p3[3])) - ((p2[3] - p1[3]) * (p4[1] - p3[1]))
        --print("GetLineLineIntersection d=" .. tostring(d))
        if d ~= 0 then
            r = (((p1[3] - p3[3]) * (p4[1] - p3[1])) - ((p1[1] - p3[1]) * (p4[3] - p3[3]))) / d
            --print("R: " .. tostring(r))
            if r > 0 then
                -- The point is infront of the first line
                return Vector(p1[1] + r * (p2[1] - p1[1]), p1[2], p1[3] + r * (p2[3] - p1[3]))
            end
        end
    end
    return nil
end


MoveData = {}

-- Lookup table for most of the moves
-- Generated using Matlab, source: https://github.com/tjakubo2/xwing_traj
-- Stored on another object to reduce clutter, passsed on load
MoveData.LUT = {}
MoveData.onLoad = function()
    for k,obj in pairs(getAllObjects()) do
        if obj.getName() == 'MoveLUT' then
            MoveData.LUT.Parse(obj)
        end
    end
end
EventSub.Register('onLoad', MoveData.onLoad)
MoveData.LUT.Parse = function(object)
    MoveData.LUT.Data = object.call('ParseLUT', {})
end

-- Max part value for partial moves
-- Part equal to this is a full move
-- Value is largely irrelevant since part can be a fraction (any kind of number really)
MoveData.partMax = 1000

-- Construct data from a lookup table entry
-- Move info provided from MoveData.DecodeInfo
-- Return format: {xPos_offset, yPos_offset, zPos_offset, yRot_offset}
-- Linear interpolation between points in lookup table
--
-- Only returns data for RIGHT direction move (if applies)
-- Doesn't take any segnor, talon versions etc into considerations
-- Above things are considered MODIFIERS with functions to apply them defined futher
MoveData.LUT.ConstructData = function(moveInfo, part)
    if part == nil then
        part = MoveData.partMax
    end
    if moveInfo.speed == 0 and moveInfo.type == 'straight' then
        return {0, 0, 0, 0}
    end
    part = math.clamp(part, 0, MoveData.partMax)
    local LUTtable = MoveData.LUT.Data[moveInfo.size .. 'Base'][moveInfo.type][moveInfo.speed]
    local LUTindex = (part/MoveData.partMax)*LUTtable.dataNum
    if LUTindex < 1 then LUTindex = 1 end
    -- Interpolation between two nearest indexes
    local aProp = LUTindex - math.floor(LUTindex)
    local bProp = 1 - aProp
    local outPos = Vect.Sum(Vect.Scale(LUTtable.posXZ[math.floor(LUTindex)], bProp), Vect.Scale(LUTtable.posXZ[math.ceil(LUTindex)], aProp))
    local outRot = (LUTtable.rotY[math.floor(LUTindex)] * bProp) + (LUTtable.rotY[math.ceil(LUTindex)] * aProp)

    local outData = {outPos[1], 0, outPos[2], outRot}
    return outData
end

-- Get true move length from LUT data *IN MILIMETERS*
-- True as in trajectory length, not distance between start and end
-- (stored in LUT to reduce load here)
MoveData.MoveLength = function(moveInfo)
    if moveInfo.traits.part == false then
        return nil
    elseif moveInfo.speed == 0 then
        return 0
    else
        return MoveData.LUT.Data[moveInfo.size .. 'Base'][moveInfo.type][moveInfo.speed].length
    end
end



-- Convert an entry from milimeters to in-game units
MoveData.ConvertDataToIGU = function(entry)
    return {Convert_mm_igu(entry[1]), Convert_mm_igu(entry[2]), Convert_mm_igu(entry[3]), entry[4]}
end

-- Change an entry to a left-heading version
MoveData.LeftVariant = function(entry)
    return {-1*entry[1], entry[2], entry[3], -1*entry[4]}
end

-- Change an entry to be k-turn like (+180deg rot at the end)
MoveData.TurnAroundVariant = function(entry)
    return {entry[1], entry[2], entry[3], entry[4]+180}
end

-- Change an entry to be talon-roll like (+90deg INWARD rot at the end)
MoveData.TurnInwardVariant = function(entry)
    local dir = 0
    if entry[1] > 0 then dir = 90
    elseif entry[1] < 0 then dir = -90 end
    return {entry[1], entry[2], entry[3], entry[4]+dir}
end

-- Change an entry to be reverse type
MoveData.ReverseVariant = function(entry)
    return {entry[1], entry[2], -1*entry[3], -1*entry[4]}
end

-- Rotate an entry by given degrees
-- Helps define rolls as straights rotated 90deg sideways etc
MoveData.RotateEntry = function(entry, angDeg)
    local rotEntry = Vect.RotateDeg(entry, angDeg)
    return {rotEntry[1], rotEntry[2], rotEntry[3], entry[4]+angDeg}
end

-- Apply move modifiers that happen even if move is partial
MoveData.ApplyBasicModifiers = function(entry, info)
    local out = table.shallowcopy(entry)
    if info.dir == 'left' then
        out = MoveData.LeftVariant(out)
    end
    if info.extra == 'reverse' then
        out = MoveData.ReverseVariant(out)
    end
    return out
end

-- Apply move modifiers that only happen if move is performed fully
MoveData.ApplyFinalModifiers = function(entry, info)
    local out = table.shallowcopy(entry)
    if info.extra == 'talon' then
        out = MoveData.TurnInwardVariant(out)
    elseif info.extra == 'koiogran' or info.extra == 'segnor' then
        out = MoveData.TurnAroundVariant(out)
    end
    return out
end


-- Decode a move command into table with type, direction, speed etc info
-- TODO make a lookup table?
MoveData.DecodeInfo = function (move_code, ship)
    local info = {
                                        -- [option1] [option2] ... [optionN]  // [errorOption]
                    type='invalid',     -- [straight] [bank] [turn] [roll] [viper] [cloak] [echo] //  [invalid]
                    speed=nil,          -- [1] [2] [3] [4] [5]  //  [nil]
                    dir=nil,            -- [left] [right] [nil]
                    extra=nil,          -- [koiogran] [segnor] [talon] [reverse] [straight] [forward] [backward] [nil]
                    traits =
                    {
                        full=false,     -- [true] [false] if this move can be attempted as a full move
                        part=false      -- [true] [false] if this move can be attempted as a partial move
                    },
                    size=nil,           -- [small] [large]  //  [nil]
                    note=nil,           -- [string] eg. 'banked xxx'       //  [nil]
                    collNote=nil,       -- [string] eg. 'tried to do xxx'  //  [nil]
                    code=move_code      -- [string] eg. 'be2'              //  [nil]
    }
    if ship ~= nil then
        info.size = ship.getTable("Data").Size or 'small'
    else
        info.size = 'small'
    end
    -- Straights and koiograns, regular stuff
    if move_code:sub(1,1) == 's' or move_code:sub(1,1) == 'k' then
        info.type = 'straight'
        info.speed = tonumber(move_code:sub(2,2))
        info.traits.full = true
        info.traits.part = true
        if move_code:sub(1,1) == 'k' then
            info.extra = 'koiogran'
            info.note = 'koiogran turned ' .. info.speed
            info.collNote = 'tried to koiogran turn ' .. info.speed
        elseif move_code:sub(-1,-1) == 'r' then
            info.extra = 'reverse'
            info.note = 'flew reverse ' .. info.speed
            info.collNote = 'tried to fly reverse ' .. info.speed
        elseif move_code:sub(-1,-1) == 'b' then
            info.traits.part = false
            local boostSpd = ''
            if info.speed > 1 then
                boostSpd = ' ' .. info.speed
            end
            info.note = 'boosted straight' .. boostSpd
            info.collNote = 'tried to boost straight' .. boostSpd
        else
            info.note = 'flew straight ' .. info.speed
            info.collNote = 'tried to fly straight ' .. info.speed
        end
        if info.speed == 0 then
            info.traits.part = false
            if info.extra == 'koiogran' then
                info.note = 'turned around'
            else
                info.note = 'is stationary'
            end
        end
    -- Banks, regular stuff
    elseif move_code:sub(1,1) == 'a' then
        info.type = 'adjust'
        info.speed = tonumber(move_code:sub(2,2))
        info.traits.full = true
        info.traits.part = false
        if info.speed == 1 then
            info.note = 'adjusted forward'
            info.collNote = 'tried to adjust forward'
        else
            info.note = 'adjusted backward'
            info.collNote = 'tried to adjust backward'
        end
    elseif move_code:sub(1,1) == 'b' then
        info.type = 'bank'
        info.dir = 'right'
        info.speed = tonumber(move_code:sub(3,3))
        info.traits.full = true
        info.traits.part = true
        if move_code:sub(2,2) == 'l' or move_code:sub(2,2) == 'e' then
            info.dir = 'left'
        end
        if move_code:sub(-1,-1) == 's' then
            info.extra = 'segnor'
            info.note = 'segnor looped ' .. info.dir .. ' ' .. info.speed
            info.collNote = 'tried to segnor loop ' .. info.dir .. ' ' .. info.speed
        elseif move_code:sub(-1,-1) == 't' then
            info.extra = 'talon'
            info.note = 'talon rolled (bank template) ' .. info.dir .. ' ' .. info.speed
            info.collNote = 'tried to talon roll ' .. info.dir .. ' ' .. info.speed
        elseif move_code:sub(-1,-1) == 'r' then
            info.extra = 'reverse'
            info.note = 'flew reverse bank ' .. info.dir .. ' ' .. info.speed
            info.collNote = 'tried to fly reverse bank ' .. info.dir .. ' ' .. info.speed
        elseif move_code:sub(-1,-1) == 'b' then
            info.traits.part = false
            local boostSpd = ''
            if info.speed > 1 then
                boostSpd = ' ' .. info.speed
            end
            info.note = 'boosted ' .. info.dir .. boostSpd
            info.collNote = 'tried to boost ' .. info.dir .. boostSpd
        else
            info.note = 'banked ' .. info.dir .. ' ' .. info.speed
            info.collNote = 'tried to bank ' .. info.dir .. ' ' .. info.speed
        end
    -- Turns, regular stuff
    elseif move_code:sub(1,1) == 't' then
        if info.size == 'huge' then
            info.note = "tried to turn, but huge ships can't do that"
            info.collNote = "tried to turn, but huge ships can't do that"
            return info
        end
        info.type = 'turn'
        info.dir = 'right'
        info.speed = tonumber(move_code:sub(3,3))
        info.traits.full = true
        info.traits.part = true
        if move_code:sub(2,2) == 'l' or move_code:sub(2,2) == 'e' then
            info.dir = 'left'
        end
        if move_code:sub(-1,-1) == 't' then
            info.type = 'talon'
            info.note = 'talon rolled ' .. info.dir .. ' ' .. info.speed
            info.collNote = 'tried to talon roll ' .. info.dir .. ' ' .. info.speed
            if move_code:sub(-2,-2) == 'f' then
                info.type = 'talonF'
                info.note = 'talon rolled ' .. info.dir .. ' ' .. info.speed .. 'adjusting Forward'
                info.collNote = 'tried to talon roll ' .. info.dir .. ' ' .. info.speed .. 'adjusting Forward'
            elseif move_code:sub(-2,-2) == 'b' then
                info.type = 'talonB'
                info.note = 'talon rolled ' .. info.dir .. ' ' .. info.speed .. 'adjusting Backward'
                info.collNote = 'tried to talon roll ' .. info.dir .. ' ' .. info.speed .. 'adjusting Backward'
            end
        elseif move_code:sub(-1,-1) == 's' then
            info.extra = 'segnor'
            info.note = 'segnor looped (turn template) ' .. info.dir .. ' ' .. info.speed
            info.collNote = 'tried to segnor loop (turn template) ' .. info.dir .. ' ' .. info.speed
        elseif move_code:sub(-1,-1) == 'r' then
            info.extra = 'reverse'
            info.note = 'flew reverse turn ' .. info.dir .. ' ' .. info.speed
            info.collNote = 'tried to fly reverse turn ' .. info.dir .. ' ' .. info.speed
        elseif move_code:sub(-1,-1) == 'b' then
            info.traits.part = false
            local boostSpd = ''
            if info.speed > 1 then
                boostSpd = ' ' .. info.speed
            end
            info.note = 'boosted (turn template) ' .. info.dir .. boostSpd
            info.collNote = 'tried to boost (turn template) ' .. info.dir .. boostSpd
        else
            info.note = 'turned ' .. info.dir .. ' ' .. info.speed
            info.collNote = 'tried to turn ' .. info.dir .. ' ' .. info.speed
        end
        if tonumber(move_code:sub(3,3)) == 4 then
            info.traits.part = false
            info.note = 'Pivoted ' .. info.dir
            info.collNote = 'tried pivoting ' .. info.dir
        end
    -- New Barrel Roll
    elseif move_code:sub(1,1) == 'r' then
        info.type = 'roll'
        info.dir = 'right'
        if move_code:sub(2,2) == 'l' or move_code:sub(2,2) == 'e' then
            info.dir = 'left'
        end
        info.speed = tonumber(move_code:sub(3,3))
        info.traits.full = true
        info.traits.part = false
        if tonumber(move_code:sub(3,3)) == 1 then
            info.note = 'barrel rolled ' .. info.dir .. ' forward'
            info.collNote = 'tried barrel rolling ' ..info.dir .. ' forward'
        elseif tonumber(move_code:sub(3,3)) == 2 then
            info.note = 'barrel rolled ' .. info.dir .. ' straight'
            info.collNote = 'tried barrel rolling ' ..info.dir .. ' straight'
        elseif tonumber(move_code:sub(3,3)) == 3 then
            info.note = 'barrel rolled ' .. info.dir .. ' backward'
            info.collNote = 'tried barrel rolling ' ..info.dir .. ' backward'
        end

    -- New Viper roll
    elseif move_code:sub(1,1) == 'v' then
        info.type = 'viper'
        info.dir = 'right'
        if move_code:sub(2,2) == 'l' or move_code:sub(2,2) == 'e' then
            info.dir = 'left'
        end
        info.speed = tonumber(move_code:sub(-1,-1))
        info.traits.full = true
        info.traits.part = false
        if move_code:sub(3,3) == 'f' then
            info.type = 'viperF'
            info.extra = 'forward'
        else
            info.type = 'viperB'
            info.extra = 'backward'
        end
        if tonumber(move_code:sub(-1,-1)) == 1 then
            info.note = 'barrel rolled ' .. info.dir .. ' ' .. info.extra .. ' adjusting forward'
            info.collNote = 'tried barrel rolling ' ..info.dir .. ' ' .. info.extra
        elseif tonumber(move_code:sub(-1,-1)) == 2 then
            info.note = 'barrel rolled ' .. info.dir .. ' ' .. info.extra .. ' adjusting straight'
            info.collNote = 'tried barrel rolling ' ..info.dir .. ' ' .. info.extra
        elseif tonumber(move_code:sub(-1,-1)) == 3 then
            info.note = 'barrel rolled ' .. info.dir .. ' ' .. info.extra .. ' adjusting backward'
            info.collNote = 'tried barrel rolling ' ..info.dir .. ' ' .. info.extra
        end
        -- New Decloak
    elseif move_code:sub(1,1) == 'c' then
        info.type = 'deCloak'
        info.dir = 'right'
        if move_code:sub(2,2) == 'l' or move_code:sub(2,2) == 'e' then
            info.dir = 'left'
        end
        info.speed = tonumber(move_code:sub(-1,-1))
        info.traits.full = true
        info.traits.part = false
        if tonumber(move_code:sub(-1,-1)) == 1 then
            info.note = 'decloaked ' .. info.dir .. ' forward'
            info.collNote = 'tried decloaking ' ..info.dir .. ' forward'
        elseif tonumber(move_code:sub(-1,-1)) == 2 then
            info.note = 'decloaked ' .. info.dir .. ' straight'
            info.collNote = 'tried decloaking ' ..info.dir .. ' straight'
        elseif tonumber(move_code:sub(-1,-1)) == 3 then
            info.note = 'decloaked ' .. info.dir .. ' backward'
            info.collNote = 'tried decloaking ' ..info.dir .. ' backward'
        end
        if move_code:sub(2,2) == 's' then
            info.type = 'straight'
            if info.size == "small" then
                info.speed = 2
            else
                info.speed = 1
            end
            info.dir = nil
            info.note = 'decloaked forward'
            info.collNote = 'tried decloacking forward'
        end
    --New Echo
    elseif move_code:sub(1,1) == 'e' then
        info.type = 'Echo'
        info.dir = 'right'
        if move_code:sub(2,2) == 'l' or move_code:sub(2,2) == 'e' then
            info.dir = 'left'
        end
        info.speed = tonumber(move_code:sub(4,4))
        info.traits.full = true
        info.traits.part = false
        if move_code:sub(3,3) == 'f' then
            info.type = 'echoF'
            info.extra = 'forward'
        elseif move_code:sub(3,3) == 'b' then
            info.type = 'echoB'
            info.extra = 'backward'
        end
        if tonumber(move_code:sub(4,4)) == 1 then
            info.note = 'decloacked ' .. info.dir .. ' ' .. info.extra .. ' adjusting forward'
            info.collNote = 'tried decloacking ' ..info.dir .. ' ' .. info.extra
        elseif tonumber(move_code:sub(4,4)) == 2 then
            info.note = 'decloacked ' .. info.dir .. ' ' .. info.extra .. ' adjusting straight'
            info.collNote = 'tried decloacking ' ..info.dir .. ' ' .. info.extra
        elseif tonumber(move_code:sub(4,4)) == 3 then
            info.note = 'decloacked ' .. info.dir .. ' ' .. info.extra .. ' adjusting backward'
            info.collNote = 'tried decloacking ' ..info.dir .. ' ' .. info.extra
        end
        if move_code:sub(2,2) == 's' then
            info.type = 'bank'
            info.speed = 2
            info.note = 'decloaked banking right'
            info.collNote = 'tried decloacking banking right'
            if move_code:sub(3,3) == 'l' or move_code:sub(3,3) == 'e' then
                info.dir = 'left'
                info.note = 'decloaked banking left'
                info.collNote = 'tried decloacking banking left'
            end
        end
    -- Barrel rolls and decloaks, spaghetti
elseif move_code:sub(1,2) == 'ch' or move_code:sub(1,2) == 'vr' then
        -- Echo's fucking bullshit which goes against ALL the standards
        -- StarViper handled the same
        info.type = 'echo'
        if move_code:sub(1,2) == 'vr' then
            info.type = 'viper'
        end
        info.dir = 'right'
        info.extra = 'forward'
        if move_code:sub(4,4) == 'b' then
            info.extra = 'backward'
        end
        if move_code:sub(3,3) == 'l' or move_code:sub(3,3) == 'e' then
            -- Ones going right/left
            info.dir = 'left'
        elseif move_code:sub(3,3) == 's' then
            -- Ones going forward
            info = MoveData.DecodeInfo('b' .. move_code:sub(4,4) .. '2', ship)
            info.traits.part = false
            info.code = move_code
        end
        if move_code:sub(1,2) == 'ch' then
            -- Echo dedscriptions
            if info.type == 'echo' then
                info.note = 'dechocloaked ' .. info.dir .. ' ' .. info.extra
                info.collNote = 'tried to dechocloak ' .. info.dir .. ' ' .. info.extra
            else
                info.note = 'dechocloaked forward ' .. info.dir
                info.collNote = 'tried to dechocloak forward ' .. info.dir
            end
        else
            -- SV descriptions
            info.note = 'bank rolled ' .. info.dir .. ' ' .. info.extra
            info.collNote = 'tried to bank roll ' .. info.dir .. ' ' .. info.extra
        end
        -- Special 2nd adjust move
        if move_code == 'chadj' or move_code == 'vradj' then
            info.extra = 'adjust'
        end
    elseif move_code:sub(1,1) == 'x' or move_code:sub(1,1) == 'c' then
        -- Rolls
        info.type = 'roll'
        info.dir = 'right'
        info.speed = 1
        if move_code:sub(2,2) == 'l' or move_code:sub(2,2) == 'e' then
            info.dir = 'left'
        end
        info.note = 'barrel rolled'
        info.collNote = 'tried to barrel roll'
        -- Decloaks
        -- Straigh decloak is treated as a roll before, now just return straight 2 data
        if move_code:sub(2,2) == 's' then
            info.type = 'straight'
            info.speed = 2
            info.traits.full = true
            info.note = 'decloaked forward'
            info.collNote = 'tried to decloak forward'
            info.dir = nil
        -- Side decloak is a barrel roll, but with 2 speed
        elseif move_code:sub(1,1) == 'c' then
            info.note = 'decloaked'
            info.collNote = 'tried to decloak'
            info.speed = 2
        end

        -- Forward/backward modifiers
        if info.type ~= 'straight' then
            if move_code:sub(-1,-1) == 'f' then
                info.extra = 'forward'
                info.note = info.note .. ' forward ' .. info.dir
                info.collNote = info.collNote .. ' forward ' .. info.dir
            elseif move_code:sub(-1,-1) == 'b' then
                info.extra = 'backward'
                info.note = info.note .. ' backward ' .. info.dir
                info.collNote = info.collNote .. ' forward ' .. info.dir
            else
                info.note = info.note .. ' ' .. info.dir
                info.collNote = info.collNote .. ' ' .. info.dir
            end
        end
    end
    return info
end

-- Get the offset data for a full move
-- Return format: {xPos_offset, yPos_offset, zPos_offset, yRot_offset}
MoveData.DecodeFullMove = function(move_code, ship)
    local data = {}
    local info = MoveData.DecodeInfo(move_code, ship)
    if info.type == 'invalid' then
        print('MoveData.DecodeFullMove: invalid move type')
        return {0, 0, 0, 0}
    else
        data = MoveData.DecodePartMove(move_code, ship, MoveData.partMax)
    end
    data = MoveData.ApplyFinalModifiers(data, info)
    return data
end

-- Get the offset data for a partial move
-- Return format: {xPos_offset, yPos_offset, zPos_offset, yRot_offset}
MoveData.DecodePartMove = function(move_code, ship, part)
    local data = {}
    local info = MoveData.DecodeInfo(move_code, ship)
    part = math.clamp(part, 0, MoveData.partMax)
    if info.type == 'invalid' then
        print('MoveData.DecodePartMove: invalid move type')
        return {0, 0, 0, 0}
    end
    data = MoveData.LUT.ConstructData(info, part)
    data = MoveData.ApplyBasicModifiers(data, info)
    return data
end


-- END MOVEMENT DATA MODULE
--------


--------
-- MAIN MOVEMENT MODULE
-- Lets us move ships around and handles what comes with moving

MoveModule = {}

-- Convert a typical entry from MoveData functions
-- (this: {xPos_offset, yPos_offset, zPos_offset, yRot_offset} )
-- to a real ship position in world
MoveModule.EntryToPos = function(entry, shipPos)
    local basePos = nil
    local baseRot = nil
    if type(shipPos) == 'userdata' then
        basePos = shipPos.getPosition()
        baseRot = shipPos.getRotation()
    elseif type(shipPos) == 'table' then
        basePos = shipPos.pos
        baseRot = shipPos.rot
    end
    local finalPos = MoveData.ConvertDataToIGU(entry)
    local finalRot = entry[4] + baseRot[2]
    finalPos = Vect.RotateDeg(finalPos, baseRot[2]+180)
    finalPos = Vect.Sum(basePos, finalPos)
    return {pos=finalPos, rot={0, finalRot, 0}}
end

-- Get the position for a ship if it did a full move
-- Returned position and rotation are ready to feed TTS functions with
MoveModule.GetFullMove = function(move, ship)
    local entry = MoveData.DecodeFullMove(move, ship)
    return MoveModule.EntryToPos(entry, ship)
end

-- Get the position for a ship if it did a part of a move
-- Returned position and rotation are ready to feed TTS functions with
MoveModule.GetPartMove = function(move, ship, part)
    local entry = MoveData.DecodePartMove(move, ship, part)
    return MoveModule.EntryToPos(entry, ship)
end


-- HISTORY HANDLING:
-- Lets us undo, redo and save positions a ship was seen at

-- History table: {ship=shipRef, actKey=keyOfHistoryEntryShipWasLastSeenAt (._.), history=entryList}
-- Entry list: {entry1, entry2, entry3, ...}
-- Entry: {pos=position, rot=rotation, move=moveThatGotShipHere, part=partOfMovePerformed}
MoveModule.moveHistory = {}

-- Hostory-related commads
XW_cmd.AddCommand('[qz]', 'historyHandle')
XW_cmd.AddCommand('undo', 'historyHandle')
XW_cmd.AddCommand('redo', 'historyHandle')
XW_cmd.AddCommand('keep', 'historyHandle')

-- Return history of a ship
MoveModule.GetHistory = function(ship)
    for k,hist in pairs(MoveModule.moveHistory) do
        if hist.ship == ship then
            return hist
        end
    end
    table.insert(MoveModule.moveHistory, {ship=ship, actKey=0, history={}})
    return MoveModule.GetHistory(ship)
end

-- Erase all history "forward" from the current state
-- Happens when you undo and then do a move - all positions you undid are lost
MoveModule.ErasePastCurrent = function(ship)
    local histData = MoveModule.GetHistory(ship)
    local k=1
    while histData.history[histData.actKey + k] ~= nil do
        histData.history[histData.actKey + k] = nil
        k = k+1
    end
end

-- Print history, just for debug
MoveModule.PrintHistory = function(ship)
    local histData = MoveModule.GetHistory(ship)
    if histData.actKey == 0 then
        print(ship.getName() .. ': NO HISTORY')
    else
        print(ship.getName() .. '\'s HISTORY:')
        local k=1
        while histData.history[k] ~= nil do
            local entry = histData.history[k]
            local typeStr = ' (' .. entry.finType
            if entry.part ~= nil then
                typeStr = typeStr .. ':' .. entry.part .. ')'
            else
                typeStr = typeStr .. ')'
            end
            if k == histData.actKey then
                print(' >> ' .. entry.move .. typeStr)
            else
                print(' -- ' .. entry.move .. typeStr)
            end
            k = k+1
        end
        print(' -- -- -- -- ')
    end
end

-- Save <some> ship position to the history
-- Saves on the position after current and deletes any past that
MoveModule.AddHistoryEntry = function(ship, entry)
    local histData = MoveModule.GetHistory(ship)
    histData.actKey = histData.actKey+1
    histData.history[histData.actKey] = entry
    MoveModule.ErasePastCurrent(ship)
end

-- How much position can be offset to be considered 'same'
MoveModule.undoPosCutoff = Convert_mm_igu(1)
-- How much rotation can be offset to be considered 'same'
MoveModule.undoRotCutoffDeg = 1

-- Check if the ship is on the curent history position (tolerance above)
MoveModule.IsAtSavedState = function(ship)
    local histData = MoveModule.GetHistory(ship)
    if histData.actKey > 0 then
        local currEntry = histData.history[histData.actKey]
        local dist = Vect.Distance(ship.getPosition(), currEntry.pos)
        local angDiff = math.abs(ship.getRotation()[2] - currEntry.rot[2])
        if math.abs(angDiff) > 180 then
            angDiff = math.abs(angDiff - math.sgn(angDiff)*360)
        end
        return (dist < MoveModule.undoPosCutoff and angDiff < MoveModule.undoRotCutoffDeg)
    end
    return false
end

-- Save curent ship position to the history
-- Can be quiet when not explicitly called by the user
MoveModule.SaveStateToHistory = function(ship, beQuiet)
    local histData = MoveModule.GetHistory(ship)
    -- Don't add an entry if it's current position/rotation
    if MoveModule.IsAtSavedState(ship) then
        if beQuiet ~= true then
            AnnModule.Announce({type='historyHandle', note='already has current position saved'}, 'all', ship)
        end
    else
        local entry = {pos=ship.getPosition(), rot=ship.getRotation(), move='position save', part=nil, finType='special'}
        MoveModule.AddHistoryEntry(ship, entry)
        if beQuiet ~= true then
            AnnModule.Announce({type='historyHandle', note='stored current position'}, 'all', ship)
        end
    end
end

-- Move a ship to a previous state from the history
-- Return true if action was taken
-- Return false if there is no more data
MoveModule.UndoMove = function(ship)
    local histData = MoveModule.GetHistory(ship)
    local announceInfo = {type='historyHandle'}
    -- No history
    if histData.actKey == 0 then
        announceInfo.note = 'has no more moves to undo'
    else
        -- There is history
        local currEntry = histData.history[histData.actKey]
        -- current position not matching history
        if not MoveModule.IsAtSavedState(ship) then
            MoveModule.MoveShip(ship, {finPos={pos=currEntry.pos, rot=currEntry.rot}, noSave=true})
            announceInfo.note = 'moved to the last saved position'
        else
        -- current position matching current histor
            if histData.actKey > 1 then
                local undidMove = currEntry.move
                histData.actKey = histData.actKey - 1
                currEntry = histData.history[histData.actKey]
                MoveModule.MoveShip(ship, {finPos={pos=currEntry.pos, rot=currEntry.rot}, noSave=true})
                announceInfo.note = 'performed an undo of (' .. undidMove .. ')'
            else
                -- There is no data to go back to
                announceInfo.note = 'has no more moves to undo'
            end
        end
    end
    AnnModule.Announce(announceInfo, 'all', ship)
    return shipMoved
end

-- Move a ship to next state from the history
MoveModule.RedoMove = function(ship)
    local histData = MoveModule.GetHistory(ship)
    local announceInfo = {type='historyHandle'}
    -- No history
    if histData.actKey == 0 then
        announceInfo.note = 'has no more moves to redo'
    else
        -- There is history
        if histData.history[histData.actKey+1] == nil then
            -- No more moves forward
            announceInfo.note = 'has no more moves to redo'
        else
            -- Move forward
            histData.actKey = histData.actKey+1
            local currEntry = histData.history[histData.actKey]
            MoveModule.MoveShip(ship, {finPos={pos=currEntry.pos, rot=currEntry.rot}, noSave=true})
            announceInfo.note = 'performed a redo of (' .. currEntry.move .. ')'
        end
    end
    AnnModule.Announce(announceInfo, 'all', ship)
    return shipMoved
end

-- Get the last move code from ship history
-- Always returns an "entry" table, if there's no move, move key is 'none'
MoveModule.GetLastMove = function(ship)
    local histData = MoveModule.GetHistory(ship)
    if histData.actKey < 1 then
        return {move='none'}
    else
        return table.shallowcopy(histData.history[histData.actKey])
    end
end

-- Get some old move from ship history (arg in number of moves back)
-- Always returns an "entry" table, if there's no move, move key is 'none'
MoveModule.GetOldMove = function(ship, numMovesBack)
    local histData = MoveModule.GetHistory(ship)
    if histData.actKey-numMovesBack < 1 then
        return {move='none'}
    else
        return table.shallowcopy(histData.history[histData.actKey-numMovesBack])
    end
end

-- THING THAT ALLOWS US TOR ESTORE SHIP POSITION AFTER IT WAS DELETED
-- Table of deleted ships last positions
MoveModule.emergencyRestore = {}
-- Pointer at the most recently added restore entry
MoveModule.restoreBufferPointer = 0
-- Max size of the restore entry table
MoveModule.restoreBufferSize = 25
-- Restore command
XW_cmd.AddCommand('restore#[1-9][0-9]?', 'historyHandle')

-- Try to restore some ship position to an entry with given key
MoveModule.Restore = function(ship, key)
    if #MoveModule.emergencyRestore < key or key <= 0 then
        AnnModule.Announce({type='historyHandle', note='Restore key (number after the #) invalid'}, 'all')
        return false
    else
        local data = MoveModule.emergencyRestore[key]
        ship.setPosition(data.savedPos.pos)
        ship.setRotation(data.savedPos.rot)
        MoveModule.SaveStateToHistory(ship, true)
        AnnModule.Announce({type='historyHandle', note='has been restored to position ' .. data.srcName .. ' was last seen at'}, 'all', ship)
        return true
    end
end

-- Save some restore data and notify the user of it
MoveModule.AddRestorePoint = function(entry)
    local newKey = MoveModule.restoreBufferPointer + 1
    if newKey > MoveModule.restoreBufferSize then
        newKey = 1
    end
    AnnModule.Announce({type='historyHandle', note=entry.srcName .. '\'s ship has been deleted - you can respawn the model and use \'restore#' .. newKey .. '\' command to restore its position'}, 'all')
    MoveModule.emergencyRestore[newKey] = entry
    MoveModule.restoreBufferPointer = newKey
end

-- Handle destroyed objects
-- Create a restore entry from last set position in history
-- Delete history if present
MoveModule.onObjectDestroyed = function(obj)
    if not ObjType.IsOfType(obj, 'ship') then return end
    if MoveModule.GetLastMove(obj).move ~= 'none' then
        local lastMove = MoveModule.GetLastMove(obj)
        MoveModule.AddRestorePoint({srcName=obj.getName(), savedPos={pos=lastMove.pos, rot=lastMove.rot}})
    end
    for k,hist in pairs(MoveModule.moveHistory) do
        if hist.ship == ship then
            table.remove(MoveModule.moveHistory, k)
            break
        end
    end
end

-- Get the history table with "serialized" positions/rotations
-- I hate this so much
-- Devs, fix your shit, goddamnit
MoveModule.GetSaveData = function()
    local currHistory = {}
    for k,hist in pairs(MoveModule.moveHistory) do
        if hist.history[1] ~= nil then
            local currEntry = MoveModule.GetLastMove(hist.ship)
            currEntry.pos = TTS_Serialize(currEntry.pos)
            currEntry.rot = TTS_Serialize(currEntry.rot)
            table.insert(currHistory, {ship=hist.ship.getGUID(), actKey=1, history={currEntry}})
        end
    end
    if currHistory[1] == nil then return nil else
    return currHistory end
end


-- Restore provided table and notify of the results
MoveModule.RestoreSaveData = function(saveTable)
    if saveTable == nil then
        return
    end
    local count = 0
    local missCount = 0
    for k,hist in pairs(saveTable) do
        hist.ship = getObjectFromGUID(hist.ship)
        if hist.ship == nil then
            missCount = missCount + 1
        else
            count = count + 1
            table.insert(MoveModule.moveHistory, hist)
        end
    end
    local info = ' - Restored last position save for ' .. count .. ' ship(s)'
    if missCount > 0 then
        info = info .. ' (' .. missCount .. ' ship model(s) missing)'
    end
    if count > 0 or missCount > 0 then
        return info
    end
end

SaveManager.Register('MoveModule', MoveModule.GetSaveData, MoveModule.RestoreSaveData)

-- Join hit tables t1 .. t5 resulting from Physics.cast call
-- Return a table of unique objects that pass selection function
-- (apaprently cant use '...' arg type when a function is a table field)
-- Arguments:
--      exclObj     <- object excluded from return table (for casts over a ship)
--      SelectFun   <- function taking an object and returning true/false (obj type selection)
--      t1 .. t5    <- hit tables returned from Physics.cast, some can be nil or empty
-- Return:
--      Concatenated table of unique objects from hit tables that also passed selection function
MoveModule.JoinHitTables = function(exclObj, SelectFun, t1, t2, t3, t4, t5)
    local gTable = {[exclObj.getGUID()]=true}
    local out = {}
    local tbls = {a=t1, b=t2, c=t3, d=t4, e=t5}
    for k,hTable in pairs(tbls) do
        for k2,hit in pairs(hTable) do
            if SelectFun(hit.hit_object) and gTable[hit.hit_object.getGUID()] == nil then
                gTable[hit.hit_object.getGUID()] = true
                table.insert(out, hit.hit_object)
            end
        end
    end
    return out
end

-- Selection function for MoveModule.JoinHitTables - ships only
MoveModule.SelectShips = function(obj)
    return (obj.tag == 'Figurine')
end

-- Selection function for MoveModule.JoinHitTables - huge ships only
MoveModule.SelectHugeShips = function(obj)
    return (obj.tag == 'Figurine') and (obj.getTable('Data').Size == 'huge')
end


-- Selection function for MoveModule.JoinHitTables - obstacles only
MoveModule.SelectObstacles = function(obj)
    local name = obj.getName()
    return (name:find('Asteroid') or name:find('Debris') or name:find('Chute debris') or name:find('Cloud') or name:find('Spare')) ~= nil
end

-- Selection function for MoveModule.JoinHitTables - mine tokens only
MoveModule.SelectMineTokens = function(obj)
    local name = obj.getName()
    return (name:find('Mine') or name:find('Connor') or name:find('Chute debris') or name:find('Probe') or name:find('Buzz')) ~= nil
end

-- Selection function for MoveModule.JoinHitTables - mines and obstacles
MoveModule.SelectMinesAndObstacleTokens = function(obj)
    return MoveModule.SelectObstacles(obj) or MoveModule.SelectMineTokens(obj)
end

-- Selection function for MoveModule.JoinHitTables - anything aside from global table object
MoveModule.SelectAny = function(obj)
    return obj.getGUID() ~= nil
end

-- Cast data for checking collisions over a ship type shape
MoveModule.castData = {}
MoveModule.castData.small = {}
MoveModule.castData.small.base = {
    debug=false,
    direction = {0, 0.001, 0},
    type=3,
    size={Convert_mm_igu(40), Convert_mm_igu(6), Convert_mm_igu(40)},
    debug=false
    -- + Origin
    -- + Orientation
}
MoveModule.castData.small.nubFR = {
    debug=false,
    localPos = {-1*Convert_mm_igu(11.38), Convert_mm_igu(-1.86), -1*Convert_mm_igu(20.858)},
    direction = {0, 0.001, 0},
    type=2,
    size={Convert_mm_igu(3.6), Convert_mm_igu(8), Convert_mm_igu(3.6)},
    -- + Origin
}
MoveModule.castData.small.nubFL = {
    debug=false,
    localPos = {Convert_mm_igu(11.38), Convert_mm_igu(-1.86), -1*Convert_mm_igu(20.858)},
    direction = {0, 0.001, 0},
    type=2,
    size={Convert_mm_igu(3.6), Convert_mm_igu(8), Convert_mm_igu(3.6)},
    -- + Origin
}
MoveModule.castData.small.nubBR = {
    debug=false,
    localPos = {-1*Convert_mm_igu(11.38), Convert_mm_igu(-1.86), Convert_mm_igu(20.858)},
    direction = {0, 0.001, 0},
    type=2,
    size={Convert_mm_igu(3.6), Convert_mm_igu(8), Convert_mm_igu(3.6)},
    -- + Origin
}
MoveModule.castData.small.nubBL = {
    debug=false,
    localPos = {Convert_mm_igu(11.38), Convert_mm_igu(-1.86), Convert_mm_igu(20.858)},
    direction = {0, 0.001, 0},
    type=2,
    size={Convert_mm_igu(3.6), Convert_mm_igu(8), Convert_mm_igu(3.6)},
    -- + Origin
}

MoveModule.castData.medium = {}
MoveModule.castData.medium.base = {
    debug=false,
    direction = {0, 0.001, 0},
    type=3,
    size={Convert_mm_igu(60), Convert_mm_igu(6), Convert_mm_igu(60)},
    -- + Origin
    -- + Orientation
}
MoveModule.castData.medium.nubFR = {
    debug=false,
    localPos = {-1*Convert_mm_igu(11.38), Convert_mm_igu(-1.86), -1*Convert_mm_igu(30.858)},
    direction = {0, 0.001, 0},
    type=2,
    size={Convert_mm_igu(3.6), Convert_mm_igu(8), Convert_mm_igu(3.6)},
    -- + Origin
}
MoveModule.castData.medium.nubFL = {
    debug=false,
    localPos = {Convert_mm_igu(11.38), Convert_mm_igu(-1.86), -1*Convert_mm_igu(30.858)},
    direction = {0, 0.001, 0},
    type=2,
    size={Convert_mm_igu(3.6), Convert_mm_igu(8), Convert_mm_igu(3.6)},
    -- + Origin
}
MoveModule.castData.medium.nubBR = {
    debug=false,
    localPos = {-1*Convert_mm_igu(11.38), Convert_mm_igu(-1.86), Convert_mm_igu(30.858)},
    direction = {0, 0.001, 0},
    type=2,
    size={Convert_mm_igu(3.6), Convert_mm_igu(8), Convert_mm_igu(3.6)},
    -- + Origin
}
MoveModule.castData.medium.nubBL = {
    debug=false,
    localPos = {Convert_mm_igu(11.38), Convert_mm_igu(-1.86), Convert_mm_igu(30.858)},
    direction = {0, 0.001, 0},
    type=2,
    size={Convert_mm_igu(3.6), Convert_mm_igu(8), Convert_mm_igu(3.6)},
    -- + Origin
}


MoveModule.castData.large = {}
MoveModule.castData.large.base = {
    debug=false,
    direction = {0, 0.001, 0},
    type=3,
    size={Convert_mm_igu(80), Convert_mm_igu(6), Convert_mm_igu(80)},
    -- + Origin
    -- + Orientation
}
MoveModule.castData.large.nubFR = {
    debug=false,
    localPos = {-1*Convert_mm_igu(11.38), Convert_mm_igu(-1.86), -1*Convert_mm_igu(40.858)},
    direction = {0, 0.001, 0},
    type=2,
    size={Convert_mm_igu(3.6), Convert_mm_igu(8), Convert_mm_igu(3.6)},
    -- + Origin
}
MoveModule.castData.large.nubFL = {
    debug=false,
    localPos = {Convert_mm_igu(11.38), Convert_mm_igu(-1.86), -1*Convert_mm_igu(40.858)},
    direction = {0, 0.001, 0},
    type=2,
    size={Convert_mm_igu(3.6), Convert_mm_igu(8), Convert_mm_igu(3.6)},
    -- + Origin
}
MoveModule.castData.large.nubBR = {
    debug=false,
    localPos = {-1*Convert_mm_igu(11.38), Convert_mm_igu(-1.86), Convert_mm_igu(40.858)},
    direction = {0, 0.001, 0},
    type=2,
    size={Convert_mm_igu(3.6), Convert_mm_igu(8), Convert_mm_igu(3.6)},
    -- + Origin
}
MoveModule.castData.large.nubBL = {
    debug=false,
    localPos = {Convert_mm_igu(11.38), Convert_mm_igu(-1.86), Convert_mm_igu(40.858)},
    direction = {0, 0.001, 0},
    type=2,
    size={Convert_mm_igu(3.6), Convert_mm_igu(8), Convert_mm_igu(3.6)},
    -- + Origin
}

MoveModule.castData.huge = {}
MoveModule.castData.huge.base = {
    debug=false,
    direction = {0, 0.001, 0},
    type=3,
    size={Convert_mm_igu(80), Convert_mm_igu(6), Convert_mm_igu(221)},
    -- + Origin
    -- + Orientation
}
MoveModule.castData.huge.nubFR = {
    debug=false,
    localPos = {-1*Convert_mm_igu(11.38), Convert_mm_igu(-1.86), -1*Convert_mm_igu(111.858)},
    direction = {0, 0.001, 0},
    type=2,
    size={Convert_mm_igu(3.6), Convert_mm_igu(8), Convert_mm_igu(3.6)},
    -- + Origin
}
MoveModule.castData.huge.nubFL = {
    debug=false,
    localPos = {Convert_mm_igu(11.38), Convert_mm_igu(-1.86), -1*Convert_mm_igu(111.858)},
    direction = {0, 0.001, 0},
    type=2,
    size={Convert_mm_igu(3.6), Convert_mm_igu(8), Convert_mm_igu(3.6)},
    -- + Origin
}
MoveModule.castData.huge.nubBR = {
    debug=false,
    localPos = {-1*Convert_mm_igu(11.38), Convert_mm_igu(-1.86), Convert_mm_igu(111.858)},
    direction = {0, 0.001, 0},
    type=2,
    size={Convert_mm_igu(3.6), Convert_mm_igu(8), Convert_mm_igu(3.6)},
    -- + Origin
}
MoveModule.castData.huge.nubBL = {
    debug=false,
    localPos = {Convert_mm_igu(11.38), Convert_mm_igu(-1.86), Convert_mm_igu(111.858)},
    direction = {0, 0.001, 0},
    type=2,
    size={Convert_mm_igu(3.6), Convert_mm_igu(8), Convert_mm_igu(3.6)},
    -- + Origin
}



-- Get cast data for particular ship situation
-- Arguments:
--      ship        <- ship ref (for base size)
--      shipPosRot  <- table with ship check position and rotation ('pos' and 'rot' keys)
--      castType    <- 'base' for base, 'nub[FB][RL]' for one of four nubs
-- Return:
--      Table ready to be fed to Physics.cast
MoveModule.GetCast = function(ship, shipPosRot, castType)
    local baseSize = ship.getTable("Data").Size or 'small'
    local castTable = MoveModule.castData[baseSize][castType]
    if castType == 'base' then
        castTable.origin = shipPosRot.pos
        castTable.orientation = shipPosRot.rot
        return castTable
    else
        castTable.origin = Vect.Sum(shipPosRot.pos, Vect.RotateDeg(castTable.localPos, shipPosRot.rot[2]))
        return castTable
    end
end

-- Return all objects that pass selection function and would overlap ship in some situation
-- Arguments:
--      ship        <- ship ref (for base size)
--      shipPosRot  <- table with ship check position and rotation ('pos' and 'rot' keys)
--      SelectFun   <- selection function that returns true/false for an object
-- Return:
--      Concatenated table of all objects that would overlap ship in this situation and pass select function
MoveModule.FullCastCheck = function(ship, shipPosRot, SelectFun)
    return MoveModule.JoinHitTables(
    ship,
    SelectFun,
    Physics.cast(MoveModule.GetCast(ship, shipPosRot, 'base')),
    Physics.cast(MoveModule.GetCast(ship, shipPosRot, 'nubFR')),
    Physics.cast(MoveModule.GetCast(ship, shipPosRot, 'nubFL')),
    Physics.cast(MoveModule.GetCast(ship, shipPosRot, 'nubBR')),
    Physics.cast(MoveModule.GetCast(ship, shipPosRot, 'nubBL'))
    )
end

-- Return all objects that pass selection function and would overlap a template in some situation
-- Arguments:
--      excludeObj   <- Object to exclude from overlapping
--      collList     <- List of already hit objects (from base overlapping)
--      templateData <- table with information on origin, orientation, speed, type and direction
--      SelectFun   <- selection function that returns true/false for an object
-- Return:
--      Concatenated table of all objects that would overlap ship in this situation and pass select function
MoveModule.TemplateCastCheck = function(excludeObj, collList, templateData, SelectFun)

    local gTable = {[excludeObj.getGUID()]=true}

    for k, coll in pairs(collList) do
        gTable[coll.getGUID()] = true
    end

    -- Find template origin and do special handling of special manouvers
    local templateOrigin = {}
    if templateData.extra == "reverse" then
        templateOrigin = MoveModule.GetTemplateOrigin(templateData.origin, templateData.orientation, templateData.shipSize, "back")
        if templateData.dir == "left" then
            templateData.dir = "right"
        elseif templateData.dir == "right" then
            templateData.dir = "left"
        end
    elseif templateData.type == "straight" or  templateData.type == "bank" or templateData.type == "turn" then
        templateOrigin = MoveModule.GetTemplateOrigin(templateData.origin, templateData.orientation, templateData.shipSize, "front")
    elseif templateData.type == "roll" then
        templateOrigin = MoveModule.GetTemplateOrigin(templateData.origin, templateData.orientation, templateData.shipSize, templateData.dir)
        templateData.speed = 1
    elseif templateData.type == "viper" then
        templateOrigin = MoveModule.GetTemplateOrigin(templateData.origin, templateData.orientation, templateData.shipSize, templateData.dir)
        if templateData.dir == "right" and templateData.extra =="forward" then
            templateData.dir = "left"
        elseif templateData.dir == "left" and templateData.extra == "backward" then
            templateData.dir = "right"
        end
        templateData.speed = 1
        templateData.type = "bank"
    elseif templateData.type == "echoF"  then
        templateOrigin = MoveModule.GetTemplateOrigin(templateData.origin, templateData.orientation, templateData.shipSize, templateData.dir)
        templateData.speed = 2
        templateData.type = "bank"
        if templateData.dir == "right" then
            templateData.dir = "left"
        elseif templateData.dir == "left" then
            templateData.dir = "right"
        end
    elseif templateData.type == "echoB"  then
        templateOrigin = MoveModule.GetTemplateOrigin(templateData.origin, templateData.orientation, templateData.shipSize, templateData.dir)
        templateData.speed = 2
        templateData.type = "bank"

    elseif templateData.type == "deCloak" then
        templateOrigin = MoveModule.GetTemplateOrigin(templateData.origin, templateData.orientation, templateData.shipSize, templateData.dir)
        if templateData.shipSize == "small" then
            templateData.speed = 2
        else
            templateData.speed = 1
        end
    else
        return
    end

    if templateData.type == "straight" or templateData.type == "roll" or templateData.type == "deCloak" then
        local offsetDistance = Convert_mm_igu(20)* tonumber(templateData.speed)

         local size = {Convert_mm_igu(20), Convert_mm_igu(6), templateData.speed*Convert_mm_igu(40)}
         if (templateData.type =="roll"  or templateData.type == "deCloak") and templateData.shipSize ~= "small" then
             size = {Convert_mm_igu(40), Convert_mm_igu(6), Convert_mm_igu(20)}
             offsetDistance = Convert_mm_igu(10)
         end

         local offset = vector(offsetDistance * math.sin(math.rad(templateOrigin.rot.y)),
          0, offsetDistance * math.cos(math.rad(templateOrigin.rot.y)) )

         local collissions = Physics.cast({
             origin       = templateOrigin.pos + offset,
             orientation  = templateOrigin.rot,
             direction    = {0,0.001,0},
             type         = 3,
             size         = size,
             max_distance = 1,
             debug        = false
         })

         MoveModule.AddCollissionEntry(gTable, collList, collissions, SelectFun)
    elseif templateData.type == "bank" then
        local radius = 0
        if templateData.speed == 1 then
            radius = Convert_mm_igu(80)
        elseif templateData.speed == 2 then
            radius = Convert_mm_igu(130)
        elseif templateData.speed == 3 then
            radius = Convert_mm_igu(180)
        end
        local iterations = 10
        local radianStep = math.pi /(4*iterations)
        local dir_mod = 1
        if templateData.dir == "left" then
            dir_mod = -1
        end
        local c = math.cos(math.rad(templateOrigin.rot.y))
        local s = math.sin(math.rad(templateOrigin.rot.y))
        for i = 0, iterations do
            local radians = radianStep*i
            local orientation_offset = vector(0, math.deg(radians), 0)
            -- Calculate world position for template
            local pz = math.sin(radians)*radius
            local px = dir_mod * (1 - math.cos(radians))*radius
            -- Translate point to template origin
            local position_offset = vector(px * c + pz * s, 0, pz * c - px * s)

            local collissions = Physics.cast({
                origin       = templateOrigin.pos + position_offset,
                orientation  = templateOrigin.rot + orientation_offset * dir_mod,
                direction    = {0,0.001,0},
                type         = 3,
                size         = {Convert_mm_igu(20), Convert_mm_igu(6), Convert_mm_igu(1)},
                max_distance = 1,
                debug        = false
            })
            MoveModule.AddCollissionEntry(gTable, collList, collissions, SelectFun)

        end
    elseif templateData.type == "turn" then
        local radius = 0
        if templateData.speed == 1 then
            radius = Convert_mm_igu(35)
        elseif templateData.speed == 2 then
            radius = Convert_mm_igu(62)
        elseif templateData.speed == 3 then
            radius = Convert_mm_igu(90)
        end
        local iterations = 10
        local radianStep = math.pi /(2*iterations)
        local dir_mod = 1
        if templateData.dir == "left" then
            dir_mod = -1
        end
        local c = math.cos(math.rad(templateOrigin.rot.y))
        local s = math.sin(math.rad(templateOrigin.rot.y))
        for i = 0, iterations do
            local radians = radianStep*i
            local orientation_offset = vector(0, math.deg(radians), 0)
            -- Calculate world position for template
            local pz = math.sin(radians)*radius
            local px = dir_mod * (1 - math.cos(radians))*radius
            -- Translate point to template origin
            local position_offset = vector(px * c + pz * s, 0, pz * c - px * s)

            local collissions = Physics.cast({
                origin       = templateOrigin.pos + position_offset,
                orientation  = templateOrigin.rot + orientation_offset * dir_mod,
                direction    = {0,0.001,0},
                type         = 3,
                size         = {Convert_mm_igu(20), Convert_mm_igu(6), Convert_mm_igu(1)},
                max_distance = 1,
                debug        = false
            })
            MoveModule.AddCollissionEntry(gTable, collList, collissions, SelectFun)

        end
    end
end


-- Adds objects from the collissions table to the collList if it pass the selectfun
-- and is not already present
-- Arguments:
--      gTable          <- GUID table, containing allready present objects
--      collList        <- List of hit objects that have passed the select fun
--      collissions     <- Table of hits returned from a Physics.cast()
--      SelectFun       <- Function that returns true if object if of correct type
MoveModule.AddCollissionEntry = function(gTable, collList, collissions, SelectFun)
    for k,hit in pairs(collissions) do
        if gTable[hit.hit_object.getGUID()] == nil and SelectFun(hit.hit_object) then
            gTable[hit.hit_object.getGUID()] = true
            table.insert(collList, hit.hit_object)
        end
    end
end

-- Return all position and rotation for a template originating position based on ship size and direction
-- Arguments:
--      shipOrigin      <- The ship origin
--      shipOrientation <- Orientation of the ship
--      shipSize        <- Size of the ship (small, medium, large)
--      templateDir     <- Which direction to get position and orientation for
-- Return:
--      TemplateOrigin (position and rotation)
MoveModule.GetTemplateOrigin = function(shipOrigin, shipOrientation, shipSize, templateDir)
    -- OBS: Ships are placed backwards
    local orientation = shipOrientation
    orientation.y = orientation.y + 180
    if templateDir == "left" then
        orientation.y = orientation.y - 90
    elseif templateDir == "right" then
        orientation.y = orientation.y + 90
    elseif templateDir == "back" then
        orientation.y = orientation.y - 180
    end

    local distance = Convert_mm_igu(20)
    if shipSize == "medium" then
        distance = Convert_mm_igu(30)
    elseif shipSize == "large" then
        distance = Convert_mm_igu(40)
    end

    local position = shipOrigin + vector(distance * math.sin(math.rad(orientation.y)), 0 , distance*math.cos(math.rad(orientation.y)))

    return {pos = position, rot = orientation}
end


-- Check if provided ship in a provided position/rotation would collide with anything from the provided table
-- Return: {coll=collObject, minMargin=howFarCollisionIsStillCertain, numCheck=numCollideChecks}
MoveModule.CheckCollisions = function(ship, shipPosRot, collShipTable)
    local info = {coll=nil, minMargin=0, numCheck=0, numCast=0}
    local shipInfo = {pos=shipPosRot.pos, rot=shipPosRot.rot, ship=ship}
    local shipSize = ship.getTable("Data").Size or 'small'
    local certShipReach = Convert_mm_igu(mm_baseSize[shipSize]/2)              -- distance at which other ships MUST bump it
    local maxShipReach = Convert_mm_igu(mm_baseSize[shipSize]*math.sqrt(2)/2)  -- distance at which other ships CAN bump it

    for k, collShip in pairs(collShipTable) do
        local collShipSize = collShip.getTable("Data").Size or 'small'
        local certBumpDist = certShipReach + Convert_mm_igu(mm_baseSize[collShipSize]/2)            -- distance at which these two particular ships ships MUST bump
        local maxBumpDist = maxShipReach + Convert_mm_igu(mm_baseSize[collShipSize]*math.sqrt(2)/2) -- distance at which these two particular ships ships CAN bump

        local dist = Vect.Distance(shipPosRot.pos, collShip.getPosition())
        if dist < maxBumpDist then
            if dist < certBumpDist then
                info.coll = collShip
                if certBumpDist - dist > info.minMargin then
                    info.minMargin = certBumpDist - dist
                end
            elseif collide(shipInfo, {pos=collShip.getPosition(), rot=collShip.getRotation(), ship=collShip}) == true then
                info.coll = collShip
                info.numCheck = info.numCheck + 1
                break
            end
        end
    end
    if info.coll == nil then
        local hTable = {}
        if shipSize == 'huge' then
            hTable = MoveModule.FullCastCheck(ship, shipPosRot,  MoveModule.SelectHugeShips)
        else
            hTable = MoveModule.FullCastCheck(ship, shipPosRot,  MoveModule.SelectShips)
        end
        info.coll = hTable[1]
    end
    return info
end

MoveModule.partResolutionRough = 1/100  -- Resolution for rough checks (guaranteed)
MoveModule.partResolutionFine = 1/1000  -- Resolution for fine checks  (for forward adjust)

-- Module for trying and finding free positions
MoveModule.MoveProbe = {}

-- Get near ships when trying a move that allows for partial execution
-- Args: SEE MoveModule.MoveProbe.GetFreePart
-- Return: {shipRef1, shipRef2, ... , shipRefN}
MoveModule.MoveProbe.GetShipsNearPart = function(info, ship, partFun, partRange)
    local middlePart = (partRange.to - partRange.from)/2
    local maxShipReach = Convert_mm_igu(mm_baseSize[info.size]*math.sqrt(2))/2
    local moveReach = math.max( Vect.Distance(partFun(info.code, ship, middlePart).pos, partFun(info.code, ship, partRange.to).pos),
                                Vect.Distance(partFun(info.code, ship, middlePart).pos, partFun(info.code, ship, partRange.from).pos) )
    local collShipRange = moveReach + maxShipReach + Convert_mm_igu(mm_largeBase*math.sqrt(2))/2 + Convert_mm_igu(10)
    return ObjType.GetNearOfType(partFun(info.code, ship, MoveData.partMax/2).pos, collShipRange, 'ship', {ship})
end
-- Get first free part for a partial-enabled move (going through parts as partRange specifies)
-- Args:
--      info        <- move info as per MoveData.DecodeInfo
--      ship        <- object ref to a ship we want to move
--      partFun     <- function that takes (moveInfo, shipRef, part) and returns {pos=position, rot=rotation} (pure data, ignores collisions)
--      partRange   <- { from = partValueFromToCheck, to = partValueToCheckTo} ((from < to), (from > to) and (from == to) to all handled)
-- Return:  {
--      part        <- number of the part that was last checked (first free if other args specify free part was found)
--      info        <- nil if free part was found sowmehere, 'first' if partRange.from was free, 'overlap' if no part was free
--      collObj     <- nil if first part was free, object ref to last colliding ship otherwise
--          }
MoveModule.MoveProbe.GetFreePart = function(info, ship, partFun, partRange, moveLength)
    if moveLength == nil then moveLength = 0 end
    moveLength = Convert_mm_igu(moveLength)
    local out = {part = nil, info = nil, collObj = nil}
    local checkNum = {rough=0, fine=0}

    -- Get ships that *can* possibly collide during this move
    local collShips = MoveModule.MoveProbe.GetShipsNearPart(info, ship, partFun, partRange)

    -- Current part and part delts for ROUGH CHECKING
    local actPart = partRange.from
    local partDelta = math.sgn(partRange.to - partRange.from)*(MoveData.partMax*MoveModule.partResolutionRough)
    local minPartDelta = math.abs(partDelta)
    local collision = false

    -- Collision check, then part delta step or margin step
    repeat
        local nPos = partFun(info.code, ship, actPart)
        local collInfo = MoveModule.CheckCollisions(ship, nPos, collShips)
        checkNum.rough = checkNum.rough + collInfo.numCheck
        local distToSkip = nil
        if collInfo.coll ~= nil then
            collision = true
            distToSkip = collInfo.minMargin
            -- If there is a distance we can travel that assures collison will not end
            if distToSkip > 0 then
                -- Calculate how big part it is and skip away
                partDelta = math.sgn(partDelta)*((distToSkip * MoveData.partMax)/moveLength)
                if math.abs(partDelta) < minPartDelta then partDelta = math.sgn(partDelta)*minPartDelta end
            else
                partDelta = math.sgn(partDelta)*minPartDelta
            end
        else
            collision = false
        end
        if collision == true then
            out.collObj = collInfo.coll
            actPart = actPart + partDelta
        end
    -- until we're out of collisions OR we're out of part range
    until collision == false or ((partRange.to - actPart)*math.sgn(partDelta) < 0) or partDelta == 0

    if collision == false and partDelta ~= 0 and actPart ~= partRange.from then
        -- Right now, we're out of any collisions or at part 0 (no move)
        -- Go fineResolution of a move forward until we have a collision, then skip one back
        partDelta = math.sgn(partRange.to - partRange.from)*(MoveData.partMax*MoveModule.partResolutionFine)*-1
        local collInfo
        repeat
            local nPos = partFun(info.code, ship, actPart)
            collInfo = MoveModule.CheckCollisions(ship, nPos, {out.collObj})
            checkNum.fine = checkNum.fine + collInfo.numCheck
            if collInfo.coll ~= nil then
                collision = true
            else
                collision = false
            end
            actPart = actPart + partDelta
        until collision == true or (partRange.from - actPart)*math.sgn(partDelta) < 0
        actPart = actPart - partDelta
        out.collObj = collInfo.coll -- This is what we hit
        out.part = actPart
    elseif collision == false then
        -- This happens if rough check didn't do anything (first part free, but no fullMove function)
        out.part = actPart
        out.info = 'first'
    elseif collision == true then
        -- This happens if rough check didn't escape collisions (no free part)
        out.info = 'overlap'
        out.part = partRange.to
    end
    -- print('-- GetFreePart CHECK_COUNT: ' .. checkNum.rough+checkNum.fine .. ' (' .. checkNum.rough .. ' + ' .. checkNum.fine .. ')')
    return out
end
-- Get near ships when trying a move that only allows for full execution
-- Args: SEE MoveModule.MoveProbe.TryFullMove
-- Return: {shipRef1, shipRef2, ... , shipRefN}
MoveModule.MoveProbe.GetShipsNearFull = function(info, ship, fullFun)
    local maxShipReach = Convert_mm_igu(mm_baseSize[info.size]*math.sqrt(2))/2
    local collShipRange = maxShipReach + Convert_mm_igu(mm_largeBase*math.sqrt(2))/2 + Convert_mm_igu(10)
    return ObjType.GetNearOfType(fullFun(info.code, ship).pos, collShipRange, 'ship', {ship})
end

-- Get near huge ships when trying a move that only allows for full execution
-- Args: SEE MoveModule.MoveProbe.TryFullMove
-- Return: {shipRef1, shipRef2, ... , shipRefN}
MoveModule.MoveProbe.GetHugeShipsNearFull = function(info, ship, fullFun)
    local shipsfound = MoveModule.MoveProbe.GetShipsNearFull(info, ship, fullFun)
    print("GetHugeShipsNearFull")
    shipsfound = table.sieve(shipsfound, function(obj) return (obj.getTable('Data').Size == 'huge') end)
    return shipsfound
end

-- Try a full version of a move
-- Args:
--      info        <- move info as per MoveData.DecodeInfo
--      ship        <- object ref to a ship we want to move
--      fullFun     <- function that takes (moveInfo, shipRef) and returns {pos=position, rot=rotation} (pure data, ignores collisions)
-- Return:  {
--      done        <- TRUE if move was completed, FALSE if it was obstructed
--      collObj     <- nil if completed, object ref to colliding ship otherwise
--      collObs     <- nil if no obstacle moved over, object ref to obstacle if otherwise
--          }
MoveModule.MoveProbe.TryFullMove = function(info, ship, fullFun)
    local collShips = nil
    if info.size == 'huge' then
        collShips = MoveModule.MoveProbe.GetHugeShipsNearFull(info, ship, fullFun)
    else
        collShips = MoveModule.MoveProbe.GetShipsNearFull(info, ship, fullFun)
    end
    local out = {done=nil, collObj=nil, collObs=nil}
    local checkNum = 0

    local startPosRot = {['pos']=ship.GetPosition(), ['rot']=ship.GetRotation()}
    local finalPosRot = fullFun(info.code, ship)

    -- Ship-to-ship collisions
    fullInfo = MoveModule.CheckCollisions(ship, finalPosRot, collShips)
    checkNum = checkNum + fullInfo.numCheck
    if fullInfo.coll == nil then
        out.done = true
    else
        out.done = false
        out.collObj = fullInfo.coll
    end

    -- Ship-to-obstacle collisions
    -- Get any obstacles that we're currently overlapping, and ignore them
    -- for the template check (but not for the final position check)
    local startingObstacleCollisions = MoveModule.CheckMineAndObstacleCollisions(ship, startPosRot, false, nil)

    local templateData =
    {
        origin = ship.GetPosition(),
        orientation = ship.GetRotation(),
        dir = info.dir,
        speed = info.speed,
        type = info.type,
        shipSize = info.size,
        extra = info.extra
    }
    -- Do the template and final position check
    local endingObstacleCollisions = MoveModule.CheckMineAndObstacleCollisions(ship, finalPosRot, false, templateData, startingObstacleCollisions)
    if #endingObstacleCollisions ~= 0 then
        out.collObs = endingObstacleCollisions[1]
    end

    return out
end

-- Get the FINAL position for a given move, including partial move and collisions
-- Follows traits from MoveData.DecodeInfo to try different move functions
-- Return:  {
--      finType     <- 'move' when did full/part mvoe
--                     'stationary' when there was no position change (rotation change allowed)
--                     'overlap' if there was no valid free target position
--                     IF OVERLAP, OTHER KEYS ARE TO BE IGNORED
--      finPos      <- { pos = finalPosition, rot = finalRotation }
--      collObj     <- nil if no collision, object ref to colliding ship otherwise
--      finPart     <- part of partial move performed, 'max' if full move, nil if not applicable
--          }
MoveModule.GetFinalPosData = function(move_code, ship, ignoreCollisions)
    local out = {finPos = nil, collObj = nil, finType = nil, finPart = nil}
    local info = MoveData.DecodeInfo(move_code, ship)

    -- Don't bother with collisions if it's stationary
    if info.speed == 0 then
        ignoreCollisions = true
    end

    -- NON-COLLISION VERSION
    if ignoreCollisions then
        if info.traits.full == true then
        -- If full moves are allowed, get a full move
            out.finPos = MoveModule.GetFullMove(info.code, ship)
            if info.speed == 0 then
                out.finType = 'stationary'
            else
                out.finType = 'move'
            end
            out.finPart = 'max'
            return out
        elseif info.traits.part == true then
        -- If partial moves are allowed, get max part move
            out.finPos = MoveModule.GetPartMove(info.code, ship, MoveData.partMax)
            out.finType = 'move'
            out.finPart = 'max'
            return out
        end

    -- COLLISION VERSION
    else
        -- If move allows for full move check, try it
        if info.traits.full == true then
            local fullData = MoveModule.MoveProbe.TryFullMove(info, ship, MoveModule.GetFullMove)
            while info.size == 'huge' and fullData.done == false do
              info.speed = info.speed -1
              if info.speed == -1 then
                info.speed = 0
                info.code = "s0"
                info.type = "straight"
              else
                info.code = string.gsub(info.code, "%d", info.speed)
              end
              fullData = MoveModule.MoveProbe.TryFullMove(info, ship, MoveModule.GetFullMove)
            end
            if fullData.done == true then
                out.finPos = MoveModule.GetFullMove(info.code, ship)
                out.finType = 'move'
                out.finPart = 'max'
                return out
            end
        end
        -- If move allows for partial execution, try to find a free part
        if info.traits.part == true then
            local partRange = {from=MoveData.partMax, to=0}
            local freePartData = MoveModule.MoveProbe.GetFreePart(info, ship, MoveModule.GetPartMove, partRange, MoveData.MoveLength(info))
            if freePartData.info ~= 'overlap' then
                out.finPos = MoveModule.GetPartMove(info.code, ship, freePartData.part)
                out.finType = 'move'
                out.finPart = freePartData.part
                out.collObj = freePartData.collObj
                return out
            end
        end
        -- If nothing worked out, we have an all-overlap
        out.finType = 'overlap'
        out.finPos = {pos=ship.getPosition(), rot=ship.getRotation()}
        return out
    end
end


-- Move ship to some position and handle stuff around it
-- If move is not stationary, clear target position and move tokens with it
-- Add history entry if save move name is provided
-- Args:
--      ship        <- object reference to ship to move
--      finData     <- {pos = targetPos, rot=targetRot}
--      saveName    <- move code for history save, no save done if nil
--      finFunction <- optional, function to call when the ship has come to rest
MoveModule.MoveShip = function(ship, finData, saveName, finFunction)
    XW_cmd.SetBusy(ship)
    MoveModule.RemoveOverlapReminder(ship)
    if finData.type ~= 'stationary' then
        TokenModule.QueueShipTokensMove(ship)
        local baseSize = ship.getTable("Data").Size or 'small'
        local shipReach = Convert_mm_igu(mm_baseSize[baseSize]+5)*(math.sqrt(2)/2)
        TokenModule.ClearPosition(finData.finPos.pos, shipReach, ship)
    end
    local finPos = finData.finPos
    if finData.noSave ~= true then
        MoveModule.SaveStateToHistory(ship, true)
    end
    ship.setPositionSmooth(finPos.pos, false, true)
    ship.setRotationSmooth(finPos.rot, false, true)
    -- Wait for resting, but provide final position to set so smooth move doesn't fuck with accuracy
    MoveModule.WaitForResting(ship, finPos, finFunction)
    if saveName ~= nil then
        MoveModule.AddHistoryEntry(ship, {pos=finPos.pos, rot=finPos.rot, move=saveName, part=finData.finPart, finType=finData.finType})
    end
end

-- This part controls the waiting part of moving
-- Basically, if anything needs to be done after the ship rests, this can trigger it

-- Ships waiting to be resting
-- Entry: {ship = shipRef, finPos={pos=posToSet, rot=rotToSet}}
MoveModule.restWaitQueue = {}

-- Tokens waiting to be moved with ships
-- Entry: { tokens={t1, t2, ... , tN}, ship=shipWaitingFor }
-- tX: {ref = tokenRef, relPos = pos, relRot = rot}
-- elements wait here until ships are ready
MoveModule.tokenWaitQueue = {}

-- Add ship to the queue so it fires once it completes the move
-- OPTIONAL: finPos     <- position to be set at the end of the wait
-- OPTIONAL: finFun     <- function to be execeuted at the end of the wait (argument: waiting ship)
MoveModule.WaitForResting = function(ship, finPos, finFun)
    table.insert(MoveModule.restWaitQueue, {ship=ship, finPos=finPos, finFun=finFun})
    startLuaCoroutine(Global, 'restWaitCoroutine')
end

-- This completes when a ship is resting at a table level
-- Does token movement and ship locking after
-- IF a final position was provided in the data table, set it at the end
-- IF a final function was provideed in the data table, execute it at the end
function restWaitCoroutine()
    if MoveModule.restWaitQueue[1] == nil then
        return 1
    end

    local waitData = MoveModule.restWaitQueue[#MoveModule.restWaitQueue]
    local actShip = waitData.ship
    local finPos = waitData.finPos
    local finFun = waitData.finFun
    table.remove(MoveModule.restWaitQueue, #MoveModule.restWaitQueue)
    -- Wait
    repeat
        coroutine.yield(0)
    until actShip.resting == true and actShip.isSmoothMoving() == false and actShip.held_by_color == nil

    if finPos ~= nil then
        actShip.setPosition(finPos.pos)
        actShip.setRotation(finPos.rot)
    end

    local newTokenTable = {}
    for k,tokenSetInfo in pairs(MoveModule.tokenWaitQueue) do
        -- Move and pop waiting tokens
        if tokenSetInfo.ship == actShip then
            for k2,tokenData in pairs(tokenSetInfo.tokens) do
                local offset = Vect.RotateDeg(tokenData.relPos, actShip.getRotation()[2])
                local dest = Vect.Sum(offset, actShip.getPosition())
                dest[2] = dest[2]+0.5
                dest = TokenModule.VisiblePosition(tokenData.ref, tokenSetInfo.ship, dest)
                tokenData.ref.setPositionSmooth(dest)
                local tRot = tokenData.ref.getRotation()
                tokenData.ref.setRotationSmooth({tRot[1], actShip.getRotation()[2] + tokenData.relRot, tRot[3]})
                tokenData.ref.highlightOn({0, 1, 0}, 2)
            end
        else
            -- Index back tokens that are not waiting for this ship
            table.insert(newTokenTable, tokenSetInfo)
        end
    end

    MoveModule.tokenWaitQueue = newTokenTable
    actShip.lock()
    actShip.highlightOn({0, 1, 0}, 0.1)
    XW_cmd.SetReady(actShip)
    if finFun ~= nil then
        finFun(actShip)
    end
    return 1
end

-- Perform move designated by move_code on a ship and announce the result
-- How move is preformed generally relies on MoveData.DecodeInfo for its code
-- Includes token handling so nothing obscurs the final position
-- Starts the wait coroutine that handles stuff done when ship settles down
-- Takes an optional parameter, the function to call at the end of the move.
MoveModule.PerformMove = function(move_code, ship, ignoreCollisions, finishFunction)
    ship.lock()
    local originalPos = ship.getPosition()
    local origionalRot = ship.getRotation()
    local info = MoveData.DecodeInfo(move_code, ship)
    local finData = MoveModule.GetFinalPosData(move_code, ship, ignoreCollisions)
    local annInfo = {type=finData.finType, note=info.note, code=info.code}
    if finData.finType == 'overlap' then
        annInfo.note = info.collNote
    elseif finData.finType == 'move' then
        if finData.collObj ~= nil then
            annInfo.note = info.collNote
            annInfo.collidedShip = finData.collObj
        end
    elseif finData.finType == 'stationary' then
        -- And here as well
    end

    if finData.finType ~= 'overlap' then
        MoveModule.MoveShip(ship, finData, move_code, finishFunction)
        if finData.collObj ~= nil then
            MoveModule.SpawnOverlapReminder(ship)
        end
    end
    AnnModule.Announce(annInfo, 'all', ship)

    local templateData =
    {
        origin = originalPos,
        orientation = origionalRot,
        dir = info.dir,
        speed = info.speed,
        type = info.type,
        shipSize = info.size,
        extra = info.extra
    }

    MoveModule.CheckMineAndObstacleCollisions(ship, finData.finPos, true, templateData)
    --MoveModule.CheckObstacleCollisions(ship, finData.finPos, true, templateData)
    --MoveModule.CheckMineCollisions(ship, finData.finPos, true, templateData)
    return (finData.finType ~= 'overlap')
end

-- Spawn a 'BUMPED' informational button on the base that removes itself on click or next move
MoveModule.SpawnOverlapReminder = function(ship)
    Ship_RemoveOverlapReminder(ship)
    remindButton = {click_function = 'Ship_RemoveOverlapReminder', label = 'BUMPED', rotation =  {0, 0, 0}, width = 1000, height = 350, font_size = 250}

    local size = ship.getTable("Data").Size or 'small'
    if size == 'large' then
        remindButton.position = {0, 0.2, 2}
    elseif size == 'medium' then
        remindButton.position = {0, 0.2, 1.4}
    else
        remindButton.position = {0, 0.3, 0.8}
    end
    ship.createButton(remindButton)
end

-- Remove the 'BUMPED' dummy button from a ship
MoveModule.RemoveOverlapReminder = function(ship)
    local buttons = ship.getButtons()
    if buttons ~= nil then
        for k,but in pairs(buttons) do if but.label == 'BUMPED' then ship.removeButton(but.index) end end
    end
end

-- Check if a ship in some situation is overlapping any obstacles
-- Highlight overlapped obstacles red
-- If 'vocal' set to true, add a notification
-- Return table of overlapped obstacles
MoveModule.CheckObstacleCollisions = function(ship, targetPosRot, vocal, templateData)
    local collList = MoveModule.FullCastCheck(ship, targetPosRot,  MoveModule.SelectObstacles)
    if templateData ~= nil then
        MoveModule.TemplateCastCheck(ship, collList, templateData, MoveModule.SelectObstacles)
    end
    if collList[1] ~= nil then
        local obsList = '('
        for k,obs in pairs(collList) do
            obs.highlightOn({1, 0, 0}, 3)
            obsList = obsList .. obs.getName() .. ', '
        end
        obsList = obsList:sub(1, -3) .. ')'
        if vocal then
            AnnModule.Announce({type='warn', note=ship.getName() .. ' appears to have overlapped an obstacle ' .. obsList}, 'all')
        end
    end
    return collList
end



-- Check if a ship in some situation is overlapping any mine tokens
-- Highlight overlapped tokens red
-- If 'vocal' set to true, add a notification
-- Return table of overlapped tokens
--TODO maybe check mine colision after bomb drop?
MoveModule.CheckMineCollisions = function(ship, targetPosRot, vocal, templateData)
    local collList = MoveModule.FullCastCheck(ship, targetPosRot,  MoveModule.SelectMineTokens)
    if templateData ~= nil then
        MoveModule.TemplateCastCheck(ship, collList, templateData, MoveModule.SelectMineTokens)
    end
    if collList[1] ~= nil then
        local mineList = '('
        for k,mine in pairs(collList) do
            mine.highlightOn({1, 0, 0}, 3)
            mineList = mineList .. mine.getName() .. ', '
        end
        mineList = mineList:sub(1, -3) .. ')'
        if vocal then
            AnnModule.Announce({type='warn', note=ship.getName() .. ' appears to have overlapped a mine token ' .. mineList}, 'all')
        end
    end
    return collList
end

MoveModule.CheckMineAndObstacleCollisions = function(ship, targetPosRot, vocal, templateData, ignoredTemplateObstacles)
    local collList = MoveModule.FullCastCheck(ship, targetPosRot,  MoveModule.SelectMinesAndObstacleTokens)
    if templateData ~= nil then
        MoveModule.TemplateCastCheck(ship, collList, templateData, function(obj)
            if ignoredTemplateObstacles ~= nil then
                for _, ignoredTemplate in pairs(ignoredTemplateObstacles) do
                    if obj == ignoredTemplate then
                        return false
                    end
                end
            end
            return MoveModule.SelectMinesAndObstacleTokens(obj)
        end)
    end
    if vocal then
        if collList[1] ~= nil then
            local hitList = '('
            for k, hitObj in pairs(collList) do
                hitObj.highlightOn({1, 0, 0}, 3)
                hitList = hitList .. hitObj.getName() .. ', '
            end
            hitList = hitList:sub(1, -3) .. ')'
            AnnModule.Announce({type='warn', note=ship.getName() .. ' appears to have overlapped a mine or obstacle token ' .. hitList}, 'all')
        end
    end
    return collList
end

-- Remove the 'BUMPED' button from a ship (click function)
function Ship_RemoveOverlapReminder(ship)
    MoveModule.RemoveOverlapReminder(ship)
end

-- Check which ship has it's base closest to position (large ships have large bases!), that's the owner
--   also check how far it is to the owner-changing position (margin of safety)
-- Kinda tested: margin > 20mm = visually safe
-- Arg can be a token ref or a position
-- Returns {dist=distanceFromOwner, owner=ownerRef, margin=marginForNextCloseShip}
MoveModule.GetTokenOwner = function(tokenPos)
    local out = {owner=nil, dist=0, margin=-1}
    local nearShips = ObjType.GetNearOfType(tokenPos, Convert_mm_igu(120), 'ship')
    if nearShips[1] == nil then return out end
    local baseDist = {}
    -- Take the base size into account for distances
    for k,ship in pairs(nearShips) do
        local realDist = Vect.Distance(tokenPos, ship.getPosition())
        local size = ship.getTable("Data").Size or 'small'
        if size == 'large' then
            realDist = realDist - Convert_mm_igu(10)
        elseif size == 'medium' then
            realDist = realDist - Convert_mm_igu(5)
        end
        table.insert(baseDist, {ship=ship, dist=realDist})
    end
    local nearest = baseDist[1]
    for k,data in pairs(baseDist) do
        if data.dist < nearest.dist then nearest = data end
    end
    local nextNearest = {dist=999}
    for k,data in pairs(baseDist) do
        if data.ship ~= nearest.ship and (data.dist < nextNearest.dist) then
            nextNearest = data
        end
    end
    return {owner=nearest.ship, dist=nearest.dist, margin=(nextNearest.dist-nearest.dist)/2}
end

-- END MAIN MOVEMENT MODULE
--------

--------
-- TOKEN MODULE
-- Moves tokens, clears positions from tokens, checks its owners, deducts a visible position after a ship move

TokenModule = {}
-- Table with refs for different token and template sources
TokenModule.tokenSources = {}

-- Update token and template sources on each load
TokenModule.onLoad = function()
    for k, obj in pairs(getAllObjects()) do
        if obj.tag == 'Infinite' then
            if obj.getName() == 'Focus' then TokenModule.tokenSources.Focus = {src=obj, hlColor={0, 0.5, 0}}
            elseif obj.getName() == 'Calculate' then TokenModule.tokenSources.Calculate = {src=obj, hlColor={0, 1, 0}}
            elseif obj.getName() == 'Evade' then TokenModule.tokenSources.Evade = {src=obj, hlColor={0, 1, 0}}
            elseif obj.getName() == 'Stress' then TokenModule.tokenSources.Stress = {src=obj, hlColor={0.8, 0, 0}}
            elseif obj.getName() == 'Strain' then TokenModule.tokenSources.Strain = {src=obj, hlColor={0.8, 0, 0}}
            elseif obj.getName() == 'Ion' then TokenModule.tokenSources.Ion = {src=obj, hlColor={0.8, 0, 0}}
            elseif obj.getName() == 'Jam' then TokenModule.tokenSources.Jam = {src=obj, hlColor={0.8, 0, 0}}
            elseif obj.getName() == 'Tractor' then TokenModule.tokenSources.Tractor = {src=obj, hlColor={0.8, 0, 0}}
            elseif obj.getName() == 'Disarm' then TokenModule.tokenSources.Disarm = {src=obj, hlColor={0.8, 0, 0}}
            elseif obj.getName() == 'Reinforce' then TokenModule.tokenSources.Reinforce = {src=obj, hlColor={0.8, 0, 0}}
            elseif obj.getName() == 'Cloak' then TokenModule.tokenSources.Cloak = {src=obj, hlColor={0.8, 0, 0}}
            elseif obj.getName() == 'Target Locks' then TokenModule.tokenSources['Target Lock'] = {src=obj, hlColor={0, 0, 1}}
            elseif obj.getName():find('Templates') ~= nil then
                if obj.getName():find('Straight') ~= nil then
                    TokenModule.tokenSources['s' .. obj.getName():sub(1,1)] = obj
                elseif obj.getName():find('Turn') ~= nil then
                    TokenModule.tokenSources['t' .. obj.getName():sub(1,1)] = obj
                elseif obj.getName():find('Bank') ~= nil then
                    TokenModule.tokenSources['b' .. obj.getName():sub(1,1)] = obj
                end
            end
        end
    end
end
EventSub.Register('onLoad', TokenModule.onLoad)

-- How far can tokens be to be considered owned bya  ship
TokenModule.tokenReachDistance = Convert_mm_igu(100)
-- By how much this token has to be distant from other ship "interception zone" to be visible
-- (how far from an owner-switching-border it has to be so you can see whose it is)
TokenModule.visibleMargin = Convert_mm_igu(20)

-- Preset positions for tokens on and near the base
-- Generally used only when their current position switches its owner after a move
-- Positions on the base

TokenModule.basePos = {}

-- On base - small ships
TokenModule.basePos.small = {}
TokenModule.basePos.small.Focus     = { 12,  12}
TokenModule.basePos.small.Calculate = { 12,  24}
TokenModule.basePos.small.Evade     = { 12, -12}
TokenModule.basePos.small.Stress    = {-12,  12}
TokenModule.basePos.small.Ion       = {-12,  -24}
TokenModule.basePos.small.Strain    = {-12,  24}

TokenModule.basePos.small.Reinforce = {-24,  24}
TokenModule.basePos.small.Cloak     = {-24, -24}
TokenModule.basePos.small.Jam       = { 24, -12}
TokenModule.basePos.small.Disarm    = { 24,  12}
TokenModule.basePos.small.Tractor   = { 24,  24}

TokenModule.basePos.small.rest      = {-12, -12}

--On base - medium ships
TokenModule.basePos.medium = {}
TokenModule.basePos.medium.Focus     = { 25,  25}
TokenModule.basePos.medium.Calculate = { 25,  35}
TokenModule.basePos.medium.Evade     = { 25, -25}
TokenModule.basePos.medium.Stress    = {-25,  25}
TokenModule.basePos.medium.Ion       = {-25, -35}
TokenModule.basePos.medium.Strain    = {-25,  35}

TokenModule.basePos.medium.Reinfoce  = {-35,  35}
TokenModule.basePos.medium.Cloak     = {-35, -35}
TokenModule.basePos.medium.Jam       = { 35, -25}
TokenModule.basePos.medium.Disarm    = { 35,  25}
TokenModule.basePos.medium.Tractor   = { 35,  35}

TokenModule.basePos.medium.rest      = {-25, -25}

-- On base - large ships
TokenModule.basePos.large = {}
TokenModule.basePos.large.Focus     = { 30,  30}
TokenModule.basePos.large.Calculate = { 30,  40}
TokenModule.basePos.large.Evade     = { 30,   0}
TokenModule.basePos.large.Stress    = { 30, -30}
TokenModule.basePos.large.Strain    = { 30, -40}
TokenModule.basePos.large.Tractor   = {-30,  30}
TokenModule.basePos.large.Ion       = {-30,   0}
TokenModule.basePos.large.Lock      = {  0,  30}

TokenModule.basePos.large.Cloak     = { 30,  30}
TokenModule.basePos.large.Reinforce = {-30,  30}
TokenModule.basePos.large.Jam       = {-30, -30}
TokenModule.basePos.large.Disarm    = { 40,  30}

TokenModule.basePos.large.rest      = {-30, -30}


-- Positions near the base
-- Near base - small ships
TokenModule.nearPos = {}

TokenModule.nearPos.small = {}
TokenModule.nearPos.small.Focus     = { 35,  25}
TokenModule.nearPos.small.Calculate = { 15,  35}
TokenModule.nearPos.small.Evade     = { 35,   0}
TokenModule.nearPos.small.Stress    = { 35, -25}
TokenModule.nearPos.small.Strain    = { 35, -35}
TokenModule.nearPos.small.Ion       = {-35,  25}
TokenModule.nearPos.small.Tractor   = {-35,   0}
TokenModule.nearPos.small.Lock      = {  0,  40}


TokenModule.nearPos.small.Reinfoce  = {-35,  35}
TokenModule.nearPos.small.Cloak     = {-35, -35}
TokenModule.nearPos.small.Jam       = { 35, -25}
TokenModule.nearPos.small.Disarm    = { 35,  25}

TokenModule.nearPos.small.rest      = {-35, -25}

-- Near base - medium ships
TokenModule.nearPos.medium = {}
TokenModule.nearPos.medium.Focus     = { 45,  28}
TokenModule.nearPos.medium.Calculate = { 45,  56}
TokenModule.nearPos.medium.Evade     = { 45,   0}
TokenModule.nearPos.medium.Stress    = { 45, -28}
TokenModule.nearPos.medium.Strain    = { 45, -45}
TokenModule.nearPos.medium.Ion       = {-45,  28}
TokenModule.nearPos.medium.Tractor   = {-45,   0}
TokenModule.nearPos.medium.Lock      = {  0,  45}

TokenModule.nearPos.medium.Reinfoce  = {-35,  35}
TokenModule.nearPos.medium.Cloak     = {-35, -35}
TokenModule.nearPos.medium.Jam       = { 35, -25}
TokenModule.nearPos.medium.Disarm    = { 35,  25}

TokenModule.nearPos.medium.rest      = {-45, -35}

-- Near base - large ships
TokenModule.nearPos.large = {}
TokenModule.nearPos.large.Focus     = { 55,  30}
TokenModule.nearPos.large.Calculate = { 55,  30}
TokenModule.nearPos.large.Evade     = { 55,   0}
TokenModule.nearPos.large.Stress    = { 55, -30}
TokenModule.nearPos.large.Strain    = { 55, -55}
TokenModule.nearPos.large.Tractor   = {-55,  45}
TokenModule.nearPos.large.Ion       = {-55,  15}
TokenModule.nearPos.large.Weapons   = {-55, -15}
TokenModule.nearPos.large.Lock      = {  0,  50}

TokenModule.nearPos.medium.Reinfoce = {-45,  45}
TokenModule.nearPos.large.Cloak     = {-45, -45}
TokenModule.nearPos.large.Jam       = { 45, -45}
TokenModule.nearPos.large.Disarm    = { 45,  45}

TokenModule.nearPos.large.rest      = {-55, -45}

-- Deduct target token position in the world for a ship, token and some entry from TokenModule.basePos or .nearPos
TokenModule.TokenPos = function(tokenName, ship, posTable)
    local baseSize = ship.getTable("Data").Size or 'small'
    local entry = posTable[baseSize].rest
    for tokenEntryName, tEntry in pairs(posTable[baseSize]) do
        if tokenName:find(tokenEntryName) ~= nil then
            entry = tEntry
        end
    end
    local tsPos = {Convert_mm_igu(entry[1]), 0.5, Convert_mm_igu(entry[2])}
    return Vect.Sum(ship.getPosition(), Vect.RotateDeg(tsPos, ship.getRotation()[2]+180))
end

-- Return position for a given token that is on the base of given ship
TokenModule.BasePosition = function(tokenName, ship)
    local name = nil
    if type(tokenName) == 'string' then
            name = tokenName
    elseif type(tokenName) == 'userdata' then
        name = tokenName.getName()
    end
    return TokenModule.TokenPos(name, ship, TokenModule.basePos)
end
-- Return position for a given token that is near the base of given ship
TokenModule.NearPosition = function(tokenName, ship)
    local name = nil
    if type(tokenName) == 'string' then
            name = tokenName
    elseif type(tokenName) == 'userdata' then
        name = tokenName.getName()
    end
    return TokenModule.TokenPos(name, ship, TokenModule.nearPos)
end

-- Return a visible position for some token near some ship
-- Priorities as follows (OK if token is still visible there as in you can see who is its owner easily):
-- 1. Prefer the position given as 3rd argument if passed
-- 2. Prefer position on a stack if a stack of tokens already belongs to a ship
-- 3. Prefer position NEAR ship base as position table dictates
-- 3. Prefer position ON ship base as position table dictates (if all else fails, this will be returned)
TokenModule.VisiblePosition = function(tokenName, ship, preferredPos)
    -- Check preferred position margin
    if preferredPos ~= nil then
        local prefInfo = TokenModule.TokenOwnerInfo(preferredPos)
        if prefInfo.owner == ship and prefInfo.margin > TokenModule.visibleMargin then
            return preferredPos
        end
    end
    -- Check for present stacks
    local currTokensInfo = TokenModule.GetShipTokensInfo(ship)
    local currStack = {qty=-2, obj=nil}
    for k,tokenInfo in pairs(currTokensInfo) do
        if tokenInfo.token.getName() == tokenName and tokenInfo.token.getQuantity() > currStack.qty and (not tokenInfo.token.IsSmoothMoving()) then
            currStack.obj = tokenInfo.token
            currStack.qty = currStack.obj.getQuantity()
        end
    end
    if currStack.obj ~= nil then
        return Vect.Sum(currStack.obj.getPosition(), {0, 0.7, 0})
    end
    -- Check for near near base position or return base position
    local nearPos = TokenModule.NearPosition(tokenName, ship)
    local nearData = TokenModule.TokenOwnerInfo(nearPos)
    if nearData.margin < TokenModule.visibleMargin then
        return TokenModule.BasePosition(tokenName, ship)
    else
        return nearPos
    end
end

-- Check which tokens belong to a ship and queue them to be moved with it
-- Needs the MoveModule.WaitForResting fired to actually use stuff from this queue
TokenModule.QueueShipTokensMove = function(ship)
    local selfTokens = TokenModule.GetShipTokens(ship)
    if selfTokens[1] == nil then
        return
    end
    -- Exclude currently used cloak tokens
    local tokensExcl = {}
    for k,token in pairs(selfTokens) do
        if token.getName() == 'Cloak' then
            local active = true
            local buttons = token.getButtons()
            if buttons ~= nil then
                for k2, but in pairs(buttons) do
                    if but.label == 'Decloak' then active = false break end
                end
            end
            if active == false then table.insert(tokensExcl, token) end
        elseif token.getVar('deleted') ~= true then
            table.insert(tokensExcl, token)
        end
    end
    selfTokens = tokensExcl
    local waitTable = {tokens = {}, ship=ship}
    -- Save relative position/rotation
    for k,token in pairs(selfTokens) do
        local relPos = Vect.RotateDeg(Vect.Between(ship.getPosition(), token.getPosition()), -1*ship.getRotation()[2])
        local relRot = token.getRotation()[2] - ship.getRotation()[2]
        table.insert(waitTable.tokens, {ref=token, relPos=relPos, relRot=relRot})
    end
    table.insert(MoveModule.tokenWaitQueue, waitTable)
end

-- Table for locks to be set and callback to trigger their naming and coloring
-- Entry: {lock=targetLockRef, color=colorToTint, name=nameToSet}
TokenModule.locksToBeSet = {}

-- Callback to set ALL the locks in wueue
function TokenModule_SetLocks()
    for k,info in pairs(TokenModule.locksToBeSet) do
        info.lock.call('manualSet', {color=info.color, name=info.name})
        info.lock.highlightOn({0,0,0}, 0.01)
    end
    TokenModule.locksToBeSet = {}
end

-- Table for locks to be set and callback to trigger their naming and coloring
-- Entry: {lock=targetLockRef, color=colorToTint, name=nameToSet}
TokenModule.tractorsToBeSet = {}

-- Callback to set ALL the locks in wueue
function TokenModule_SetTractors()
    for k,info in pairs(TokenModule.tractorsToBeSet) do
        info.tractor.call('manualSet',{ref=info.ref})
        info.tractor.highlightOn({0,0,0}, 0.01)
    end
    TokenModule.tractorsToBeSet = {}
end


-- Table for locks to be set and callback to trigger their naming and coloring
-- Entry: {lock=targetLockRef, color=colorToTint, name=nameToSet}
TokenModule.ionsToBeSet = {}

-- Callback to set ALL the locks in wueue
function TokenModule_SetIons()
    for k,info in pairs(TokenModule.ionsToBeSet) do
        info.ion.call('manualSet',{ref=info.ref})
        info.ion.highlightOn({0,0,0}, 0.01)
    end
    TokenModule.ionsToBeSet = {}
end

-- Take a token of some type and move to some position
-- Player color argument only matters when taking target locks
-- Returns ref to a newly taken token
-- Highlights the token with type-aware color
TokenModule.TakeToken = function(type, playerColor, dest)
    local takeTable = {}
    if dest ~= nil then
        takeTable.position = dest
    end
    local highlightColor = TokenModule.tokenSources[type].hlColor
    if type == 'Target Lock' then
        takeTable.callback = 'TokenModule_SetLocks'
        takeTable.callback_owner = Global
    end
    if type == 'Ion' then
        takeTable.callback = 'TokenModule_SetIons'
        takeTable.callback_owner = Global
    end
    if type == 'Tractor' then
        takeTable.callback = 'TokenModule_SetTractors'
        takeTable.callback_owner = Global
    end
    local newToken = TokenModule.tokenSources[type].src.takeObject(takeTable)
    newToken.highlightOn(highlightColor, 3)
    return newToken
end

-- Get owner info from a token or positions
-- Return:  {
--      token   <- passed token ref if arg was a token ref
--      owner   <- ship ref to owner, nil if none
--      dist    <- distance to owner (igu)
--      margin  <- how far from owner token would have to be moved to change owner
--          }
TokenModule.TokenOwnerInfo = function(tokenPos)
    local pos = nil
        local out = {token=nil, owner=nil, dist=0, margin=-1}
    if type(tokenPos) == 'table' then
        pos = tokenPos
    elseif type(tokenPos) == 'userdata' then
        out.token = tokenPos
        pos = tokenPos.getPosition()
    end
    local nearShips = ObjType.GetNearOfType(pos, TokenModule.tokenReachDistance, 'ship')
    if nearShips[1] == nil then return out end
    local baseDist = {}
    -- Take the base size into account for distances
    for k,ship in pairs(nearShips) do
        local realDist = Vect.Distance(pos, ship.getPosition())
        local size = ship.getTable("Data").Size or 'small'
        if size == 'large' then
          realDist = realDist - Convert_mm_igu(10)
        elseif size == 'medium' then
          realDist = realDist - Convert_mm_igu(5)
        end
        table.insert(baseDist, {ship=ship, dist=realDist})
    end
    local nearest = {ship=nil, dist=999}
    local nextNearest = {ship=nil, dist=999}
    for k,data in pairs(baseDist) do
        if data.dist < nearest.dist then
            nextNearest = nearest
            nearest = data
        elseif data.dist < nextNearest.dist then
            nextNearest = data
        end
    end
    out.owner = nearest.ship
    out.dist = nearest.dist
    if nextNearest.ship == nil then
        out.margin = 999
    else
        out.margin = (nextNearest.dist-nearest.dist)/2
    end
    local owner = 'nil'
    if out.owner ~= nil then
        owner = out.owner.getName()
    end
    return out
end

-- Return table of MoveModule.GetTokenInfo entries for all tokens withis some distance of given position
TokenModule.GetNearTokensInfo = function(pos, dist)
    local reachDist = TokenModule.tokenReachDistance
    if dist ~= nil then
        reachDist = dist
    end
    local nearTokens = ObjType.GetNearOfType(pos, reachDist, 'token')
    local shipTokensInfo = {}
    for k,token in pairs(nearTokens) do
        local tokenInfo = TokenModule.TokenOwnerInfo(token)
        table.insert(shipTokensInfo, tokenInfo)
    end
    return shipTokensInfo
end

TokenModule.GetShipTokenCount = function(ship, token_name)
    local count = 0;

    for _, tokenInfo in pairs(TokenModule.GetShipTokensInfo(ship)) do
        if tokenInfo.token.getName() == token_name and tokenInfo.token.getVar('deleted') == nil then
            local quantity = tokenInfo.token.getQuantity()
            if quantity < 0 then
                quantity = 1
            end
            count = count + quantity
        end
    end

    return count
end

-- Return table of MoveModule.GetTokenInfo enties for all tokens that are owned by given ship
TokenModule.GetShipTokensInfo = function(ship)
    -- Check for nearby tokens
    local nearTokens = ObjType.GetNearOfType(ship.getPosition(), TokenModule.tokenReachDistance, 'token')
    local shipTokensInfo = {}
    for k,token in pairs(nearTokens) do
        local tokenInfo = TokenModule.TokenOwnerInfo(token)
        if tokenInfo.owner == ship then
            table.insert(shipTokensInfo, tokenInfo)
        end
    end
    return shipTokensInfo
end

-- Return table of object references for all tokens that are owned by given ship
TokenModule.GetShipTokens = function(ship)
    -- Check for nearby tokens
    local shipTokensInfo = TokenModule.GetShipTokensInfo(ship)
    local tokens = {}
    for k,tokenInfo in pairs(shipTokensInfo) do
        table.insert(tokens, tokenInfo.token)
    end
    return tokens
end

-- Clear given distance within position from tokens
-- If given third argument, this hip tokens will be ignored
-- Tokens that have an owner will be moved near(er)/on it
-- Stray tokens will be yanked away
TokenModule.ClearPosition = function(pos, dist, ignoreShip)
    local clearDist = dist + Convert_mm_igu(20)
    local posTokenInfo = TokenModule.GetNearTokensInfo(pos, clearDist)
    for k,tokenInfo in pairs(posTokenInfo) do
        if tokenInfo.token.getButtons() == nil then
            if tokenInfo.owner ~= nil and tokenInfo.owner ~= ignoreShip then
                local visPos = TokenModule.VisiblePosition(tokenInfo.token.getName(), tokenInfo.owner)
                if Vect.Distance(visPos, pos) <= clearDist then
                    local basePos = TokenModule.BasePosition(tokenInfo.token.getName(), tokenInfo.owner)
                    tokenInfo.token.setPositionSmooth(basePos)
                else
                    tokenInfo.token.setPositionSmooth(visPos)
                end
            else
                local ptVect = Vect.Between(pos, tokenInfo.token.getPosition())
                ptVect[2] = 0
                local actDist = Vect.Distance(tokenInfo.token.getPosition(), pos)
                local distToMove = 2*clearDist - actDist
                local targetPos = Vect.Sum(tokenInfo.token.getPosition(), Vect.SetLength(ptVect, distToMove))
                targetPos[2] = targetPos[2] + 0.5
                tokenInfo.token.setPositionSmooth(targetPos)
            end
        end
    end
end

-- END TOKEN MODULE
--------


function proxyPerformAction(table)
    ship = table[1]
    actionType = table[2]
    playerColor = table[3]
    DialModule.PerformAction(ship, actionType, playerColor)
end

DialModule = {}
-- Perform an automated action
-- Can be called externally for stuff like range ruler spawning
DialModule.PerformAction = function(ship, type, playerColor)
    local tokenActions = ' Focus Calculate Evade Stress Strain Target Lock Ion Cloak Jam Reinforce Disarm Tractor Dummy '
    announceInfo = {type='action'}
    -- Ruler spawning
    if type:find('ruler') ~= nil then
        local scPos = type:find(':')
        local rulerCode = type:sub(scPos+1,-1)
        RulerModule.ToggleRuler(ship, rulerCode)
        return
    elseif type:find('spawnMoveTemplate') ~= nil then
        if DialModule.DeleteTemplate(ship) == false then
            local scPos = type:find(':')
            local dialCode = type:sub(scPos+1,-1)
            if DialModule.SpawnTemplate(ship, dialCode) ~= nil then
                announceInfo.note = 'spawned a move template'
            else
                announceInfo.note = 'looks at you weird'
            end
        else
            return
        end
    elseif type:find('deleteMoveTemplate') ~= nil then
      DialModule.DeleteTemplate(ship)
      return
    elseif type == 'unstress' then
        local stressInfo = {token=nil, dist=-1}
        for k,tokenInfo in pairs(TokenModule.GetShipTokensInfo(ship)) do
            if tokenInfo.token.getName() == 'Stress' and tokenInfo.dist > stressInfo.dist and tokenInfo.token.getVar('deleted') == nil then
                stressInfo.token = tokenInfo.token
            end
        end
        if stressInfo.token == nil then
            announceInfo.note = 'tried to shed a stress but doesn\'t have any'
        else
            announceInfo.note = 'sheds a stress token'
            if stressInfo.token.getQuantity() > 0 then
                stressInfo.token = stressInfo.token.takeObject({})
            end
            stressInfo.token.highlightOn({0, 0.7, 0}, 3)
            stressInfo.token.setPositionSmooth(Vect.Sum(TokenModule.tokenSources.Stress.src.getPosition(), {0, 2, 0}))
            stressInfo.token.setVar('deleted', true)
        end
    elseif type == 'unstrain' then
        local strainInfo = {token=nil, dist=-1}
        for k,tokenInfo in pairs(TokenModule.GetShipTokensInfo(ship)) do
            if tokenInfo.token.getName() == 'Strain' and tokenInfo.dist > strainInfo.dist and tokenInfo.token.getVar('deleted') == nil then
                strainInfo.token = tokenInfo.token
            end
        end
        if strainInfo.token == nil then
            announceInfo.note = 'tried to shed a strain but doesn\'t have any'
        else
            announceInfo.note = 'sheds a strain token'
            if strainInfo.token.getQuantity() > 0 then
                strainInfo.token = strainInfo.token.takeObject({})
            end
            strainInfo.token.highlightOn({0, 0.7, 0}, 3)
            strainInfo.token.setPositionSmooth(Vect.Sum(TokenModule.tokenSources.Strain.src.getPosition(), {0, 2, 0}))
            strainInfo.token.setVar('deleted', true)
        end
    elseif type == 'union' then
        local ionised = false
        for k,tokenInfo in pairs(TokenModule.GetShipTokensInfo(ship)) do
            if tokenInfo.token.getName() == 'Ion' and tokenInfo.token.getVar('deleted') == nil then
                ionised = true
                tokenInfo.token.highlightOn({0, 0.7, 0}, 3)
                tokenInfo.token.setPositionSmooth(Vect.Sum(TokenModule.tokenSources.Ion.src.getPosition(), {0, 2, 0}))
                tokenInfo.token.setVar('deleted', true)
            end
        end
        if ionised then
            announceInfo.note = 'sheds all ion tokens'
        else
            announceInfo.note = 'tried to shed ion but doesn\'t have any'
        end
    elseif tokenActions:find(' ' .. type .. ' ') ~= nil then
        local dest = TokenModule.VisiblePosition(type, ship)
        local newToken = TokenModule.TakeToken(type, playerColor, dest)
        if type == 'Target Lock' then
            table.insert(TokenModule.locksToBeSet, {lock=newToken, name=ship.getName(), color=playerColor})
            announceInfo.note = 'acquired a target lock'
        elseif type == 'Ion' then
            table.insert(TokenModule.ionsToBeSet, {ion=newToken, ref=ship})
            announceInfo.note = 'takes an ion token'
        elseif type == 'Tractor' then
            table.insert(TokenModule.tractorsToBeSet, {tractor=newToken, ref=ship})
            announceInfo.note = 'takes a tractor token'
        else
            if type == 'Evade' then
                announceInfo.note = 'takes an evade token'
            elseif type == 'Ion' then
                announceInfo.note = 'takes an ion token'
            else
                announceInfo.note = 'takes a ' .. string.lower(type) .. ' token'
            end
        end
    end
    AnnModule.Announce(announceInfo, 'all', ship)
end

-- Spawned tempaltes are kept there
-- Entry: {ship=shipRef, template=templateObjRef}
DialModule.SpawnedTemplates = {}

-- Position data for template spawning
-- "Trim" entries are to fine-tune the position
-- (its quite rough by the numbers since their origin was not perfectly at the center)
DialModule.TemplateData = {}
DialModule.TemplateData.straight = {}
DialModule.TemplateData.straight[1] = {0, -2.5, 20, 0}
DialModule.TemplateData.straight[2] = {0, -2.5, 40, 0}
DialModule.TemplateData.straight[3] = {0, -2.5, 60, 0}
DialModule.TemplateData.straight[4] = {0, -2.5, 80, 0}
DialModule.TemplateData.straight[5] = {0, -2.5, 100, 0}
DialModule.TemplateData.bank = {}
DialModule.TemplateData.bank.leftRot = 45
DialModule.TemplateData.bank.trim = { left = {{-2,0,-4,0}, {-5.5,0,-5.2,0}, {-9.3,0,-6.45,0}}, right={{4.2,0,1.2,0}, {7.8,0,-0.3,0}, {11.5,0,-1.4,0}} }
DialModule.TemplateData.bank[1] = {80*(1-math.cos(math.pi/8)), 0, 80*math.sin(math.pi/8), 180}
DialModule.TemplateData.bank[2] = {130*(1-math.cos(math.pi/8)), 0, 130*math.sin(math.pi/8), 180}
DialModule.TemplateData.bank[3] = {180*(1-math.cos(math.pi/8)), 0, 180*math.sin(math.pi/8), 180}
DialModule.TemplateData.turn = {}
DialModule.TemplateData.turn.leftRot = 90
DialModule.TemplateData.turn.trim = { left = {{0,-2.5,0,0}, {-3,-2.5,-3.66,0}, {-4.7,-2.5,-7.5,0}}, right={{0,-2.5,0,0}, {3,-2.5,-4.1,0}, {4.5,-2.5,-7.8,0}} }
DialModule.TemplateData.turn[1] = {35*(1-math.cos(math.pi/4))+2, 0, 35*math.sin(math.pi/4)-2, 180}
DialModule.TemplateData.turn[2] = {62.5*(1-math.cos(math.pi/4))+5, 0, 62.5*math.sin(math.pi/4)-4, 180}
DialModule.TemplateData.turn[3] = {90*(1-math.cos(math.pi/4))+9, 0, 90*math.sin(math.pi/4)-6, 180}
DialModule.TemplateData.talon = {}
DialModule.TemplateData.talon.leftRot = 90
DialModule.TemplateData.talon.trim = { left = {{0,-2.5,0,0}, {-3,-2.5,-3.66,0}, {-4.7,-2.5,-7.5,0}}, right={{0,-2.5,0,0}, {3,-2.5,-4.1,0}, {4.5,-2.5,-7.8,0}} }
DialModule.TemplateData.talon[1] = {35*(1-math.cos(math.pi/4))+2, 0, 35*math.sin(math.pi/4)-2, 180}
DialModule.TemplateData.talon[2] = {62.5*(1-math.cos(math.pi/4))+5, 0, 62.5*math.sin(math.pi/4)-4, 180}
DialModule.TemplateData.talon[3] = {90*(1-math.cos(math.pi/4))+9, 0, 90*math.sin(math.pi/4)-6, 180}

DialModule.TemplateData.baseOffset = {}
DialModule.TemplateData.baseOffset.small = {0, 0, 20, 0}
DialModule.TemplateData.baseOffset.medium = {0, 0, 30, 0}
DialModule.TemplateData.baseOffset.large = {0, 0, 40, 0}

-- Spawn a tempalte on given ship
-- dialCode is move code PLUS identifier if ship already did it or not
-- be3_A means "spawn a bank left 3 template behind me" (A as in after move)
-- tr1_B means "spawn a turn right 1 tempalte in front of me" (B as in before move)
-- Return template reference
-- TODO toggletemplate?
DialModule.SpawnTemplate = function(ship, dialCode)

    local moveCode = dialCode:sub(1, -3)
    local moveInfo = MoveData.DecodeInfo(moveCode, ship)
    --if moveInfo.speed == 0 then
    --    return nil
    --end
    local tempEntry = DialModule.TemplateData[moveInfo.type][moveInfo.speed]
    local baseSize = ship.getTable("Data").Size or 'small'
    tempEntry = Vect.Sum(tempEntry, DialModule.TemplateData.baseOffset[baseSize])
    local ref = ship
    if dialCode:sub(-1,-1) == 'A' then
        ref = MoveModule.GetOldMove(ship, 1)
    end
    --TODO LAST MOVE LOGIC OUT!!!
    --TODO dont barf if no last move
    if moveInfo.dir == 'left' then
        tempEntry = MoveData.LeftVariant(tempEntry)
        tempEntry[4] = tempEntry[4] + 180 - DialModule.TemplateData[moveInfo.type].leftRot
    end
    if moveInfo.extra == 'reverse' then
        tempEntry = MoveData.ReverseVariant(tempEntry)
        if moveInfo.type ~= 'straight' then
            tempEntry[4] = tempEntry[4] - DialModule.TemplateData[moveInfo.type].leftRot
        end
    end
    if moveInfo.dir ~= nil then
        if moveInfo.extra ~= 'reverse' then
            tempEntry = Vect.Sum(tempEntry, DialModule.TemplateData[moveInfo.type].trim[moveInfo.dir][moveInfo.speed])
        else
            if moveInfo.dir == 'right' then
                moveInfo.dir = 'left'
            elseif moveInfo.dir == 'left' then
                moveInfo.dir = 'right'
            end
            tempEntry = Vect.Sum(tempEntry, Vect.ScaleEach(DialModule.TemplateData[moveInfo.type].trim[moveInfo.dir][moveInfo.speed], {-1, 1, -1, -1}))
        end
    end

    local finPos = MoveModule.EntryToPos(tempEntry, ref)
    local src = TokenModule.tokenSources[moveInfo.type:sub(1,1) .. moveInfo.speed]
    local newTemplate = src.takeObject({position=finPos.pos, rotation=finPos.rot})
    newTemplate.lock()
    newTemplate.setPosition(finPos.pos)
    newTemplate.setRotation(finPos.rot)
    table.insert(DialModule.SpawnedTemplates, {template=newTemplate, ship=ship})
    return newTemplate
end

-- Delete template spawned for a ship, return true if deleted, false if there was none
DialModule.DeleteTemplate = function(ship)
    for k,info in pairs(DialModule.SpawnedTemplates) do
        if info.ship == ship then
            if info.template ~= nil then
                info.template.destruct()
            end
            table.remove(DialModule.SpawnedTemplates, k)
            return true
        end
    end
    return false
end



-- Char width table by Indimeco
StringLen = {}
StringLen.charWidthTable = {
        ['`'] = 2381, ['~'] = 2381, ['1'] = 1724, ['!'] = 1493, ['2'] = 2381,
        ['@'] = 4348, ['3'] = 2381, ['#'] = 3030, ['4'] = 2564, ['$'] = 2381,
        ['5'] = 2381, ['%'] = 3846, ['6'] = 2564, ['^'] = 2564, ['7'] = 2174,
        ['&'] = 2777, ['8'] = 2564, ['*'] = 2174, ['9'] = 2564, ['('] = 1724,
        ['0'] = 2564, [')'] = 1724, ['-'] = 1724, ['_'] = 2381, ['='] = 2381,
        ['+'] = 2381, ['q'] = 2564, ['Q'] = 3226, ['w'] = 3704, ['W'] = 4167,
        ['e'] = 2174, ['E'] = 2381, ['r'] = 1724, ['R'] = 2777, ['t'] = 1724,
        ['T'] = 2381, ['y'] = 2564, ['Y'] = 2564, ['u'] = 2564, ['U'] = 3030,
        ['i'] = 1282, ['I'] = 1282, ['o'] = 2381, ['O'] = 3226, ['p'] = 2564,
        ['P'] = 2564, ['['] = 1724, ['{'] = 1724, [']'] = 1724, ['}'] = 1724,
        ['|'] = 1493, ['\\'] = 1923, ['a'] = 2564, ['A'] = 2777, ['s'] = 1923,
        ['S'] = 2381, ['d'] = 2564, ['D'] = 3030, ['f'] = 1724, ['F'] = 2381,
        ['g'] = 2564, ['G'] = 2777, ['h'] = 2564, ['H'] = 3030, ['j'] = 1075,
        ['J'] = 1282, ['k'] = 2381, ['K'] = 2777, ['l'] = 1282, ['L'] = 2174,
        [';'] = 1282, [':'] = 1282, ['\''] = 855, ['"'] = 1724, ['z'] = 1923,
        ['Z'] = 2564, ['x'] = 2381, ['X'] = 2777, ['c'] = 1923, ['C'] = 2564,
        ['v'] = 2564, ['V'] = 2777, ['b'] = 2564, ['B'] = 2564, ['n'] = 2564,
        ['N'] = 3226, ['m'] = 3846, ['M'] = 3846, [','] = 1282, ['<'] = 2174,
        ['.'] = 1282, ['>'] = 2174, ['/'] = 1923, ['?'] = 2174, [' '] = 1282,
        ['avg'] = 2500
    }

-- Get real string lenght per char table
StringLen.GetStringLength = function(str)
    local len = 0
    for i = 1, #str do
        local c = str:sub(i,i)
        if StringLen.charWidthTable[c] ~= nil then
            len = len + StringLen.charWidthTable[c]
        else
            len = len + StringLen.charWidthTable.avg
        end
    end
    return len
end

-- Get a short name for some ship
-- Avoid user-added LGS
-- Avoid name prepositions as in ambigNames
-- Avoid too short or long names
-- Add a single number/char on the end if there is one on the ship
DialModule.GetShortName = function(ship)
    local shipNameWords = {}
    local numWords = 0
    local ambigNames = 'The Captain Colonel Cartel Lieutenant Commander Old'
    local shipName = ship.getName()
    shipName = shipName:gsub('LGS', '')             -- Delete LGS
    shipName = shipName:match( "^%s*(.-)%s*$" )     -- Trim whitespaces
    -- Fill words table
    for word in shipName:gmatch('[\'\"%-%w]+') do
        table.insert(shipNameWords, word)
    end
    -- Delete first word if ambiguous and there's more
    if ambigNames:find(shipNameWords[1]) ~= nil and #shipNameWords > 1 then
        table.remove(shipNameWords, 1)
    end
    -- Fucntion for checking if "short name"
    local function sizeJustRight(str)
        if str == nil then
            return false
        end
        return ( (str:len() < 10) --[[and (str:len() > 3)]] )
    end
    -- Delete the first word if too short/long and next is better
    if ( not sizeJustRight(shipNameWords[1]) ) and ( sizeJustRight(shipNameWords[2]) ) then
        table.remove(shipNameWords, 1)
    end
    -- Take the resulting first "valid" word
    local shortName = shipNameWords[1]
    -- If there were apostrophes and they are asymmetrical now, trim them
    if ( (string.find('\'\"', shortName:sub(1,1)) ~= nil) or (string.find('\'\"', shortName:sub(-1,-1)) ~= nil) ) and ( shortName:sub(1,1) ~= shortName:sub(-1,-1) ) then
        shortName = shortName:gsub('\'', '')
        shortName = shortName:gsub('\"', '')
    end
    if shipNameWords[#shipNameWords]:len() == 1 then
        shortName = shortName .. ' ' .. shipNameWords[#shipNameWords]
    end
    return shortName
end

-- END AUTO DIALS MODULE
--------

--------
-- RULERS MODULE

-- Since there are many ruler types (models) and commands, this takes carre of all ruler-related handling
-- TO_DO: ActionModule and include it there

RulerModule = {}

-- Table of existing spawned rulers
-- Entry: {ship=shipRef, tuler=rulerRef, type=rulerTypeCode}
RulerModule.spawnedRulers = {}
-- Click function for ruler button (destroy)
function Ruler_SelfDestruct(obj)
    for k, rTable in pairs(RulerModule.spawnedRulers) do
        if rTable.ruler == obj then
            table.remove(RulerModule.spawnedRulers, k)
            break
        end
    end
    obj.destruct()
end
-- Remove appropriate entry if ruler is destroyed
RulerModule.onObjectDestroyed = function(obj)
    for k,info in pairs(RulerModule.spawnedRulers) do
        if info.ship == obj or info.ruler == obj then
            if info.ship == obj then info.ruler.destruct() end
            table.remove(RulerModule.spawnedRulers, k)
            break
        end
    end
end

-- RULER MESHES DATABASE
RulerModule.meshes = {}
RulerModule.meshes.smallBase = {}
RulerModule.meshes.smallBase.scale = {0.629, 0.629, 0.629}
RulerModule.meshes.smallBase.diffuse = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/arctexture.png'
RulerModule.meshes.smallBase.collider = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/colliders/Small_base_Collider.obj'
RulerModule.meshes.smallBase.front = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/small_front.obj'
RulerModule.meshes.smallBase.rear = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/small_back.obj'
RulerModule.meshes.smallBase.sideArc = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/small_side_4.obj'
RulerModule.meshes.smallBase.range = {}
RulerModule.meshes.smallBase.range[1] = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/small_range_1.obj'
RulerModule.meshes.smallBase.range[2] = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/small_range_2.obj'
RulerModule.meshes.smallBase.range[3] = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/small_range_3.obj'
RulerModule.meshes.smallBase.range[4] = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/small_range_4.obj'

-- Ruler meshes for medium base JC
RulerModule.meshes.mediumBase = {}
RulerModule.meshes.mediumBase.scale = {0.629, 0.629, 0.629}
RulerModule.meshes.mediumBase.diffuse = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/arctexture.png'
RulerModule.meshes.mediumBase.collider = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/colliders/Medium_base_Collider.obj'
RulerModule.meshes.mediumBase.front = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/medium_front.obj'
RulerModule.meshes.mediumBase.rear = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/medium_back.obj'
RulerModule.meshes.mediumBase.sideArc = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/medium_side_4.obj'
RulerModule.meshes.mediumBase.range = {}
RulerModule.meshes.mediumBase.range[1] = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/medium_range_1.obj'
RulerModule.meshes.mediumBase.range[2] = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/medium_range_2.obj'
RulerModule.meshes.mediumBase.range[3] = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/medium_range_3.obj'
RulerModule.meshes.mediumBase.range[4] = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/medium_range_4.obj'


RulerModule.meshes.largeBase = {}
RulerModule.meshes.largeBase.scale = {0.629, 0.629, 0.629}
RulerModule.meshes.largeBase.diffuse = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/arctexture.png'
RulerModule.meshes.largeBase.collider = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/colliders/Large_base_Collider.obj'
RulerModule.meshes.largeBase.front = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/large_front.obj'
RulerModule.meshes.largeBase.rear = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/large_back.obj'
RulerModule.meshes.largeBase.sideArc = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/large_side_4.obj'
RulerModule.meshes.largeBase.range = {}
RulerModule.meshes.largeBase.range[1] = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/large_range_1.obj'
RulerModule.meshes.largeBase.range[2] = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/large_range_2.obj'
RulerModule.meshes.largeBase.range[3] = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/large_range_3.obj'
RulerModule.meshes.largeBase.range[4] = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/large_range_4.obj'

RulerModule.meshes.hugeBase = {}
RulerModule.meshes.hugeBase.scale = {0.629, 0.629, 0.629}
RulerModule.meshes.hugeBase.diffuse = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/arctexture.png'
RulerModule.meshes.hugeBase.collider = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/colliders/Huge_base_Collider.obj'
RulerModule.meshes.hugeBase.front = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/huge_front.obj'
RulerModule.meshes.hugeBase.rear = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/huge_back.obj'
RulerModule.meshes.hugeBase.sideArc = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/huge_side_4.obj'
RulerModule.meshes.hugeBase.range = {}
RulerModule.meshes.hugeBase.range[1] = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/huge_range_1.obj'
RulerModule.meshes.hugeBase.range[2] = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/huge_range_2.obj'
RulerModule.meshes.hugeBase.range[3] = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/huge_range_3.obj'
RulerModule.meshes.hugeBase.range[4] = '{verifycache}https://raw.githubusercontent.com/eirikmun/TTS_X-Wing2.0/hugeships/assets/Items/arcranges/new/huge_range_4.obj'


-- Avaialble ruler codes:
-- R            - 1-3 range rings
-- R1/R2/R3     - 1/2/3 range rings
-- A            - contextual arc
-- AA           - full ruler
-- AP           - primary arc
-- AS           - side arc
-- AR           - rear arc
-- AT           - turret arc
-- AM           - mobile arc
XW_cmd.AddCommand('r[1-3]?', 'rulerHandle')     -- Range "rings"
XW_cmd.AddCommand('[fbs][lrs]?', 'rulerHandle')  -- Rulers with arc lines

-- Translate ruler code to a mesh entry
RulerModule.typeToKey = {}
RulerModule.typeToKey['F'] = 'front'
RulerModule.typeToKey['FS'] = 'side'
RulerModule.typeToKey['B'] = 'rear'
RulerModule.typeToKey['R'] = 'range'
RulerModule.typeToKey['SL'] = 'sideArc'
RulerModule.typeToKey['SR'] = 'sideArc'

-- Get ruler spawn tables for some ship and some ruler code
-- Return table with "mesh", "collider" and "scale" keys
--  (for appropriate ruler)
RulerModule.GetRulerData = function(ship, rulerType)
    local baseSize = ship.getTable("Data").Size or 'small'
    local out = {mesh = nil, collider = nil, scale = nil}
    if rulerType:sub(1,1) == 'R' then
        rKey = tonumber(rulerType:sub(2,2))
        if rKey == nil then
            rKey = 4
        end
        out.mesh = RulerModule.meshes[baseSize .. 'Base'].range[rKey]
    else
        local key = RulerModule.typeToKey[rulerType]
        out.mesh = RulerModule.meshes[baseSize .. 'Base'][key]
    end
    out.scale = RulerModule.meshes[baseSize .. 'Base'].scale
    out.collider = RulerModule.meshes[baseSize .. 'Base'].collider
    out.diffuse = RulerModule.meshes[baseSize .. 'Base'].diffuse
    out.material = 3
    return out
end

-- Return a descriptive arc name of command (for announcements)
RulerModule.DescriptiveName = function(ship, rulerType)
    if rulerType:sub(1,1) == 'R' then
        ranges = rulerType:sub(2,2)
        if ranges == '' then
            ranges = '1-3'
        end
        return 'range ' .. ranges .. ' ruler'
    else
        if rulerType == 'A' then
            rulerType = rulerType .. RulerModule.DefaultShipArc(ship)
        end
        local arcName = RulerModule.typeToKey[rulerType]
        return arcName .. ' arc ruler'
    end
end

-- Get the default ship arc type code
-- e.g. whip with just primary arc will return code for priamry arc spawn
RulerModule.DefaultShipArc = function(ship)
    return 'A' --Todo Remove this
end

-- Create tables for spawning a ruler
-- Return:  {
--      params      <- table suitable for spawnObject(params) call
--      custom      <- table suitable for obj.setCustomObject(custom) call
--          }
RulerModule.CreateCustomTables = function(ship, rulerType)
    if rulerType == 'A' then
        rulerType = rulerType .. RulerModule.DefaultShipArc(ship)
    end
    local rulerData = RulerModule.GetRulerData(ship, rulerType)
    local paramsTable = {}
    paramsTable.type = 'Custom_Model'
    paramsTable.position = ship.getPosition()
    paramsTable.rotation = {0, ship.getRotation()[2], 0}
    if rulerType == 'SR' then
        rot = ship.getRotation()[2]
        paramsTable.rotation= {0, rot + 180, 0}
    end

    paramsTable.scale = rulerData.scale
    local customTable = {}

    customTable.mesh = rulerData.mesh
    customTable.collider = rulerData.collider
    customTable.diffuse = rulerData.diffuse
    return {params = paramsTable, custom = customTable}
end

-- Spawn a ruler for a ship
-- Returns new ruler reference
RulerModule.SpawnRuler = function(ship, rulerType, beQuiet)
    local rulerData = RulerModule.CreateCustomTables(ship, rulerType)
    local newRuler = spawnObject(rulerData.params)
    newRuler.setCustomObject(rulerData.custom)
    newRuler.setColorTint(color(1.0, 0.0, 0.0, 0.3))
    table.insert(RulerModule.spawnedRulers, {ship = ship, ruler = newRuler, type = rulerType})
    newRuler.lock()
    newRuler.setScale(rulerData.params.scale)
    local button = {click_function = 'Ruler_SelfDestruct', label = 'DEL', position = {0, 0.5, 0}, rotation =  {0, 0, 0}, width = 900, height = 900, font_size = 250}
    newRuler.createButton(button)
    return newRuler
end

-- Delete existing ruler for a ship
-- Return deleted ruler type or nil if there was none
RulerModule.DeleteRuler = function(ship)
    for k,rTable in pairs(RulerModule.spawnedRulers) do
        if rTable.ship == ship then
            rTable.ruler.destruct()
            local destType = rTable.type
            table.remove(RulerModule.spawnedRulers, k)
            return destType
        end
    end
    return nil
end

-- Toggle ruler for a ship
-- If a ruler of queried type exists, just delete it and return nil
-- If any other ruler exists, delete it (and spawn queried one), return new ruler ref
RulerModule.ToggleRuler = function(ship, rulerType, beQuiet)
    local destType = RulerModule.DeleteRuler(ship)
    if destType ~= rulerType then
        if beQuiet ~= true then
            local annInfo = {type='action'}
            annInfo.note = 'spawned a ' .. RulerModule.DescriptiveName(ship, rulerType) .. ' (' .. rulerType .. ')'
            AnnModule.Announce(annInfo, 'all', ship)
        end
        return RulerModule.SpawnRuler(ship, rulerType, beQuiet)
    end
end

-- END RULERS MODULE
--------

--------
-- BOMB MODULE

-- Allows for creating "bomb drops" that snap bomb tokens to position

BombModule = {}

-- Delete button for the spawned template
BombModule.deleteButton = {click_function = 'BombDrop_SelfDestruct', label = 'Cancel', position = {0, 0.1, 0}, rotation =  {0, 0, 0}, scale = {0.1, 0.1, 0.1}, width = 2000, height = 900, font_size = 400}
function BombDrop_SelfDestruct(temp)
    BombModule.DeleteDrop(temp)
end

BombModule.dropTable = {}

XW_cmd.AddCommand('b:s[1-5][r]?', 'bombDrop')
XW_cmd.AddCommand('b:b[rle][1-3][r]?', 'bombDrop')
XW_cmd.AddCommand('b:t[rle][1-3][r]?', 'bombDrop')

-- Spawn a bomb drop, delete old ones
-- If that exact one existed, just delete
BombModule.ToggleDrop = function(ship, dropCode)
    if BombModule.DeleteDrop(ship) ~= dropCode then
        BombModule.SpawnDrop(ship, dropCode)
    end
end

-- Create a bomb drop with a template
BombModule.SpawnDrop = function(ship, dropCode)
    local scPos = dropCode:find(':')
    local templateCode = dropCode:sub(scPos+1,-1)
    DialModule.DeleteTemplate(ship)
    local dropPos = nil
    local temp = nil
    if dropCode:sub(-1, -1) == 'r' then
        -- FRONT drops
        temp = DialModule.SpawnTemplate(ship, templateCode:sub(1, -2) .. '_B')
        temp.createButton(BombModule.deleteButton)
        dropPos = MoveModule.GetFinalPosData(templateCode:sub(1, -2), ship, true)
        dropPos.finPos.rot[2] = dropPos.finPos.rot[2] - 180
    else
        -- BACK drops
        temp = DialModule.SpawnTemplate(ship, templateCode .. 'r_B')
        temp.createButton(BombModule.deleteButton)
        dropPos = MoveModule.GetFinalPosData(templateCode .. 'r', ship, true)
    end
    if dropPos == nil or temp == nil then return end
    table.insert(BombModule.dropTable, {ship=ship, temp=temp, code=dropCode, dest=dropPos.finPos})
end

-- Delete existing drop, return deleted code or nil if there was none
BombModule.DeleteDrop = function(temp_ship)
    local newTable = {}
    local deleteCode = nil
    for k,dTable in pairs(BombModule.dropTable) do
        if dTable.ship == temp_ship or dTable.temp == temp_ship then
            deleteCode = dTable.code
            DialModule.DeleteTemplate(dTable.ship)
        else
            table.insert(newTable, dTable)
        end
    end
    BombModule.dropTable = newTable
    return deleteCode
end

-- Delete drops on ship/template delete
BombModule.onObjectDestroyed = function(obj)
    for k,dTable in pairs(BombModule.dropTable) do
        if dTable.ship == obj or dTable.temp == obj then
            BombModule.DeleteDrop(obj)
        end
    end
end

-- Bomb type -> offset data
BombModule.tokenOffset = {}
BombModule.tokenOffset.standardAoE = {pos={0, Convert_mm_igu(-2), Convert_mm_igu(-4.5)}, rot={0, 90, 0}}
BombModule.tokenOffset.prox = {pos={0, Convert_mm_igu(-2), Convert_mm_igu(15)}, rot={0, 90, 0}}
BombModule.tokenOffset.cluster = {pos={0, Convert_mm_igu(-2), 0}, rot={0, 180, 0}}
BombModule.tokenOffset.connor = {pos={0, Convert_mm_igu(-2), Convert_mm_igu(21)}, rot={0, 180, 0}}
BombModule.tokenOffset.rgc = {pos={0, Convert_mm_igu(-1), Convert_mm_igu(9.5)}, rot={0, 0, 0}}

-- Bomb name -> type data
BombModule.snapTable = {}
BombModule.snapTable['Ion Bomb'] = 'standardAoE'
BombModule.snapTable['Proton Bomb'] = 'standardAoE'
BombModule.snapTable['Seismic Charge'] = 'standardAoE'
BombModule.snapTable['Thermal Detonator'] = 'standardAoE'
BombModule.snapTable['Bomblet'] = 'standardAoE'
BombModule.snapTable['Proximity Mine'] = 'prox'
BombModule.snapTable['Cluster Mine (middle)'] = 'cluster'
BombModule.snapTable['Connor Net'] = 'connor'
BombModule.snapTable['Rigged Cargo Chute debris'] = 'rgc'

-- Minimum distance to snap
BombModule.snapDist = 1.5
-- Snap on drop
BombModule.OnTokenDrop = function(token)
    -- Get the offset data
    local offset = BombModule.tokenOffset[BombModule.snapTable[token.getName()]]

    -- Deduct closest bomb drop point within snap distance
    local closest = {dist=BombModule.snapDist+1, pointKey=nil}
    local tPos = token.getPosition()
    for k,dTable in pairs(BombModule.dropTable) do
        local newDist = Vect.Distance(tPos, dTable.dest.pos)
        if newDist < closest.dist then
            closest.dist = newDist
            closest.pointKey = k
            closest.temp = dTable.temp
        end
    end

    -- If there was one
    if closest.pointKey ~= nil then
        -- Move the token to the snap points
        local drop = BombModule.dropTable[closest.pointKey]
        local destPos = Vect.Sum(drop.dest.pos, Vect.RotateDeg(offset.pos, drop.dest.rot[2]))
        local size = drop.ship.getTable("Data").Size or 'small'
        if size == 'large' then
            destPos = Vect.Sum(destPos, Vect.RotateDeg({0, 0, Convert_mm_igu(-20)}, drop.dest.rot[2]))
        elseif size == 'medium' then
            destPos = Vect.Sum(destPos, Vect.RotateDeg({0, 0, Convert_mm_igu(-10)}, drop.dest.rot[2]))
        end
        local destRot = Vect.Sum(drop.dest.rot, offset.rot)
        destPos[2] = drop.ship.getPosition()[2] + offset.pos[2]
        token.lock()
        token.setPositionSmooth(destPos, false, true)
        token.setRotationSmooth(destRot, false, true)
        XW_cmd.SetBusy(token)
        MoveModule.WaitForResting(token, {pos=destPos, rot=destRot})
        -- Expand clusters
        if token.getName() == 'Cluster Mine (middle)' then
            BombModule.ExpandCluster({pos=destPos, rot=destRot})
        end
        AnnModule.Announce({type='action', note=drop.ship.getName() .. ' dropped a ' .. token.getName():gsub('%(middle%)', 'set')}, 'all')
        closest.temp.destruct()
        return true
    else
        return false
    end
end

-- Spawn side tokens for cluster mine
BombModule.ExpandCluster = function(center)
    local offset = {Convert_mm_igu(43.5), 0, Convert_mm_igu(-1.5)}
    local tParams = {type='Custom_Token'}
    local tCustom = {image='{verifycache}http://i.imgur.com/MqlYZzR.png', thickness=0.1, merge_distance=5}

    local t1 = spawnObject(tParams)
    t1.setCustomObject(tCustom)
    t1.lock()
    local destOffset1 = Vect.RotateDeg(offset, center.rot[2])
    t1.setPosition(Vect.Sum(center.pos, destOffset1))
    t1.setRotation(center.rot)
    t1.setScale({0.4554, 0.4554, 0.4554})
    t1.setName('Cluster Mine (side)')

    local t2 = spawnObject(tParams)
    t2.setCustomObject(tCustom)
    t2.lock()
    local destOffset2 = Vect.RotateDeg(Vect.ScaleEach(offset, {-1, 1, 1}), center.rot[2])
    t2.setPosition(Vect.Sum(center.pos, destOffset2))
    t2.setRotation(center.rot)
    t2.setScale({0.4554, 0.4554, 0.4554})
    t2.setName('Cluster Mine (side)')
end

-- END BOMB MODULE
--------

--------
-- ANNOUNCEMENTS MODULE

-- For writing out stuff in chat

AnnModule = {}

-- COLOR CONFIGURATION FOR ANNOUNCEMENTS
AnnModule.announceColor = {}
AnnModule.announceColor.moveClear = {0.1, 1, 0.1}     -- Green
AnnModule.announceColor.moveCollision = {1, 0.7, 0.1} -- Orange
AnnModule.announceColor.action = {0.3, 0.3, 1}        -- Blue
AnnModule.announceColor.historyHandle = {0.1, 1, 1}   -- Cyan
AnnModule.announceColor.error = {1, 0.15, 0.15}       -- Red
AnnModule.announceColor.warn = {1, 0.4, 0}            -- Red - orange
AnnModule.announceColor.info = {0.8, 0.1, 0.8}        -- Purple

-- Notify color or all players of some event
-- announceInfo: {type=typeOfEvent, note=notificationString}
AnnModule.Announce = function(info, target, shipPrefix)
    local annString = ''
    local annColor = {1, 1, 1}
    local shipName = ''

    if shipPrefix ~= nil then
        if type(shipPrefix) == 'string' then
            shipName = shipPrefix .. ' '
        elseif type(shipPrefix) == 'userdata' then
            shipName = shipPrefix.getName() .. ' '
        end
    end
    if info.type == 'move' or info.type == 'stationary' then
        if info.collidedShip == nil then
            annString = shipName .. info.note .. ' (' .. info.code .. ')'
            annColor = AnnModule.announceColor.moveClear
        else
            annString = shipName .. info.note .. ' (' .. info.code .. ') but is now touching ' .. info.collidedShip.getName()
            annColor = AnnModule.announceColor.moveCollision
        end
    elseif info.type == 'overlap' then
        annString = shipName .. info.note .. ' (' .. info.code .. ') but there was no space to complete the move'
        annColor = AnnModule.announceColor.moveCollision
    elseif info.type == 'historyHandle' then
        annString = shipName .. info.note
        annColor = AnnModule.announceColor.historyHandle
    elseif info.type == 'action' then
        annString = shipName .. info.note
        annColor = AnnModule.announceColor.action
    elseif info.type:find('error') ~= nil then
        annString = shipName .. info.note
        annColor = AnnModule.announceColor.error
    elseif info.type:find('warn') ~= nil then
        annString = shipName .. info.note
        annColor = AnnModule.announceColor.warn
    elseif info.type:find('info') ~= nil then
        annString = shipName .. info.note
        annColor = AnnModule.announceColor.info
    end

    if target == 'all' then
        printToAll(annString, annColor)
    else
        printToColor(target, annString, annColor)
    end
end

-- Record of players that already got note of some ID
-- Key: playerSteamID
-- Value: table of true's on keys of received noteIDs
AnnModule.notifyRecord = {}

-- Print note to playerColor
-- Any further calls with same noteID will not notify same player
-- Print to everyone if playerColor is 'all'
AnnModule.NotifyOnce = function(note, noteID, playerColor)
    if playerColor == 'all' then
        local seatedPlayers = getSeatedPlayers()
        for _,color in pairs(seatedPlayers) do
            AnnModule.NotifyOnce(note, noteID, color)
        end
    else
        local steamID = Player[playerColor].steam_id
        if AnnModule.notifyRecord[steamID] == nil then
            AnnModule.notifyRecord[steamID] = {}
        end
        if AnnModule.notifyRecord[steamID][noteID] ~= true then
            broadcastToColor(note, playerColor, AnnModule.announceColor.info)
            AnnModule.notifyRecord[steamID][noteID] = true
        end
    end
end


-- END ANNOUNCEMENTS MODULE
--------

--------
-- DIRECT TTS EVENT HANDLING
-- Watch for changed descriptions, handle destroyed objects, saving et cetera

-- ~~~~~~
-- CONFIGURATION:

-- How many frames pass between updating watched objects (ships) list
-- It's so we don't go through massive list of all objects on table each frame (why would we?)
updateFrameInterval = 120
-- ~~~~~~

frameCounter = 0
watchedObj = {}

-- This is called each frame
function update()
    -- If there are no watched objects or frame counter passes threshhold
    if watchedObj[1] == nil or frameCounter > updateFrameInterval then
        watchedObj = {}
        -- Reset the list and add every figurine on the table
        for k,obj in pairs(getAllObjects()) do
            if obj ~= nil and obj.tag == 'Figurine' then
                table.insert(watchedObj, obj)
            end
        end
        frameCounter = 0
    end

    -- If description is not blank, try processing it
    for k, obj in pairs(watchedObj) do
        if obj ~= nil and obj.getDescription() ~= '' then
          Wait.frames(
            function()
              XW_cmd.Process(obj, obj.getDescription())
            end
          , 1) -- Waiting a frame to allow Animated Ships to pick up command

        end
    end

    frameCounter = frameCounter + 1
end

-- When something is destroyed, it is called as an argument here (with 1 more frame to live)
function onObjectDestroyed(dying_object)
    for k, obj in pairs(watchedObj) do if dying_object == obj then table.remove(watchedObj, k) end end
    -- Handle history delete and emergency restore saving
    MoveModule.onObjectDestroyed(dying_object)
    -- Handle killing rulers
    RulerModule.onObjectDestroyed(dying_object)
    -- Handle killing bomb drop templates
    BombModule.onObjectDestroyed(dying_object)
end

-- Report peeking on dials
function onObjectPeek(object, player_color)
    local token_type = object.getVar("__XW_TokenType")
    if token_type == "helper:Dial" then
        if object.is_face_down == false then
            local owning_player = object.getVar("playerColor")
            if owning_player == nil then
                owning_player = "no one"
            end
            if player_color ~= owning_player then
                printToAll(player_color .. " player attempted to peek on ".. object.getName() .. "s dial, owned by " .. owning_player .. "!!",{1,0,0})
            else
                printToAll(player_color .. " peeked on " .. object.getName() .. "s dial", {0.6, 0.6, 1})
                local set_manouver = object.getVar("setMan")
                if set_manouver == "" then
                    printToColor(object.getName() .. "s dial is not yet set" , player_color, {0.6, 0.6, 1})
                else
                    local info = MoveData.DecodeInfo(set_manouver)
                    local manouver = info.speed
                    -- [koiogran] [segnor] [talon] [reverse] [straight] [forward] [backward] [nil]
                    if info.extra == "koiogran" then
                        manouver = manouver .. " " .. info.extra
                    else
                        manouver = manouver .. " " .. info.type
                    end
                    if info.dir ~= nil then
                        manouver = manouver .. " " .. info.dir
                    end
                    if info.extra == "reverse" then
                        manouver = manouver .. " " .. info.extra
                    end
                    printToColor(object.getName() .. "s dial is set to: " .. manouver , player_color, {0.6, 0.6, 1})
                end
            end
        end
    end
end


-- END DIRECT TTS EVENT HANDLING
--------


--------
-- COLLISION CHECKING MODULE
-- Generally checking if two rotated rectangles overlap

-- ~~~~~~
-- CONFIGURATION:

-- How many milimeters should we widen the base from each side
-- With this at zero, sometimes ships overlap after a move
addidionalCollisionMargin_mm = -0.5
-- ~~~~~~

-- General idea here: http://www.gamedev.net/page/resources/_/technical/game-programming/2d-rotated-rectangle-collision-r2604
-- Originally written by Flolania and Hera Verigo, slightly refitted here

-- Return corners of ship base in a {xPos, zPos} table format
-- shipInfo: {ship=shipObjectReference, pos=shipPosition, rot=shipRotation}
function getCorners(shipInfo)
    local corners = {}
    local spos = shipInfo.pos
    local srot = shipInfo.rot[2]
    local baseSize = shipInfo.ship.getTable("Data").Size or 'small'
    local size = Convert_mm_igu((mm_baseSize[baseSize]/2) + addidionalCollisionMargin_mm)
    local world_coords = {}
    world_coords[1] = {spos[1] - size, spos[3] + size}
    world_coords[2] = {spos[1] + size, spos[3] + size}
    world_coords[3] = {spos[1] + size, spos[3] - size}
    world_coords[4] = {spos[1] - size, spos[3] - size}
    for r, corr in ipairs(world_coords) do
        local xcoord = spos[1] + ((corr[1] - spos[1]) * math.sin(math.rad(srot))) - ((corr[2] - spos[3]) * math.cos(math.rad(srot)))
        local ycoord = spos[3] + ((corr[1] - spos[1]) * math.cos(math.rad(srot))) + ((corr[2] - spos[3]) * math.sin(math.rad(srot)))
        corners[r] = {xcoord,ycoord}
    end
    return corners
end

-- Return axes perpendicular to sides of two rectangles
function getAxis(c1,c2)
    local axis = {}
    axis[1] = {c1[2][1]-c1[1][1],c1[2][2]-c1[1][2]}
    axis[2] = {c1[4][1]-c1[1][1],c1[4][2]-c1[1][2]}
    axis[3] = {c2[2][1]-c2[1][1],c2[2][2]-c2[1][2]}
    axis[4] = {c2[4][1]-c2[1][1],c2[4][2]-c2[1][2]}
    return axis
end

function dot2d(p,o)
    return p[1] * o[1] + p[2] * o[2]
end

-- Check if any part of two rectangles overlap
-- Rectangles as in ship bases of a proper size
-- shipInfo: {ship=shipObjectReference, pos=shipPosition, rot=shipRotation}
function collide(shipInfo1, shipInfo2)
    local c2 = getCorners(shipInfo1)
    local c1 = getCorners(shipInfo2)
    local axis = getAxis(c1,c2)
    local scalars = {}
    for i1 = 1, #axis do
        for i2, set in pairs({c1,c2}) do
            scalars[i2] = {}
            for i3, point in pairs(set) do
                table.insert(scalars[i2],dot2d(point,axis[i1]))
            end
        end
        local s1max = math.max(unpack(scalars[1]))
        local s1min = math.min(unpack(scalars[1]))
        local s2max = math.max(unpack(scalars[2]))
        local s2min = math.min(unpack(scalars[2]))
        if s2min > s1max or s2max < s1min then
            return false
        end
    end
    return true
end

-- END COLLISION CHECKING MODULE
--------

-------
-- Local Reference function, for spawning items relative to the quick build card
function LocalPos(object, position)
    local rot = object.getRotation()
    local lPos = {position[1], position[2], position[3]}
    -- Z-X-Y extrinsic
    local zRot = RotMatrix('z', rot['z'])
    lPos = RotateVector(zRot, lPos)
    local xRot = RotMatrix('x', rot['x'])
    lPos = RotateVector(xRot, lPos)
    local yRot = RotMatrix('y', rot['y'])
    lPos = RotateVector(yRot, lPos)

    return Vect_Sum(lPos, object.getPosition())
end

------


--Databases with data for special spawning conditions
--Provides data for the spawner regarding tokens and other accessories

--List of pilots with calculate action
calculateDB = {}
calculateDB['Guri'] = 0
calculateDB['"Leebo"'] = 0
calculateDB['IG%-88A'] = 0
calculateDB['IG%-88B'] = 0
calculateDB['IG%-88C'] = 0
calculateDB['IG%-88D'] = 0
calculateDB['4%-LOM'] = 0
calculateDB['L3%-37'] = 0
calculateDB['Autopilot Drone'] = 0
calculateDB['Feethan Ottraw Autopilot'] = 0
calculateDB['0%-66'] = 0
calculateDB['Precise Hunter'] = 0
calculateDB['DFS%-081'] = 0
calculateDB['Separatist Drone'] = 0
calculateDB['Haor Chall Prototype'] = 0
calculateDB['DFS%-311'] = 0
calculateDB['Trade Federation Drone'] = 0

--Stores cards wich add the Calculate actions
addCalculateDB = {}
addCalculateDB['C3-PO'] = 0

--Store pilots

--[[function onLoad()
    objList=getAllObjects()
    for k, v in pairs(objList) do
        i.hide_when_face_down = false
    end
end]]

function onObjectSpawned(obj)
    obj.hide_when_face_down = false
end


-- Save and load ship data lua scriptState
saveAndLoadShipStateLua = [[

function initContextMenu()
    local added_arcs = {}
    for k, arctype in pairs(self.getTable("Data").arcs) do
        if arctype == 'doubleturret' then
            self.addContextMenuItem("FireArc - Left & Right", function(argument) Global.call("CheckArc", {ship=self,arctype="leftright"}) end, false)
            self.addContextMenuItem("FireArc - Front & Back", function(argument) Global.call("CheckArc", {ship=self,arctype="frontback"}) end, false)
        elseif arctype == 'singleturret' then
            if added_arcs['front'] == nil then
                self.addContextMenuItem("FireArc - Front", function(argument) Global.call("CheckArc", {ship=self,arctype="front"}) end, false)
                added_arcs['front'] = true
            end
            if added_arcs['back'] == nil then
                self.addContextMenuItem("FireArc - Back", function(argument) Global.call("CheckArc", {ship=self,arctype="back"}) end, false)
                added_arcs['back'] = true
            end
            if added_arcs['left'] == nil then
                self.addContextMenuItem("FireArc - Left", function(argument) Global.call("CheckArc", {ship=self,arctype="left"}) end, false)
                added_arcs['left'] = true
            end
            if added_arcs['right'] == nil then
                self.addContextMenuItem("FireArc - Right", function(argument) Global.call("CheckArc", {ship=self,arctype="right"}) end, false)
                added_arcs['right'] = true
            end
        elseif arctype == 'front' then
            if added_arcs['front'] == nil then
                self.addContextMenuItem("FireArc - Front", function(argument) Global.call("CheckArc", {ship=self,arctype="front"}) end, false)
                added_arcs['front'] = true
            end
        elseif arctype == 'back' then
            if added_arcs['back'] == nil then
                self.addContextMenuItem("FireArc - Back", function(argument) Global.call("CheckArc", {ship=self,arctype="back"}) end, false)
                added_arcs['back'] = true
            end
        elseif arctype == 'fullfront' then
            self.addContextMenuItem("FireArc - Full Front", function(argument) Global.call("CheckArc", {ship=self,arctype="fullfront"}) end, false)
        elseif arctype == 'bullseye' then
            self.addContextMenuItem("FireArc - Bullseye", function(argument) Global.call("CheckArc", {ship=self,arctype="bullseye"}) end, false)
        elseif arctype == 'left' then
            if added_arcs['left'] == nil then
                self.addContextMenuItem("FireArc - Left", function(argument) Global.call("CheckArc", {ship=self,arctype="left"}) end, false)
                added_arcs['left'] = true
            end
        elseif arctype == 'right' then
            if added_arcs['right'] == nil then
                self.addContextMenuItem("FireArc - Right", function(argument) Global.call("CheckArc", {ship=self,arctype="right"}) end, false)
                added_arcs['right'] = true
            end
        end
    end

    if Global.getVar('enable_AI') then
        self.AddContextMenuItem("AI maneuver", function(argument) Global.call("PerformAIManeuver", {ship=self}) end, false)
    end
end

-- Save self state
function onSave()
    local state = {shipData=self.getTable("Data")}
    return JSON.encode(state)
end

-- Restore self state
function onLoad(savedData)
    --print("OnLoad: ".. self.getName() .. " " .. savedData)
    if savedData ~= "" and Data == nil then
        local state =  JSON.decode(savedData)
        self.setTable("Data", state.shipData)
        if state.shipData.arcs ~= nil then
            initContextMenu()
        end
    end
end

]]


pilotCardScript =
[[
dial = nil
ship = nil
function addTintObject(params)
    if params[1] == "ship" then
      ship = params[2]
    elseif params[1] == "dial" then
      dial = params[2]
    end
end

function onUpdate()
    local tint = self.getColorTint()
    if tint ~= color(1,1,1,1) then
      self.setColorTint(color(1,1,1,1))
      if dial ~= nil then
        dial.setColorTint(tint)
      end

      for i, attachment in pairs(self.getAttachments()) do
        id = self.removeAttachment(attachment.index)
        id.setColorTint(tint)
        self.addAttachment(id)
      end

      if ship ~= nil then
        for i, attachment in pairs(ship.getAttachments()) do
          id = ship.removeAttachment(attachment.index)
          id.setColorTint(tint)
          ship.addAttachment(id)
        end
      end

    end
end

loaded = false

function onLoad(savestate)
  loaded = true
end

function isLoadedAndStill()
  return loaded and self.resting
end
]]

-------
--spawner function, checks for Pilots and Upgrades lists and spawn the respective objects

function newSpawner(listTable)
    --listTable contains :

    --Pilots[x] = table

    --Upgrades[x] = {string1, string2...}
    --spawnCard = Object reference used to position the spawned material
    --Faction = String

    Pilots = listTable.Pilots
    Upgrades = listTable.Upgrades
    spawnCard = listTable.spawnCard
    Faction = listTable.Faction
    local dialSkin = listTable.factionDial
    spawnedPilotList = {}

    PosBag1 = {5, 5, 0}
    PosBag2 = {10, 10, 0}
    PosBag3 = {15, 15, 0}
    PosBag4 = {20, 20, 0}
    PoaBag5 = {25, 25, 0}
    tempBagAcc = getObjectFromGUID('53ad3d').clone({position = PosBag3}) -- Accessories bag
    tempBagShp = getObjectFromGUID('eb5680').clone({position = PosBag4}) -- Ships bag

    --Stablishes lists of available upgrades, pilots, accessories, ships and mobile upgrades
    listaAcc = tempBagAcc.getObjects()
    listaShp = tempBagShp.getObjects()

    --Store the initial position of the Quick Build Card
    storePos = spawnCard.getPosition()
    storeRot = spawnCard.getRotation()


    shipIndex = 1 --Sets index of ship being spawned

    while Pilots[shipIndex] ~= nil do
        --Values used for accessories spawn and layout
        forceValue = 0
        shieldValue = 0
        UpNum = 0
        Turret  = 0
        dualTurret = 0
        Bombs = 0
        hasMob = 0
        pilotCount = 0
        bombTokenDescription = ''
        local tint = Pilots[shipIndex].tint or color(0,0,0,0)
        -- Spawn Mobile Upgrades
        for j, Up in ipairs(Upgrades[shipIndex]) do
            if  Up['Config'] == true then
                finalPos = LocalPos(spawnCard, {-2, 0, 0})      --Layout adjustment
                spawnCard.setPosition(finalPos)
                pos = LocalPos(spawnCard, {1.5, 0, 5.5})
                rot = spawnCard.getRotation()
                rot.y = rot.y
                cardLink = (Up['card'])
                cardBackLink = (Up['cardB'])
                deck = Decker.Asset(cardLink, cardBackLink)
                card = Decker.Card(deck,1, 1)
                newUp = card:spawn({position = pos, rotation=rot, scale={0.68,0.68,0.68}})
                newUp.setName(Up['name'])
                hasMob = 1
            end
        end
        for j, Up in ipairs(Upgrades[shipIndex]) do
            if Up['Config'] ~= true then                               --Indicates there's a card left of the pilot card, for layout purposes
                pos = LocalPos(spawnCard, {-1.5 - 2*UpNum, 2-0.2*UpNum, 5.5})
                rot = spawnCard.getRotation()
                rot.y = rot.y - 90
                cardLink = (Up['card'])
                cardBLink = (Up['cardB'])
                deck = Decker.Asset(cardLink, cardBLink)
                card = Decker.Card(deck,1, 1)
                local rotUp = rot
                rotUp.y = rotUp.y+90
                newUp = card:spawn({position = pos, rotation=rotUp, scale={0.68,0.68,0.68}})
                newUp.setName(Up['name'])
                if Up['Condition'] ~= nil then                                            --Checks and spawn conditions associated to pilots
                    for k, acc in ipairs(listaAcc) do
                        if acc.name == Up['Condition'] then
                            pos = LocalPos(spawnCard, {-2 - 2*UpNum, 2-0.2*UpNum, 8})
                            rot = spawnCard.getRotation()
                            newAsset = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                            assetClone = newAsset.clone()
                            tempBagAcc.putObject(assetClone)
                        end
                    end
                end
                --Checks and spawns Charge Tokens with appropriate layout (up to 4 tokens)
                charges = Up['Charge']
                while charges > 0 do
                    for k, acc in ipairs(listaAcc) do
                        if acc.name == 'Charge' then
                            if charges == 5 then
                                pos = LocalPos(spawnCard, {-1.7 - 2*UpNum,0, 1.9})
                                rot = spawnCard.getRotation()
                            elseif charges == 4 then
                                pos = LocalPos(spawnCard, {-1.7 - 2*UpNum,0, 2.8})
                                rot = spawnCard.getRotation()
                            elseif charges == 3 then
                                pos = LocalPos(spawnCard, {-2.6 - 2*UpNum,0, 2.8})
                                rot = spawnCard.getRotation()
                            elseif charges == 2 then
                                pos = LocalPos(spawnCard, {-1.7 - 2*UpNum,0, 3.7})
                                rot = spawnCard.getRotation()
                            elseif charges == 1 then
                                pos = LocalPos(spawnCard, {-2.6 - 2*UpNum,0, 3.7})
                                rot = spawnCard.getRotation()
                            else
                                charges = 0
                            end
                            chargeToken = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                            chargeClone = chargeToken.clone()
                            tempBagAcc.putObject(chargeClone)
                            charges = charges-1
                        end
                    end
                end
                UpNum = UpNum + 1                       --Update number of upgrade being spawned
            end
        end

        --Pilot and Ship Spawn
        pilotName = Pilots[shipIndex]['name']
        card = Pilots[shipIndex]['card']
        cardB = Pilots[shipIndex]['cardB']
        pos = LocalPos(spawnCard, {0, 3, 5.5})
        rot = spawnCard.getRotation()
        local newPil = nil
        if card ~= '' then
            if cardB ~= nil then
                deck = Decker.Asset(card, cardB)
                card = Decker.Card(deck,1, 1)
                newPil = card:spawn({position = pos, rotation=rot})
                newPil.setName(pilotName)
                newPil.setLuaScript(pilotCardScript)
                newPil.setLock(true)
                spawnedPilotList[shipIndex] = pilotName                                            --Counts how many pilots already spawned with same name and rename if needed
                pilotCount = 0
                if spawnedPilotList[1] ~= nil then
                    for i, spawned in ipairs(spawnedPilotList) do
                        if spawned == pilotName then
                            pilotCount = pilotCount+1
                        end
                        if pilotCount > 1 then
                            newNum = tostring(pilotCount)
                            newPil.setName(Pilots[shipIndex]['name'] .. ' '..newNum)
                        end
                    end
                end

                -- Spawn Pilot Identifier
                local card = newPil
                local idpos = pos
                local idrot = rot

                pilotIdSpawnFunc = function()
                  local pilotId = spawnObject({
                      type              = "Custom_Model",
                      position          = idpos,
                      rotation          = idrot,
                      scale             = {0.629, 0.629, 0.629},
                      sound             = false,
                      snap_to_grid      = false,
                  })
                  pilotId.setCustomObject({
                      mesh = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/models/cardid.obj',
                      convex = true,
                      material = 1,
                      type = 1
                  })
                  pilotId.setColorTint(tint)
                  card.addAttachment(pilotId)
                  card.setLock(false)
                end
                Wait.condition(pilotIdSpawnFunc , function() return  (not card.spawning) end)

            end
        end
        if pilotName ~= '' then
            for k, acc in ipairs(listaAcc) do
                local card = newPil
                if acc.name == 'Unassigned Dial' then
                    local dialpos = LocalPos(spawnCard, {0, 3, 12})
                    local dialrot = rot
                    local newDial = tempBagAcc.takeObject(
                        {position = dialpos,
                         rotation = dialrot,
                         guid = acc.guid
                       })
                    dialClone = newDial.clone()
                    tempBagAcc.putObject(dialClone)
                    local conditionFunc = function() return (not card.spawning) and (not newDial.spawning) end
                    local executeFunc = function()
                        newDial.setCustomObject({['diffuse']=dialSkin})
                        newDial = newDial.reload()
                        newDial.setColorTint(tint)
                        newDial.setPosition(dialpos)
                        newDial.setRotation(dialrot)
                        card.call('addTintObject', {'dial',newDial})
                      end
                    Wait.condition(executeFunc , conditionFunc)


                end
            end
        end
        forceValue = Pilots[shipIndex]['Force'] --Checks for force value on Pilot and update forceValue
        if Pilots[shipIndex]['Condition'] ~= nil then                                            --Checks and spawn conditions associated to pilots
            for k, acc in ipairs(listaAcc) do
                if acc.name == Pilots[shipIndex]['Condition'] then
                    pos = LocalPos(spawnCard, {-2 - 2*UpNum, 2-0.2*UpNum, 8})
                    rot = spawnCard.getRotation()
                    newAsset = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                    assetClone = newAsset.clone()
                    tempBagAcc.putObject(assetClone)
                end
            end
        end
        local newShip = nil
        pos = LocalPos(spawnCard, {0, 0, 9})
        rot = spawnCard.getRotation()
        for v, ship in ipairs (listaShp) do
            if ship.name == tostring(Pilots[shipIndex]['id']) then
                newShip = tempBagShp.takeObject({ position = pos,
                                                  rotation = rot,
                                                  guid = ship.guid
                                                })
                shipClone = newShip.clone()
                tempBagShp.putObject(shipClone)
                newShip.setPosition(pos)
                newShip.setRotation(rot)
            end
        end
        if (newShip == nil) and (Pilots[shipIndex].id ~= 0) then
          newShip = spawnObject({
              type              = "Custom_Model",
              position          = pos,
              rotation          = rot,
              scale             = {0.629, 0.629, 0.629},
              sound             = false,
              snap_to_grid      = false,
          })
          newShip.setCustomObject({
              convex = true,
              mesh =  '{verifycache}'..Pilots[shipIndex].mesh,
              diffuse = '{verifycache}'..Pilots[shipIndex].texture,
              material = 1,
              type = 1
          })
        end
        if newShip ~= nil then
            newShip.setName(Pilots[shipIndex]['name']) --Corrects ship name for clones
            if Pilots[shipIndex]['Size'] == "small" then
                newShip.setCustomObject({collider= '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/colliders/Small_base_Collider.obj'})
            elseif Pilots[shipIndex]['Size'] == "medium" then
                newShip.setCustomObject({collider= '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/colliders/Medium_base_Collider.obj'})
            elseif Pilots[shipIndex]['Size'] == "large" then
                newShip.setCustomObject({collider= '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/colliders/Large_base_Collider.obj'})
            elseif Pilots[shipIndex]['Size'] == "huge" then
                newShip.setCustomObject({collider= '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/colliders/Huge_base_Collider.obj'})
            end
            newShip.setLock(true)
            newShip.setTable("Data", Pilots[shipIndex]['Data'])
            newShip.setLuaScript(saveAndLoadShipStateLua)
            if spawnedPilotList[1] ~= nil then
                for i, spawned in ipairs(spawnedPilotList) do
                    if spawned == pilotName then
                        pilotCount = pilotCount
                    end
                    if pilotCount > 1 then
                        newNum = tostring(pilotCount)
                        newShip.setName(Pilots[shipIndex]['name'] .. ' '..newNum)
                    end
                end
            end
            local ship = newShip
            local card = newPil
            local idpos = pos
            local idrot = rot
            local customObj = {
                convex = true,
                material = 1,
                type = 1
            }
            if Pilots[shipIndex]['Size'] == "small" then
                customObj.mesh='{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/models/Base_ID_Marker.obj'
            elseif Pilots[shipIndex]['Size'] == "medium" then
                customObj.mesh='{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/models/Base%20ID%20MED.obj'
            elseif Pilots[shipIndex]['Size'] == "large" then
                customObj.mesh='{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/models/Base%20ID%20LAR.obj'
            elseif Pilots[shipIndex]['Size'] == "huge" then
                customObj.mesh='{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/models/Base_ID_HUGE.obj'
            end
            shipIdSpawnFunc = function()
              local shipId = spawnObject({
                  type              = "Custom_Model",
                  position          = idpos,
                  rotation          = idrot,
                  scale             = {0.629, 0.629, 0.629},
                  sound             = false,
                  snap_to_grid      = false,
              })
              shipId.setCustomObject(customObj)
              shipId.setColorTint(tint)
              ship.addAttachment(shipId)
              ship.setLock(false)
              card.call('addTintObject', {'ship',ship})
              ship.call('initContextMenu')
            end
            Wait.condition(shipIdSpawnFunc , function() return (not ship.spawning) and (not card.spawning) end)
        end


        if Pilots[shipIndex]['Ship'] == 3 then
            for k, acc in ipairs(listaAcc) do
                if acc.name == 'StarViper Mk.II roll token' then
                    pos = LocalPos(spawnCard, {-1.5, 3, 8.7})
                    svToken = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                    svClone = svToken.clone()
                    tempBagAcc.putObject(svClone)
                end
            end
        end

        if Pilots[shipIndex]['Turret'] ~= nil then       --Checks if upgrade should trigger the dual mobile arc indicator
            if Pilots[shipIndex]['Turret'] == 2 then
                dualTurret = 1
            else
                Turret = 1
            end
        end
        if Turret == 1 and dualTurret == 0 then                                                       --Checks and spawn arc indicator if needed
            for k, acc in ipairs(listaAcc) do
                if acc.name == 'Arc Indicator'..tostring(Faction) then
                    arcInd = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                    indClone = arcInd.clone()
                    tempBagAcc.putObject(indClone)
                    arcInd.setName(string.gsub(arcInd.getName(), Faction, ''))
                    Turret = 0
                end
            end
        elseif dualTurret == 1 then                                               --Checks and spawn dual arc indicator if needed
            for k, acc in ipairs(listaAcc) do
                if acc.name == 'Dual Arc Indicator'..tostring(Faction) then
                    dualArcInd = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                    indClone = dualArcInd.clone()
                    tempBagAcc.putObject(indClone)
                    dualArcInd.setName(string.gsub(dualArcInd.getName(), Faction, ''))
                    dualTurret = 0
                end
            end
        end
        if Pilots[shipIndex]['Bomb'] == true then                                                       --Checks and spawn bomb drop token if needed
            for k, acc in ipairs(listaAcc) do
                if acc.name == 'Bomb drop token (unassigned)' then
                    pos = LocalPos(spawnCard, {-1.5, 3, 8.7})
                    bombDrop = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                    dropClone = bombDrop.clone()
                    tempBagAcc.putObject(dropClone)
                    bombDrop.setDescription(Pilots[shipIndex]['bombD'])
                end
            end
        end
        if Pilots[shipIndex]['Docking'] == true then
            for k, acc in ipairs(listaAcc) do
                if acc.name == 'Shuttle Launcher (assigned to mothership)' then
                    pos = LocalPos(spawnCard, {-1.5, 3, 8.7})
                    shuttleDrop = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                    dropClone = shuttleDrop.clone()
                    tempBagAcc.putObject(dropClone)
                end
            end
        end
        if Pilots[shipIndex]['Charge'] ~= nil then   --Checks and spawns Charge Tokens with appropriate layout (up to 4 tokens)
            charges = Pilots[shipIndex]['Charge']
            while charges > 0 do
                for k, acc in ipairs(listaAcc) do
                    if acc.name == 'Charge' then
                        if charges == 4 then
                            pos = LocalPos(spawnCard, {-0.9 ,0, 0.6})
                            rot = spawnCard.getRotation()
                        elseif charges == 3 then
                            pos = LocalPos(spawnCard, {0.9 ,0, 1.6})
                            rot = spawnCard.getRotation()
                        elseif charges == 2 then
                            pos = LocalPos(spawnCard, {0 ,0, 1.6})
                            rot = spawnCard.getRotation()
                        elseif charges == 1 then
                            pos = LocalPos(spawnCard, {-0.9 ,0, 1.6})
                            rot = spawnCard.getRotation()
                        else
                            charges = 0
                        end
                        chargeToken = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                        chargeClone = chargeToken.clone()
                        tempBagAcc.putObject(chargeClone)
                        charges = charges-1
                    end
                end
            end
        end
        if Pilots[shipIndex]['id'] ==0 then
            if Pilots[shipIndex]['Turret'] ~= nil then       --Checks if upgrade should trigger the dual mobile arc indicator
                if Pilots[shipIndex]['Turret'] == 2 then
                    dualTurret = 1
                else
                    Turret = 1
                end
            end
            if Turret == 1 and dualTurret == 0 then                                                       --Checks and spawn arc indicator if needed
                for k, acc in ipairs(listaAcc) do
                    if acc.name == 'Arc Indicator'..tostring(Faction) then
                        arcInd = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                        indClone = arcInd.clone()
                        tempBagAcc.putObject(indClone)
                        arcInd.setName(string.gsub(arcInd.getName(), Faction, ''))
                        Turret = 0
                    end
                end
            elseif dualTurret == 1 then                                               --Checks and spawn dual arc indicator if needed
                for k, acc in ipairs(listaAcc) do
                    if acc.name == 'Dual Arc Indicator'..tostring(Faction) then
                        dualArcInd = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                        indClone = dualArcInd.clone()
                        tempBagAcc.putObject(indClone)
                        dualArcInd.setName(string.gsub(dualArcInd.getName(), Faction, ''))
                        dualTurret = 0
                    end
                end
            end
            if Pilots[shipIndex]['Bomb'] == true then                                                       --Checks and spawn bomb drop token if needed
                for k, acc in ipairs(listaAcc) do
                    if acc.name == 'Bomb drop token (unassigned)' then
                        pos = LocalPos(spawnCard, {-1.5, 3, 8.7})
                        bombDrop = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                        dropClone = bombDrop.clone()
                        tempBagAcc.putObject(dropClone)
                        bombDrop.setDescription(Pilots[shipIndex]['bombD'])
                    end
                end
            end
        end
        while Pilots[shipIndex]['Force'] > 0 do
            for k, acc in ipairs(listaAcc) do
                if acc.name == 'Force' then
                    Pilots[shipIndex]['Force'] = Pilots[shipIndex]['Force'] - 1
                    if hasMob == 1 then                 --adjusts layout if Mobile Upgrade is present
                        pos = LocalPos(spawnCard, {1.7 + 0.9*Pilots[shipIndex]['Force'], 0, 3.7})
                        rot = spawnCard.getRotation()
                        if forceValue >2 then
                            pos = LocalPos(spawnCard, {1.7 + 0.9*(Pilots[shipIndex]['Force']-2), 0, 2.8})
                        end
                    else
                        pos = LocalPos(spawnCard, {1.7, 0, 3.7 + 0.9*Pilots[shipIndex]['Force']})
                        rot = spawnCard.getRotation()
                    end
                    forceToken = tempBagAcc.takeObject({position = pos, rotation = rot, guid = acc.guid})
                    forceClone = forceToken.clone()
                    tempBagAcc.putObject(forceClone)
                end
            end
        end
        --Spawns Shields
        while Pilots[shipIndex]['Shield'] > 0 do                                        --spawn shield tokens, layout good for up to 9 shields
            for k, shd in ipairs(listaAcc) do
                if shd.name == 'Shield' then
                    Pilots[shipIndex]['Shield'] = Pilots[shipIndex]['Shield'] - 1
                    pos = LocalPos(spawnCard, { -0.9 + 0.9*Pilots[shipIndex]['Shield'], 0, 3.4})
                    rot = spawnCard.getRotation()
                    if Pilots[shipIndex]['Shield'] >5  then
                        pos = LocalPos(spawnCard, {-0.9 + 0.9*(Pilots[shipIndex]['Shield']-6), 0, 1.6})
                    elseif Pilots[shipIndex]['Shield'] >2 then
                        pos = LocalPos(spawnCard, {-0.9 + 0.9*(Pilots[shipIndex]['Shield']-3), 0, 2.5})
                    end
                    shieldToken = tempBagAcc.takeObject({position = pos, rotation = rot, guid = shd.guid})
                    shieldClone = shieldToken.clone()
                    tempBagAcc.putObject(shieldClone)
                end
            end
        end

        finalPos = LocalPos(spawnCard, {-4 - 2*UpNum, 0, 0})
        spawnCard.setPosition(finalPos)
        shipIndex = shipIndex + 1
        -- Delete cloned bags
        tempBagAcc.destruct()
        tempBagShp.destruct()
    end
    --returns Quick Build Card to initial position
    spawnCard.setPosition(storePos)
    spawnCard.setRotation(storeRot)
end



function RotMatrix(axis, angDeg)
    local ang = math.rad(angDeg)
    local cs = math.cos
    local sn = math.sin

    if axis == 'x' then
        return {
                    { 1,        0,             0 },
                    { 0,   cs(ang),   -1*sn(ang) },
                    { 0,   sn(ang),      cs(ang) }
               }
    elseif axis == 'y' then
        return {
                    {    cs(ang),   0,   sn(ang) },
                    {          0,   1,         0 },
                    { -1*sn(ang),   0,   cs(ang) }
               }
    elseif axis == 'z' then
        return {
                    { cs(ang),   -1*sn(ang),   0 },
                    { sn(ang),      cs(ang),   0 },
                    { 0,                  0,   1 }
               }
    end
end

-- Apply given rotation matrix on given vector
-- (multiply matrix and column vector)
function RotateVector(rotMat, vect)
    local out = {0, 0, 0}
    for i=1,3,1 do
        for j=1,3,1 do
            out[i] = out[i] + rotMat[i][j]*vect[j]
        end
    end
    return out
end

-- Sum of two vectors (of any size)
function Vect_Sum(vec1, vec2)
    local out = {}
    local k = 1
    while vec1[k] ~= nil and vec2[k] ~= nil do
        out[k] = vec1[k] + vec2[k]
        k = k+1
    end
    return out
end

--Decker module

do
    Decker = {}

    -- provide unique ID starting from 20 for present decks
    local nextID
    do
        local _nextID = 20
        nextID = function()
            _nextID = _nextID + 1
            return tostring(_nextID)
        end
    end

    -- Asset signature (equality comparison)
    local function assetSignature(assetData)
        return table.concat({
            assetData.FaceURL,
            assetData.BackURL,
            assetData.NumWidth,
            assetData.NumHeight,
            assetData.BackIsHidden and 'hb' or '',
            assetData.UniqueBack and 'ub' or ''
        })
    end
    -- Asset ID storage to avoid new ones for identical assets
    local idLookup = {}
    local function assetID(assetData)
        local sig = assetSignature(assetData)
        local key = idLookup[sig]
        if not key then
            key = nextID()
            idLookup[sig] = key
        end
        return key
    end

    local assetMeta = {
        deck = function(self, cardNum, options)
            return Decker.AssetDeck(self, cardNum, options)
        end
    }
    assetMeta = {__index = assetMeta}

    -- Create a new CustomDeck asset
    function Decker.Asset(face, back, options)
        local asset = {}
        options = options or {}
        asset.data = {
            FaceURL = face or error('Decker.Asset: faceImg link required'),
            BackURL = back or error('Decker.Asset: backImg link required'),
            NumWidth = options.width or 1,
            NumHeight = options.height or 1,
            BackIsHidden = options.hiddenBack or false,
            UniqueBack = options.uniqueBack or false
        }
        -- Reuse ID if asset existing
        asset.id = assetID(asset.data)
        return setmetatable(asset, assetMeta)
    end

    function Decker.AssetFromData(assetData)
        return setmetatable({data = assetData, id = assetID(assetData)}, assetMeta)
    end

    -- Create a base for JSON objects
    function Decker.BaseObject()
        return {
            Name = 'Base',
            Transform = {
                posX = 0, posY = 5, posZ = 0,
                rotX = 0, rotY = 0, rotZ = 0,
                scaleX = 1, scaleY = 1, scaleZ = 1
            },
            Nickname = '',
            Description = '',
            ColorDiffuse = { r = 1, g = 1, b = 1 },
            Locked = false,
            Grid = true,
            Snap = true,
            Autoraise = true,
            Sticky = true,
            Tooltip = true,
            GridProjection = false,
            Hands = false,
            XmlUI = '',
            LuaScript = '',
            LuaScriptState = '',
            GUID = 'deadbf'
        }
    end
    -- Apply some basic parameters on base JSON object
    function Decker.SetCommonOptions(obj, options)
        options = options or {}
        obj.Nickname = options.name or ''
        obj.Description = options.desc or ''
        obj.LuaScript = options.script or ''
        obj.XmlUI = options.xmlui or ''
        obj.LuaScriptState = options.scriptState or ''
        obj.Locked = options.locked or false
        obj.Tooltip = options.tooltip or true
        obj.GUID = options.guid or 'deadbf'
    end
    -- default spawnObjectJSON params since it doesn't like blank fields
    local function defaultParams(params, json)
        params = params or {}
        params.json = json
        params.position = params.position or {0, 5, 0}
        params.rotation = params.rotation or {0, 0, 0}
        params.scale = params.scale or {1, 1, 1}
        if params.sound == nil then
            params.sound = true
        end
        return params
    end

    -- For copy method
    local deepcopy
    deepcopy = function(t)
        local copy = {}
        for k,v in pairs(t) do
           if type(v) == 'table' then
               copy[k] = deepcopy(v)
           else
               copy[k] = v
           end
        end
        return copy
    end
    -- meta for all Decker derived objects
    local commonMeta = {
        -- return object JSON string, used cached if present
        _cache = function(self)
            if not self.json then
                self.json = JSON.encode(self.data)
            end
            return self.json
        end,
        -- invalidate JSON string cache
        _recache = function(self)
            self.json = nil
            return self
        end,
        spawn = function(self, params)
            params = defaultParams(params, self:_cache())
            return spawnObjectJSON(params)
        end,
        copy = function(self)
            return setmetatable(deepcopy(self), getmetatable(self))
        end,
        setCommon = function(self, options)
            Decker.SetCommonOptions(self.data, options)
            return self
        end,
    }
    -- apply common part on a specific metatable
    local function customMeta(mt)
        for k,v in pairs(commonMeta) do
            mt[k] = v
        end
        mt.__index = mt
        return mt
    end

    -- DeckerCard metatable
    local cardMeta = {
        setAsset = function(self, asset)
            local cardIndex = self.data.CardID:sub(-2, -1)
            self.data.CardID = asset.id .. cardIndex
            self.data.CustomDeck = {[asset.id] = asset.data}
            return self:_recache()
        end,
        getAsset = function(self)
            local deckID = next(self.data.CustomDeck)
            return Decker.AssetFromData(self.data.CustomDeck[deckID])
        end,
        -- reset deck ID to a consistent value script-wise
        _recheckDeckID = function(self)
            local oldID = next(self.data.CustomDeck)
            local correctID = assetID(self.data.CustomDeck[oldID])
            if oldID ~= correctID then
                local cardIndex = self.data.CardID:sub(-2, -1)
                self.data.CardID = correctID .. cardIndex
                self.data.CustomDeck[correctID] = self.data.CustomDeck[oldID]
                self.data.CustomDeck[oldID] = nil
            end
            return self
        end
    }
    cardMeta = customMeta(cardMeta)
    -- Create a DeckerCard from an asset
    function Decker.Card(asset, row, col, options)
        options = options or {}
        local card = Decker.BaseObject()
        card.Name = 'Card'
        -- optional custom fields
        Decker.SetCommonOptions(card, options)
        if options.sideways ~= nil then
            card.SidewaysCard = options.sideways
        end
        -- CardID string is parent deck ID concat with its 0-based index (always two digits)
        local num = (row-1)*asset.data.NumWidth + col - 1
        num = string.format('%02d', num)
        card.CardID = asset.id .. num
        -- just the parent asset reference needed
        card.CustomDeck = {[asset.id] = asset.data}

        local obj = setmetatable({data = card}, cardMeta)
        obj:_cache()
        return obj
    end


    -- DeckerDeck meta
    local deckMeta = {
        count = function(self)
            return #self.data.DeckIDs
        end,
        -- Transform index into positive
        index = function(self, ind)
            if ind < 0 then
                return self:count() + ind + 1
            else
                return ind
            end
        end,
        swap = function(self, i1, i2)
            local ri1, ri2 = self:index(i1), self:index(i2)
            assert(ri1 > 0 and ri1 <= self:count(), 'DeckObj.rearrange: index ' .. i1 .. ' out of bounds')
            assert(ri2 > 0 and ri2 <= self:count(), 'DeckObj.rearrange: index ' .. i2 .. ' out of bounds')
            self.data.DeckIDs[ri1], self.data.DeckIDs[ri2] = self.data.DeckIDs[ri2], self.data.DeckIDs[ri1]
            local co = self.data.ContainedObjects
            co[ri1], co[ri2] = co[ri2], co[ri1]
            return self:_recache()
        end,
        -- rebuild self.data.CustomDeck based on contained cards
        _rescanDeckIDs = function(self, id)
            local cardIDs = {}
            for k,card in ipairs(self.data.ContainedObjects) do
                local cardID = next(card.CustomDeck)
                if not cardIDs[cardID] then
                    cardIDs[cardID] = card.CustomDeck[cardID]
                end
            end
            --[[
            for id,data in pairs(cardIDs) do
                self.data.CustomDeck[id] = data
            end
            for id,data in pairs(self.data.CustomDeck) do
                if not cardIDs[id] then
                    self.data.CustomDeck[id] = nil
                end
            end
            ]]--
            -- eeh, GC gotta earn its keep as well
            self.data.CustomDeck = cardIDs
        end,
        remove = function(self, ind, skipRescan)
            local rind = self:index(ind)
            assert(rind > 0 and rind <= self:count(), 'DeckObj.remove: index ' .. ind .. ' out of bounds')
            local card = self.data.ContainedObjects[rind]
            table.remove(self.data.DeckIDs, rind)
            table.remove(self.data.ContainedObjects, rind)
            if not skipRescan then
                self:_rescanDeckIDs(next(card.CustomDeck))
            end
            return self:_recache()
        end,
        removeMany = function(self, ...)
            local indices = {...}
            table.sort(indices, function(e1,e2) return self:index(e1) > self:index(e2) end)
            for _,ind in ipairs(indices) do
                self:remove(ind, true)
            end
            self:_rescanDeckIDs()
            return self:_recache()
        end,
        insert = function(self, card, ind)
            local rind = self:index(ind)
            assert(rind > 0 and rind <= (self:count()+1), 'DeckObj.insert: index ' .. ind .. ' out of bounds')
            table.insert(self.data.DeckIDs, rind, card.data.CardID)
            table.insert(self.data.ContainedObjects, rind, card.data)
            local id = next(card.data.CustomDeck)
            if not self.data.CustomDeck[id] then
                self.data.CustomDeck[id] = card.data.CustomDeck[id]
            end
            return self:_recache()
        end,
        reverse = function(self)
            local s,e = 1, self:count()
            while s < e do
                self:swap(s, e)
                s = s+1
                e = e-1
            end
            return self:_recache()
        end,
        cardAt = function(self, ind)
            local rind = self:index(ind)
            assert(rind > 0 and rind <= (self:count()+1), 'DeckObj.insert: index ' .. ind .. ' out of bounds')
            local card = setmetatable({data = deepcopy(self.data.ContainedObjects[rind])}, cardMeta)
            card:_cache()
            return card
        end,
        switchAssets = function(self, replaceTable)
            -- destructure replace table into
            -- [ID_to_replace] -> [ID_to_replace_with]
            -- [new_asset_ID] -> [new_asset_data]
            local idReplace = {}
            local assets = {}
            for oldAsset, newAsset in pairs(replaceTable) do
                assets[newAsset.id] = newAsset.data
                idReplace[oldAsset.id] = newAsset.id
            end
            -- update deckIDs
            for k,cardID in ipairs(self.data.DeckIDs) do
                local deckID, cardInd = cardID:sub(1, -3), cardID:sub(-2, -1)
                if idReplace[deckID] then
                    self.data.DeckIDs[k] = idReplace[deckID] .. cardInd
                end
            end
            -- update CustomDeck data - nil replaced
            for replacedID in pairs(idReplace) do
                if self.data.CustomDeck[replacedID] then
                    self.data.CustomDeck[replacedID] = nil
                end
            end
            -- update CustomDeck data - add replacing
            for _,replacingID in pairs(idReplace) do
                self.data.CustomDeck[replacingID] = assets[replacingID]
            end
            -- update card data
            for k,cardData in ipairs(self.data.ContainedObjects) do
                local deckID = next(cardData.CustomDeck)
                if idReplace[deckID] then
                    cardData.CustomDeck[deckID] = nil
                    cardData.CustomDeck[idReplace[deckID]] = assets[idReplace[deckID]]
                end
            end
            return self:_recache()
        end,
        getAssets = function(self)
            local assets = {}
            for id,assetData in pairs(self.data.CustomDeck) do
                assets[#assets+1] = Decker.AssetFromData(assetData)
            end
            return assets
        end
    }
    deckMeta = customMeta(deckMeta)
    -- Create DeckerDeck object from DeckerCards
    function Decker.Deck(cards, options)
        local deck = Decker.BaseObject()
        deck.Name = 'Deck'
        Decker.SetCommonOptions(deck, options)
        deck.DeckIDs = {}
        deck.CustomDeck = {}
        deck.ContainedObjects = {}
        for _,card in ipairs(cards) do
            deck.DeckIDs[#deck.DeckIDs+1] = card.data.CardID
            local id = next(card.data.CustomDeck)
            if not deck.CustomDeck[id] then
                deck.CustomDeck[id] = card.data.CustomDeck[id]
            end
            deck.ContainedObjects[#deck.ContainedObjects+1] = card.data
        end

        local obj = setmetatable({data = deck}, deckMeta)
        obj:_cache()
        return obj
    end
    -- Create DeckerDeck from an asset using X cards on its sheet
    function Decker.AssetDeck(asset, cardNum, options)
        cardNum = cardNum or asset.data.NumWidth * asset.data.NumHeight
        local row, col, width = 1, 1, asset.data.NumWidth
        local cards = {}
        for k=1,cardNum do
            cards[#cards+1] = Decker.Card(asset, row, col)
            col = col+1
            if col > width then
                row, col = row+1, 1
            end
        end
        return Decker.Deck(cards, options)
    end
end

-- for use with Epic Wing Tool to check if the landing space is empty
function epicMoveWingmate(table)
    local ship = table[1]
    local desiredPosRot = {pos=table[2], rot=table[3]}
    print("Ship size=" .. ship.getTable("Data").Size)
    local info = {size=ship.getTable("Data").Size, code="dummy"}
    local fullFunc = function(info,ship) return desiredPosRot end
    result = MoveModule.MoveProbe.TryFullMove(info, ship, fullFunc)
    if result.done then
      MoveModule.MoveShip(ship, {finPos=desiredPosRot})
      return true
    else
      -- Todo announce some stuff
      return false
    end
end
